## **🧠 회고**
​
오늘은 10주차 첫날! 타임리프와 Spring Security의 아키텍처, 인증 흐름을 배웠다. 처음이라 생소하고 복잡했지만, 요청이 어떻게 흐르고 보안 필터들이 어떻게 작동하는지 구조를 이해하니 스프링이 인증을 처리하는 방식이 조금씩 보이기 시작했다. 난이도는 확 올라갔지만, 드디어 핵심 영역에 들어왔다는 느낌이 들어 더 집중해서 따라가고 싶다... 파이팅
​
## **🪽 오늘의 다짐**
​
힘들 수 있다. 힘듦은 상대적이니까. 하지만 그 와중에도 나를 응원해주는 사람들이 있다는 걸 떠올리면, 오히려 내가 더 힘들다고만 할 수는 없겠다는 생각이 들었다. 그 사람들을 위해서라도, 그리고 무엇보다 나 자신을 위해서라도 끝까지 해내고 싶다는 마음이 생긴다.

결국 모든 건 마음가짐에서 시작되는 것 같다. 긍정적으로 생각하고, 어려운 일일지라도 어렵지 않다고 생각하고 별 것 아니라고 생각하기. 인간은 달에 인류를 보냈다. (훨씬 더 어려운 일을 하고, 더 위대한 일을 할 수 있고 잠재력도 있다) 인간은 잠재력이 있는 동물이기에 개인의 역량 상관없이 절대적인 포텐셜은 모두에게 매우 높다. 결론은 별로 안힘들 수 있다는 것. 힘들다고 느껴진다면 그것은 나의 뇌에서 비롯된 할루시네이션이다 (ㅋㅋㅋ) 그냥 하자! 되면 한다 (X) 하면 된다 (O)

​
---
​
## **📝 Today I Learned**
​
### **1️⃣ ThymLeaf**
​
#### **1\. 정의**
​
\- HTML을 템플릿으로 사용해 서버 데이터를 동적으로 출력할 수 있게 해주는 자바 기반 템플릿 엔진
​
\- 정적인 HTML 페이지에 서버에서 넘어온 값을 삽입해 동적으로 변하는 웹페이지를 만들 수 있음
​
\- 일반 HTML 태그 안에 th:text, th:each와 같은 속성을 추가하는 방식으로 동작하기 때문에, 템플릿 파일을 브라우저로 열어도 깨지지 않고 정상적인 HTML 구조로 확인 할 수 있다
​
#### **2\. 동작 구조**
​
**(1) 요청 (브라우저 -> 컨트롤러)**
​
\- 사용자가 URL을 열거나 버튼을 누르면 브라우저가 HTTP 요청을 보냄
​
\- Spring Boot가 자동 등록한 DispatcherServlet이 이 요청을 받아, 매핑 정보(@GetMapping / @PostMapping 등)에 따라 해당 Controller로 전달함
​
**(2) 데이터 준비 (Model 전달)**
​
\- 컨트롤러는 서비스나 리포지토리 등을 호출해 필요한 데이터를 조회, 가공하고, 그 값을 Model에 담아 뷰로 전달할 준비 함
​
\- Model은 일종의 데이터 전달용 저장소로, addAttribute("키", 값) 형태로 저장한 데이터를 뷰 템플릿에서 ${키} 이름으로 꺼내 쓸 수 있음
​
> **❓ 모델에 데이터 저장하면 어떤 형태로 저장됨**  
> Map<String, Object>  
> \- 사실상 키-값 저장소  
> \- 뷰에서 ${name}으로 접근 가능
​
**(3) 뷰 이름 반환 (컨트롤러 -> 뷰리졸버)**
​
\- 컨트롤러는 최종적으로 뷰 이름(String)을 반환함
​
\- 여기엔 파일 경로나 확장자 쓰지 않음
​
\- 이름만 넘기면, 다음 단계의 View Resolver가 실제 템플릿 파일을 찾아줌
​
**(4) 데이터 전달 (모델 -> 타임리프 엔진)**
​
\- 앞서 Model에 담아둔 데이터가 템플릿 엔진(Thymeleaf)로 넘어감
​
\- 템플릿에서 사용할 모든 값이 이 시점에 준비되어 있음
​
\- 없는 키를 참조하면 설정에 따라 빈 값 등으로 처리될 수 있음
​
**(5) 템플릿 선택 (뷰 리졸버 -> 타임리프 엔진)**
​
\- View Resolver가 뷰 이름을 실제 파일로 매핑
​
\- 스프링 부트 기본 설정에 따라 올바른 Tymeleaf 템플릿이 선택되어 엔진으로 넘어감
​
**(6) HTML 생성 (타임리프 엔진 -> HTML 응답)**
​
\- Tymeleaf 엔진이 템플릿의 th:text, th:each, th:if 등 표현식을 해석하고, Model 데이터를 치환, 반복, 조건 처리하여 최종 HTML을 만듦
​
\- 그 결과는 응답 바디에 담김
​
\- 상태코드와 Content-Type: text/html; charset=UTF-8 헤더가 함께 설정됨
​
**(7) 브라우저 표시 (HTML 응답 -> 브라우저)**
​
\- 브라우저는 수신한 HTML을 파싱해 DOM을 렌더링하고, 연동된 CSS/JS를 적용해 화면을 표시함
​
#### **3\. 사용 이유**
​
\- HTML 그대로를 유지하면서 서버 데이터를 동적으로 반영할 수 있어, 개발자와 디자이너가 같은 템플릿으로 협업하며 안정적으로 웹 페이지를 만들 수 있기 때문
​
**(1) HTML 친화성**
​
\- 원본 HTML 구조를 그대로 유지하면서 th:\* 속성만 추가하면 동작함
​
**(2) Spring MVC와 자연스러운 연동**
​
\- 컨트롤러가 Model에 담은 데이터를 ViewResolver가 선택한 템플릿에 그대로 전달하여 서버 사이드 렌더링을 수행함
​
**(3) 폼 바인딩과 검증**
​
\- th:object, th:field, th:error 속성을 사용하면 자바 객체와 입력 필드를 매끄럽게 연결 가능
​
\- 검증 실패시 에러 메시지를 자동으로 표시 가능
​
\- 입력 폼 개발 속도가 빨라짐
​
\- 사용자에게 일관된 피드백 제공 가능
​
**(4) 레이아웃과 프래그먼트 재사용**
​
\- 헤더, 푸터, 메뉴 같은 공통 요소를 th:fragment로 정의하고 필요할 때 th:replace 로 불러올 수 있음
​
\- 화면 전반에 일관된 디자인을 유지하면서도 유지보수가 훨씬 간단해짐
​
**(5) 표현식과 유틸리티**
​
\- #dates, #numbers, #strings 등 내장 유틸리티와 조건, 반복 표현식을 활용하여 템플릿 안에서 데이터 가공을 안전하고 간단하게 처리 가능
​
\- 불필요한 자바 코드나 복잡한 로직 없이 직관적으로 화면 구성 가능
​
**(6) 보안과 거버넌스**
​
\- 서버에서 최종 HTML을 만들어 내려주기 때문에 민감한 로직이나 데이터가 브라우저에 직접 노출되지 않음
​
\- 보안 규정 준수와 접근 제어를 서버단에서 강제할 수 있어 안정적인 운영에 유리
​
#### **4\. 사용 방법**
​
\- HTMl 템플릿 안에 th:\* 속성을 사용하여 컨트롤러가 전달한 데이터를 조건, 반복, 치환 형태로 반영하고, 브라우저에 안전하게 렌더링
​
#### **5\. 기본 문법**
​
**(1) th: text**
​
\- 서버에 전달된 값을 HTML 태그 안의 텍스트로 출력함
​
**(2) th:utext**
​
\- 서버에 전달된 값을 HTML 태그 그대로 출력함
​
**(3) th: each**
​
\- 리스트나 배열 데이터를 순환하면서 반복 출력함
​
**(4) th:if / th:unless**
​
\- 조건에 따라 HTML 태그를 보이거나 숨김
​
**(5) th:attr**
​
\- 기존 HTML 속성 자체를 동적으로 변경 가능
​
**(6) th:value, th:href, th:src**
​
\- 특정 속성 값 (입력값, 링크, 이미지 경로 등)을 서버 데이터로 치환함
​
**(7) ${...}**
​
\- Model에 담긴 객체의 값을 참조함
​
**(8) {...}**
​
\- 특정 객체를 선택해 그 객케의 필드를 참조함
​
**(9) #{...}**
​
\- 국제화(i18n) 메시지를 불러올 때 사용함
​
\- 국제화(i18n)ㅣ 하나의 소스 코드로 여러 언어와 지역을 지원할 수 있도록 문구를 외부 파일로 분리해 관리하는 방식을 말함
​
**(10) @{...}**
​
\- URL을 동적으로 생성함
​
\- 컨텍스트 경로를 고려해 안전하게 경로를 만들어줌
​
---
​
### **2️⃣ Spring**
​
스프링이 나오기 전에는 EJB라고 하는 기술을 사용해서 개발을 했었음
​
하지만 너무 무겁고 불편하고 좋지 않고 복잡한 설정이랑 반복적인 코드가 많았음
​
EJB를 이용해서 개발하던 시기를 자바 개발자들의 혹한기..
​
\-> Spring을 사용해서 편리하게 개발을 하게 되어서 자바 개발자들에게 봄이 왔다!
​
하지만 스프링도 여전히 아쉬움... 그래서 우리는 지금 스프링 부트를 사용하고 있다
​
#### **1\. 정의**
​
\- 자바 애플리케이션에서 객체 생성과 의존성 관리를 자동화해 구조를 단순하고 유연하게 만드는 프레임 워크
​
\- 객체를 직접 만들고 연결하는 책임을 개발자가 아니라 Spring 컨테이너가 대신 가짐
​
👉🏻 프로그램의 제어 흐름을 개발자가 아닌 프레임워크가 관리하는 방식 (제어의 역전: IoC)
​
> **❓ 스프링 컨테이너**  
> \- 스프링이 객체를 생성하고 관리하는 공간  
> \- 개발자가 직접 new로 만들지 않아도, 필요한 객체를 대신 만들고 보관해줌  
> \- 객체들 간의 의존 관계를 연결해주고, 생명주기까지 관리함
​
\- 애플리케이션이 실행되면 스프링은 미리 설정된 정보를 바탕으로 필요한 객체들을 생성해두고, 이 객체들을 관리하는 컨테이너에 보관함
​
👉🏻 그리고 어떤 클래스가 그 객체가 필요하다고 하면, 스프링은 컨테이너에서 그 객체를 꺼내서 넣어줌
​
👉🏻 의존성 주입
​
\- 스프링이 애플리케이션 전체에서 객체의 생성, 보관, 주입 과정을 대신 담당함
​
#### **2.  사용 이유**
​
\- 객체 관리와 설정을 자동화하여 개발 생산성과 유지보수성을 높임
​
\- 대규모 시스템에서도 안정적이고 확장 가능한 애플리케이션을 만들 수 있음
​
**(1) 객체 관리의 자동화(IoC / DI)**
​
\- 애플리케이션의 객체 생성, 생명주기, 의존 관계를 컨테이너가 맡아 코드 곳곳의 new 결합을 제거함
​
\- 설계 변경이나 구현 교체가 필요해도 인터페이스 기반 주입으로 수정 범위를 최소화하여 구조가 단순하고 유연해짐
​
**(2) 대규모 시스템에 맞는 확장성**
​
\- 모듈화된 아키텍처와 풍부한 서브프로젝트로 작은 서비스부터 대규모 엔터프라이즈까지 자연스럽게 확장됨
​
**(3) 표준화된 개발 방식**
​
\- 전 세계적으로 검증된 관례와 스타터 의존성 구성이 표준 개발 흐름 제공
​
**(4) 생산성과 편의성**
​
\- 스프링 부트의 자동설정과 내장서버 덕분에 별도 WAS 설치와 복잡한 XML 없이 즉시 실행형 개발이 가능
​
\- 반복적인 인프라 코드를 최소화해 개발자는 비즈니스 로직에 집중할 수 있고, 초기 설정과 배선 작업 시간을 크게 절감 가능
​
**(5) 테스트와 품질 보장**
​
\- DI 구조로 Mock/Fake 주입이 쉬워 단위/통합 테스트 작성이 자연스러움
​
\- JUnit, Mockito와의 연동으로 TDD 사이클 원활히 돌릴 수 있음
​
> **❓ TDD**  
> 테스트를 먼저 만들고 → 그 테스트를 통과하는 최소한의 코드를 만들고 → 리팩터링하는 개발 방식
​
#### **3\. 동작 방식**
​
\- 객체의 생성과 의존성 관리를 컨테이너가 대신 맡아, 필요한 곳에 자동으로 주입함으로써 애플리케이션을 단순하고 유연하게 동작
​
(제어의 역전: IoC)
​
**(1) IoC (제어의 역전)**
​
\- 객체를 직접 만들고 관리하던 개발자 대신, 스프링이 객체를 생성하고 관리하는 것
​
**(2) DI (의존성 주입)**
​
\- 스프링이 필요한 객체(의존성)를 알아서 넣어주는 것
​
\- IoC가 '객체를 스프링이 만든다'라면, DI는 '만든 객체를 스프링이 넣어준다'
​
**(3) AOP (관점 지향 프로그래밍)**
​
\- 핵심 기능과 공통 기능을 분리해 관리하는 기법
​
\- 여러 곳에 흩어져 반복적으로 등장하는 공통 기능을 핵심 로직에서 분리해 별도로 관리할 수 있도록 함
​
\- 횡단 관심사를 비즈니스 로직에서 분리
​
> **❓ 횡단 관심사**  
> \- 애플리케이션 여러 부분에서 공통적으로 필요하지만, 핵심 로직과는 직접 관련 없는 기능  
> \- 메서드 실행 시간을 기록하느 로깅, 사용자 인증/권한 확인, 트랜잭션 시작과 종료 등
​
**(4) JDBC**  
\- 자바에서 데이터베이스에 접속하고 SQL을 실행할 수 있게 하는 표준 인터페이스
​
\- JDBC Template으로 중복되는 코드 자동 처리
​
\- JPA / Hibernate: SQL을 직접 안쓰고 객체로 DB 조작
​
**(5) Servlet / Spring MVC**
​
\- Spring MVC는 서블릿 기반의 전통적인 MVC(Model - View - Controller) 패턴을 지원하는 웹 프레임워크
​
\- 컨트롤러, 뷰, 모델을 명확히 분리해 웹 요청을 처리하고 응답을 돌려줌
​
> **❓ 서블릿**  
> \- 자바 기반의 웹 애플리케이션에서 요청과 응답을 처리하는 기본 단위 프로그램  
> \- 웹 브라우저가 보낸 요청(예: 로그인, 회원가입)을 받아서 자바 코드로 처리하고, 그 결과를 HTML 등으로 응답함
​
**(6) WebSocket**
​
\- 서버와 클라이언트가 실시간 양방향 통신을 할 수 있게 함
​
\- HTTP 요청/응답 구조와 달리, 연결이 유지되는 동안 서버가 먼저 메세지 보낼 수도 있음
​
\- 채팅 서비스, 실시간 알림, 주식 시세 전송 같은 즉각 반응이 필요한 기능을 쉽게 구현 가능
​
#### **4\. 싱글톤**
​
**(1) 정의**
​
\- 하나의 클래스에서 객체를 단 하나만 만들어 애플리케이션 전체에서 함께 쓰는 방식
​
\- 여러번 new를 호출해도 실제로는 같은 객체 하나를 공유함
​
\- 스프링에서 특별히 설정하지 않으면, 등록된 Bean은 기본적으로 싱글톤 범위로 관리됨
​
**(2) 사용 이유**
​
\- 성능: 한 번 생성한 객체를 계속 재사용하기에 성능 최적화
​
\- 일관성: 동일한 서비스 객체를 여러 곳에서 공유하기 때문에 상태가 통일되어 일관성 유지
​
\- 관리 효율성: 스프링 컨테이너가 객체의 생성과 소멸을 대신 관리해주므로 개발자가 직접 생명주기를 신경 쓰지 않아도 됨
​
---
​
### **3️⃣ Spring Boot**
​
#### **1\. 정의**
​
\- 스프링 애플리케이션을 빠르고 쉽게 개발할 수 있도록 설정과 배포를 자동화한 프레임워
​
**(1) 자동 설정**
​
\- 애플리케이션 실행 시 classpath 안에 spring-webmvc 라이브러리가 있음
​
👉🏻 Boot는 이를 감지하고 Spring MVC, DispatcherServlet, 기본 에러 페이지, JSON 변환기(Jackson) 등을 자동 등록
​
👉🏻 자동 설정은 내부적으로 @Conditional 같은 어노테이션을 이용해 "라이브러리가 있으면 Bean을 등록하고, 없으면 하지 않는다" 방식으로 동작함
​
👉🏻 덕분에 개발자가 일일이 XML이나 자바 설정 클래스를 작성하지 않아도 됨
​
👉🏻 Boot가 "이 프로젝트는 웹 애플리케이션이구나" 판단해 필요한 Bean 미리 준비해줌
​
> **❓ @Conditional**  
> \- 특정조건이 만족될 때만 Bean이나 설정을 적용하도록 하는 Spring 어노테이션  
> \- 어떤 라이브러리가 classpath에 있을 때만 Bean을 등록하거나, 특정 프로퍼티 값이 설정된 경우에만 동작하도록 만들 수 있음
​
**(2) Starter 의존성 관리**
​
\- Starter라는 의존성 패키지 모음 제공
​
\- Starter는 기능별로 필요한 라이브러리를 세트로 묶어둠
​
\- 개발자는 spring-boot-starter-XXX 형태의 Starter 하나만 추가하면 됨
​
**(3) 내장 서버**
​
\- Tomcat을 내장 서버 형태로 포함함
​
\- 별도의 서버 설치 없이 애플리케이션 바로 실행 가능
​
\- main() 메서드만 실행하면 내장 Tomcat이 함께 뜨면서 웹 애플리케이션이 곧바로 동작함
​
\- 배포 방식 단순화
​
> **❓ Tomcat**  
> \- 자바 웹 애플리케이션을 실행해주는 서블릿 컨테이너  
> \- 자바 코드(서블릿, JSP, 스프링)을 실행해주는 프로그램  
> \- 브라우저 요청을 받아서 Java 웹 로직을 처리해주는 서버
​
#### **2\. 사용 이유**
​
\- 복잡한 설정과 배포 부담을 줄여 개발자가 핵심 로직에 집중하고 더 빠른 결과 낼 수 있음
​
#### **3\. Spring MVC**
​
\- 스프링 프레임워크에서 제공하는 웹 애플리케이션 개발을 위한 아키텍처
​
\- Model-View-Controller 패턴을 기반으로 함
​
\- 웹 요청을 처리하는 과정을 역할별로 분리하여, 코드의 복잡성을 줄이고 유지보수성 높임
​
**(1) Model**
​
\- 화면에 보여줄 데이터와 비즈니스 로직 담음
​
\- 컨트롤러는 필요한 데이터를 Model 객체에 실어 뷰로 전달함
​
**(2) View**
​
\- 최종적으로 사용자에게 보여지는 화면
​
\- JSP, Tymeleaf 같은 템플릿 엔진이 View 담당
​
**(3) Controller**
​
\- 사용자의 요청을 받아 처리 흐름을 제어하는 역할
​
\- 어떤 서비스 로직을 호출할지, 어떤 뷰로 데이터를 넘길지 결정
​
---
​
### **4️⃣ Spring Security**
​
#### **1\. 정의**
​
\- 스프링 프레임워크 위에서 동작하며, 웹 애플리케이션의 보안 관련 기능을 체계적으로 처리해주는 하위 프레임 워크
​
\- 사용자가 누구인지 확인하는 인증 / 인증된 사용자가 어떤 작업을 수행할 수 있는지 권한을 부여하는 인가
​
\- 개발자가 직접 세션 관리, 비밀번호 암호화, CSRF 공격 방어 같은 복잡한 보안로직을 구현하지 않아도, spring security가 제공하는 표준화된 구조를 통해 안전하게 애플리케이션 보호 가능
​
#### **2\. 배경 지식**
​
**(1) HTTP의 Stateless 특성**
​
\- HTTP는 상태가 없는 프로토콜
​
\- 서버가 클라이언트의 이전 요청을 기억하지 못함
​
\- 매번의 요청은 완전히 독립적인 트랜잭션으로 처리됨
​
👉🏻 서버의 확장성을 높여줌
​
👉🏻 사용자가 로그인을 한 후 다른 페이지로 이동하면, 서버는 방금 로그인한 사용자가 누구인지 알지 못함
​
👉🏻 쿠키와 세션, 토큰 같은 기술을 사용하여 사용자의 상태 유지
​
**(2) 인증 vs 인가**
​
\- 인증: 사용자가 자신의 신원을 증명하는 과정
​
\- 인가: 인증된 사용자가 특정 리소스에 접근하거나 특정 기능을 실행할 권한이 있는지 확인하는 과정
​
\- 항상 인증이 인가보다 먼저 수행됨
​
**(3) 웹 요청의 흐름**
​
\- Servlet filte
​
👉🏻 요청이 스프링 영역으로 들어오기 전, 서블릿 컨테이너 레벨에서 가장 먼저 요청을 가로챔
​
👉🏻 인코딩 변환, 로깅, Spring Security의 보안 검사가 이 단계에서 이루어짐
​
\- DispatcherServlet
​
👉🏻 스프링 MVC의 핵심
​
👉🏻 모든 요청을 받아 적절한 컨트롤러에 전달하는 프론트 컨트롤러 역할
​
\- Interceptor
​
👉🏻 DispatcherServlet이 Controller를 호출하기 전후에 특정 로직을 수행할 수 있도록 함
​
\- Controller
​
👉🏻 실제 비즈니스 로직을 처리하는 최종 목적지
​
#### **3\. 사용 이유**
​
\- 웹 애플리케이션에서 반복적으로 구현해야 하는 인증, 인가, 보안 위협 방어 로직을 표준화된 방식으로 안전하고 편리하게 처리하기 위함
​
\- 보안 로직과 비즈니스 로직이 분리되어 코드의 유지보수성 향상
​
\- 검증된 보안 아키텍처를 통해 애플리케이션의 안정성 크게 높일 수 있음
​
#### **4\. 동작 원리 : Spring Security 아키텍처**
​
**(1) DelegatingFilterProxy**
​
\- 서블릿 필터 체인에 포함되는 대표 필터
​
\- 보안 로직을 직접 처리하지 않고 Spring Security 쪽에 위임 (delegete)
​
\- 이유: 서블릿 필터는 스프링 컨테이너를 모름 -> 두 컨테이너를 연결해주는 다리 역할
​
\- 역할: Tomcat에서 Spring Security로 요청을 전달하는 중간 게이트 웨이
​
**(2) FilterChainProxy**
​
\- DelegatingFilterProxy로부터 위임받아 실제 보안 로직을 처리하는 필터 집합
​
\- 여러 Security FilterChain(여러 보안 필터 목록)을 관리하고 실행함
​
\- URL 요청마다 적절한 필터들을 선택해 순서대로 동작시킴
​
\- 필터 체인 구조이므로
​
👉🏻 중간에 하나라도 실패하면 즉시 요청 차단
​
👉🏻 컨트롤러까지 절대 도달하지 못함
​
\- 덕분에 보안 로직과 비즈니스 로직이 완전히 분리됨
​
#### **5\. 사용 방법**
​
\- SecurityFilterChain을 Bean으로 등록하고, HttpSecurity DSL을 사용해 요청별 접근 제어, 로그인/로그아웃 처리 등을 구성함
​
#### **6\. SecurityContextHolder와 인증 객체**
​
**(1) 정의**
​
\- 스프링 시큐리티가 현재 인증된 사용자 정보를 저장해두는 저장소
​
\- 이곳에 Authentication 객체가 들어있음
​
**(2) 사용 이유**
​
\- 매번 DB에서 사용자 정보를 조회하면 성능이 나빠짐
​
\- 그래서 한 번 인증된 사용자 정보는 메모리(서버 내부) 어딘가에 저장
​
\- SecurityContextHolder
​
**(3) 내부 저장 방식 = ThreadLocal**
​
\- ThreadLocal은 각 스레드마다 독립적인 개인 저장소
​
\- HTTP 요청 1개 = 스레드 1개가 처리
​
\- 로그인 성공 시 인증 필터가 Authentication을 ThreadLocal에 저장
​
\- 그래서 같은 요청 안에서는 SecurityContextHolder.getContext().getAuthentication() 로 어느 계층에서도 접근 가능
​
\- 요청이 끝나면 ThreadLocal 비워짐 -> 다른 요청과 섞일 일 없음
​
**(4) 장점**
​
\- 사용자 정보를 메소드 파라미터로 계속 전달할 필요 없음
​
\- 어디서든 SecurityContextHolder를 통해 바로 조회
​
\- 요청별로 격리되므로 다른 사용자의 정보가 섞이지 않음
​
#### **7\. CSRF**
​
\- 사이트 간 요청 위조
​
\- 공격자가 인증된 사용자의 권한을 도용하여, 사용자가 의도하지 않은 요청을 서버에 보내도록 만드는 공격
​
\- 스프링 시큐리티는 기본적으로 CSRF 방어 기능이 활성화되어 있음
​
\- 상태를 변경하는 요청에 대해 CSRF 토큰을 검증하는 방식으로 이를 막음
​
#### **8\. CORS**
​
\- 교차 출처 리소스 공유
​
\- 공격 기법이 아니라, 브라우저의 동일 출처 정책을 안전하게 우회하여 다른 출처의 리소스를 사용할 수 있도록 허용하는 W3C 표준 매커니즘
​
\- 프론트엔드와 백엔드 서버가 분리된 현대적인 아키텍처에서는 반드시 CORS 설정을 통해 특정 출처의 요청을 허용해주어야 정상적인 통신이 가능하다
​
---
​
### **5️⃣ Spring Security - 아키텍처**
​
#### **1\. 정의**
​
\- 여러 기술이 각자의 역할과 실행 시점을 가지고 계층적으로 동작하는 구조 전체
​
\- 서블릿 필터 기반의 연쇄적인 보안 처리 구조를 핵심으로 함
​
\- 사용자의 HTTP 요청이 스프링의 DispatcherServlet에 도달하기 전에, 여러 보안 필터들로 구성된 SecurityFilterChain을 먼저 통과함
​
👉🏻 각 필터는 인증, 인가, CSRF 방어, 세션 관리 등 저마다의 역할을 수행
​
👉🏻 모든 필터를 통과해야만 비로소 요청이 안전하다고 판단되어 컨트롤러로 전달됨
​
👉🏻 이 과정에서 인증이 성공하면, 사용자의 정보는 SecurityContext에 담겨 SecurityContextHolder를 통해 어디서든 접근할 수 있는 상태가 됨
​
👉🏻 또한 필요에 따라 스프링 MVC의 HandlerInterceptor나 AOP를 이용해 더 세분화된 보안 규칙을 적용할 수 있음
​
#### **2\. 알아야하는 이유**
​
\- 요청 처리 흐름 속에서 인증과 인가가 어느 시점에, 어떤 기술로 처리되는지 이해하여 보안 규칙을 정확히 설정하고 문제를 해결하기 위함
​
#### **3\. 동작 방식**
​
**(1) DelegatingFilterProxy**
​
\- 서블릿 컨테이너와 스프링 컨테이너를 연결해주는 프록시 필터
​
\- 톰캣(WAS)은 자기만의 서블릿 필터 체인을 가지고 있음
​
\- 스프링 시큐리티는 여기에 DelegatingFilterProxy 하나만 등록
​
\- 이 필터는 직접 보안 작업을 하지 않음
​
\- 역할
​
👉🏻 서블릿 필터와 스프링 빈을 연결해주는 다리
​
👉🏻 덕분에 스프링 시큐리티의 보안 필터들을 스프링 빈으로 관리(DI, AOP 가능)
​
**(2) FilterChainProxy**
​
\- 요청 URL을 보고 적절한 보안 필터 체인을 선택하고 실행하는 보안 라우터
​
\- DelegatingFilterProxy가 호출하는 스프링 빈
​
\- 여러 SecurityFilterChain(필터 목록)을 관리
​
\- 요청 URL을 보고 어떤 필터 체인을 적용할지 결정
​
\- 구조
​
👉🏻 필터 체인을 선택하고 각 필터를 순서대로 실행
​
**(3) SecurityFilterChain**
​
\- 요청이 반드시 통과해야 하는 보안 관문들
​
\- FilterChainProxy가 선택한 해당 요청용 필터 집합
​
\- 보안 필터들이 정해진 순서로 등록되어 있음
​
\- 특징
​
👉🏻 필터 하나라도 실패하면 즉시 요청 차단
​
👉🏻 모든 필터 통과해야만 DispatcherServlet -> Controller 진입 가능
​
**(4) UsernamePasswordAutehnticationFilter**
​
\- 로그인 요청 처리 -> 인증 성공 시 인증 객체 생성
​
\- 예시: 로그인 요청일 때 동작
​
👉🏻 사용자가 /login 요청으로 ID/Password 전달
​
👉🏻 필터가 username, password 꺼냄
​
👉🏻 AuthenticationManager에게 인증 요청
​
👉🏻 인증 성공: Authentication 객체 생성, SecurityContext에 저장
​
👉🏻 인증 실패: 즉시 요청 중단, 에러 반환
​
**(5) SecurityContextHolder & SecurityContext**
​
\- 로그인한 사용자 정보를 요청 동안 스레드 단위로 안전하게 보관
​
\- 인증 성공 시 생성된 Authentication 객체 저장
​
\- Storage 전략
​
👉🏻 기본이 ThreadLocal
​
👉🏻 요청 하나 = 스레드 하나
​
👉🏻 스레드 안에서만 접근 가능 -> 사용자 정보가 다른 사용자와 섞이지 않음
​
\- 요청 전 범위에서 사용 가능
​
**(6) 필터들이 모두 통과하면 -> DispatcherServlet -> Controller**
​
\- 보안 검증이 끝난 요청만 컨트롤러로 들어옴
​
\- 서비스/레포지토리 단계에서도 SecurityContextHolder를 통해 인증 정보 사용 가능
​
> **❓ Stateless(JWT) 환경에서도 SecurityContextHolder는 동일하게 동작하나요?**  
> \- SecurityContextHolder는 세션/ JWT 모두 동일하게 동작한다.  
> \- 차이  
> 👉🏻 Authentication을 누가 어떻게 채워넣느냐  
> 👉🏻 세션: 서버가 저장해둔 인증 정보를 재사용  
> 👉🏻 JWT: 매 요청마다 JWT 필터가 새로 인증 정보를 생성
