## **🧠 회고**

오늘은 React의 핵심인 JSX, 컴포넌트, 가상 DOM(Virtual DOM)의 개념들을 배우며 프론트엔드 구조가 어떻게 구성되는지 한층 더 선명하게 이해한 하루였다. JSX가 단순한 HTML이 아니라 자바스크립트로 UI를 표현하는 문법이라는 점, 컴포넌트가 화면을 작은 단위로 나눠 재사용성과 유지보수성을 높여준다는 점이 특히 인상 깊었다. 또한 렌더링 성능의 핵심이라고 할 수 있는 VDOM이 실제 DOM 조작을 최소화해 효율적으로 UI를 업데이트한다는 흐름을 알게 되면서 React가 왜 이렇게 널리 쓰이는지 자연스럽게 납득할 수 있었다. 전체적으로 새로운 개념들이 많아서 어려웠지만, 프레임워크가 돌아가는 원리를 이해하게 된 만큼 앞으로 React를 다룰 때 훨씬 수월해질 것 같다.

## **🪽 오늘의 다짐**

이제 본격적인 프론트엔드 주차가 시작된 만큼, 더 집중해서 배우고 더 열심히 해보자. 지금 쌓는 경험과 이해가 앞으로의 프론트엔드 실력을 결정할 테니, 매 순간 최선을 다하며 한 단계씩 확실하게 성장하자.

---

## **📝 Today I Learned**

### **1️⃣ React**

#### **1\. 정의**

\- 컴포넌트 단위로 구성된 사용자 인터페이스(UI)를 선언적으로 구축할 수 있는 자바스크립트 라이브러리

\- 직관적이고 단순한 사용법을 제공

\- 대규모 애플리케이션 개발환경에서 높은 확장성과 유지보수성 보장

> ❓ UI의 상태(state) 변화  
> \- 화면에 무엇을 어떻게 그려야 할지를 결정하는 데이터가 바뀌는 것  
> \- 리액트는 이 데이터(=상태)를 기준으로 UI를 함수처럼 계산함  
> \- 상태는 숫자, 문자열, 불리언, 객체/배열 같은 지금 이 순간 화면에 영향을 주는 값  
> \- 값이 바뀌면 화면도 바뀜

> ❓ 선언적 작성 vs 명령형 작성  
> \- 선언적 작성: 결과(what)를 코드에 작성하는 방식  
> \- 명령형 작성: 어떻게(How) 그 결과를 얻을지 하나 하나 작성하는 방식  
> \- 선언적 작성은 상태에 따라 결과만 작성해 두면 내부 동작은 React가 안전하게 처리해줌

#### 2\. 사용 이유

\- 복잡한 UI를 선언적으로 구성하여 유지보수성과 재사용성을 높이기 위해 사용

\- 현대적인 웹 애플리케이션의 복잡한 UI, 비즈니스 로직을 구분하고 더 중요한 가치에 집중 가능

(1) 생산성: 컴포넌트 재사용으로 개발 속도가 빨라짐

(2) 유지보수성: 선언적 코드 덕분에 코드 이해하고 읽기 쉬움. 데이터 흐름이 명확함.

(3) 성능: VDOM 덕분에 잦은 데이터 변경해도 브라우저가 효율적으로 동작함

> ❓ 비즈니스 로직  
> \- 웹사이트나 서비스가 실제로 해야하는 핵심 기능과 규칙  
> \- UI처럼 단순히 보여지는 것이 아니라, 사용자의 행동에 따라 어떤 일이 벌어져야 하는지를 정의한 규칙과 처리 과정

\- 리액트는 컴포넌트 기반 아키텍처를 활용해 애플리케이션에 필요한 구성 요소를 독립적인 단위로 나누어 관리함

\- 하나의 코드 파일이 거대해지는 것 방지 가능

\- 코드 재사용성과 유지 보수성 높아짐

\- 데이터 흐름을 단 방향으로 통제해 대규모 애플리케이션의 복잡한 상태 관리를 보다 체계적이고 안정적으로 예측 가능한 개발 가

> ❓컴포넌트 기반 아키텍처  
> \- UI를 버튼, 입력창, 카드, 페이지 등 하나의 역할을 가진 작은 조각(컴포넌트)으로 쪼개서 만드는 방식  
> \- 각 컴포넌트는 독립적으로 동작하며 필요한 데이터만 받아서 스스로 화면을 렌더링함  
> \- 같은 컴포넌트를 여러 곳에서 재사용 가능  
> \- 수정이 필요해도 해당 컴포넌트만 고치면 전체 화면에 반영되기에 유지보수 훨씬 쉬움

> ❓ 데이터 흐름 단방향  
> \- 상태가 항상 한 곳 (부모 컴포넌트) 에서만 관리되고, 필요한 화면(자식 컴포넌트)으로만 흘러 내려가도록 제한하는 구조

\- Virtual DOM을 활용해 실제 DOM 조작을 최소화하여 성능을 크게 향상시키고, 선언적 코드 작성 방식을 제공해 개발자가 무엇을 표현할지에만 집중 가능

> ❓ Virtual DOM  
> \- 실제 브라우저 DOM을 그대로 건드리지 않고, 메모리 안에 가짜 DOM을 만들어 미리 변화량을 계산한 뒤 필요한 부분만 실제 DOM에 반영  
> \- 불필요한 렌더링 줄어들고, 복잡한 UI도 훨씬 빠르고 효율적으로 업데이트 가능

#### 3\. 사용 방법

\- 일반적으로 Vite, Create React App, Next.js 등의 템플릿을 기반으로 프로젝트 생성

> ❓ Vite  
> \- 빌드하고 반영하는 것이 빠름  
> \- 매우 빠른 개발 서버 구동 속도와 즉각적인 HMR   
> 👉🏻 HMR: 코드 변경 시 새로고침 없이 변경된 부분만 교체하는 기능  
> \- 복잡한 설정 없이도 최신 JS 문법과 모듈 시스템(ESM)을 기본으로 활용할 수 있음

---

### 2️⃣ JSX

#### 1\. 정의

\- 문법적으로 HTML과 유사한 코드 내에 JS문법을 사용할 수 있게 한 방식

\- XML-like 문법

#### 2\. 사용 이유

\- HTML과 JS를 하나의 표현식 안에서 결합하여 UI 구조를 코드로 직관적이고 간결하게 표현하기 위함

\- 선언적 UI와 관심사의 분리

#### 3\. 사용 방법

\- <태그>{표현식}</태그>

\- HTML 구조와 JS 표현식을 함께 작성해 UI 구성

(1) JSX 프라그마 (Pragma)

\- 컴파일러에게 "이 파일의 JSX코드를 어떤 함수로 변환할지" 알려주는 지시자

\- JSX의 <태그 ...> 구조는 React.createElement(...) 로 변환

\- <User label="Hello" /> 👉🏻 React.createElement(User, { label: "Hello" }, null);

-   태그: 컴포넌트 이름
-   속성: props 객체
-   자식: children

\- 브라우저는 JSX를 이해하지 못함 -> 빌드 단계에서 트랜스파일러(Babel, SWC, TypeScript)가 JSX를 JS로 변환

\- 실행 전 자동으로 변환됨

(2) JSX 표현식

\- JSX 안에서 {}는 "여기에 JS 표현식 결과를 넣겠다"라는 의미

\- 기본 표현식

```
const Sum = () => <p>{1 + 2}</p>; // 3
```

\- 리스트 렌더링 (map)

```
<ul>
  {list.map(item => (
    <li key={item}>{item}</li>
  ))}
</ul>
```

👉🏻 map 사용 필수 (for 사용 불가)

👉🏻 key 속성 반드시 필요

\- 조건부 렌더링 - 삼항 연산자

```
<p>{score >= 60 ? "합격" : "불합격"}</p>
```

\- 조건부 렌더링 - 논리연산자 &&

```
{isLogin && <p>로그인 상태입니다.</p>}
```

\- 컴포넌트 조건부 렌더링

```
{isAdmin ? <Admin /> : <User />}
```

\- 문자열 결합

```
<p>{user.name}님의 나이는 {user.age}살입니다.</p>
```

\- 함수 호출 결과 사용

```
<p>오늘은 {formatDate(new Date())}</p>
```

\- if문 직접 사용 불가 -> 삼항 연산자로 해결

```
<p>{a > 10 ? "크다" : "작다"}</p>
```

#### 4\. JSX 속성

(1) 문자열

\- HTML처럼 문자열 값은 따옴표(",')안에 적음

```
<img src="logo.png" alt="로고" />
```

(2) 자바스크립트 값

\- 중괄호 {} 안에 변수, 숫자, 불린, 객체 등 자바스크립트 표현식을 넣음

\- {}를 쓰면 자바스크립트 모드로 전환됨

```
const size = 100;
const url = "logo.png";

<img src={url} width={size} height={size} />
```

(3) 속성 이름

\- 자바스크립트 문법 규칙을 따르기 때문에 HTML 속성 이름과 다른 경우가 있음

\- 대부분 카멜케이스로 바뀜

(4) 불린 속성

\- HTML에서는 checked, disabled 같은 불린 속성을 값 없이 써도 동작함

\- JSX는 조금 더 엄격히 검사

```
// JS
<input type="checkbox" checked />
<input type="text" readOnly />

// JSX
<input type="checkbox" checked={true} />
<input type="text" readOnly={true} />
```

(5) 스타일 속성 (style)

\- HTML에서는 style 속성에 문자열로 CSS 넣지만, JSX에서는 객체로 스타일을 작성해야함

\- 중괄호 두 번 { { ... } }

-   바깥 {}는 JSX 표현식
-   안쪽 {}는 자바스크립트 객체

\- CSS 속성은 카멜케이스로 바뀜

```
<div style={{ color: "red", backgroundColor: "yellow", padding: 10 }}>
  스타일 예제
</div>
```

(6) 속성 합치기 (Sppread 문법)

\- 여러 속성을 한꺼번에 전달하고 싶을 때는 전개 연산자(...)를 씀

(7) 자기 닫힘 태그

\- 내용이 없는 태그를 반드시 /로 닫아야 함

```
<img src="logo.png" alt="로고" />
<input type="text" />
```

---

### 3️⃣ DOM

#### 1\. 정의

\- HTML은 원래 그냥 텍스트(문자열)

\- 브라우저는 이 텍스트를 한 줄씩 읽어(파싱) 메모리 안에 객체 구조(DoM Tree)로 변환함

\- JS는 이 DOM Tree를 API(document 객체)를 통해 조작할 수 있음

\=> 브라우저가 HTML을 객체로 바꿔서 JS가 제어할 수 있게 해주는 모델

#### 2\. DOM Tree 구조

\- 브라우저가 HTML을 읽으면 트리 형태의 노드 구조를 만듦

#### 3\. DOM은 왜 API 인가?

```
document.getElementById("title");
```

위 코드가 가능한 이유

\- 브라우저가 HTML을 객체(documemt)로 만들어서 JS가 접근할 수 있도록 인터페이스(API)를 제공하기 때문

\=> 즉, DOM은 JS가 HTML을 읽고 수정할 수 있는 문(Interface)

#### 4\. DOM의 가장 큰 단점 - 수정 비용이 매우 높다

```
document.body.style.backgroundColor = "blue";
```

(1) 스타일 변경 감지

(2) 레이아웃 재계산 (Reflow)

\- 요소 크기/위치 다시 계산

\- 주변 요소까지 영향 전파

(3) 다시 그리기 (Repaint)

\- 픽셀을 다시 칠함

#### 5\. DOM이 힘들어하는 이유 정리

\- DOM 변화 -> Reflow + Repaint 과정 발생

\- Reflow/paint는 브라우저에서 가장 무거운 작업

\- 작은 변화도 전체 페이지에 영향을 미칠 수 있음

\=> DOM은 변경 비용이 높은 구조가 근본적 한계

#### 6\. 그래서 등장한 React의 Virtual DOM

\- DOM의 단점을 보완하기 위해 React는 VDOM(가상 DOM)을 사용함

\- 실제 DOM을 직접 조작하지 않고, 메모리 상에서 먼저 가상 UI 모델을 만들고(diff), 변경된 부분만 최소한으로 실제 DOM에 반영

\=> DOM 직접 조작을 최적화하기 위한 전략

> 요약  
> \- DOM은 브라우저가 HTML 텍스트를 트리 구조 객체로 만든 것  
> \- JS가 이를 조작할 수 있게 하는 API  
> \- 하지만 DOM 변경은 Reflow/Repaint때문에 매우 비싸서 성능 문제 발생  
> \- React의 VDOM은 이 비용을 줄이기 위한 해결책

---

### 4️⃣ VDOM

#### 1\. 정의

\- 실제 브라우저의 DOM을 직접 조작하지 않고, 그 변경 사항을 메모리 상의 가상 구조에서 먼저 처리하는 기술

\- 전체 DOM을 변경하지 않고 필요한 부분만 효율적으로 고칠 수 있음

\- 재조정

#### 2\. 사용 이유

\- 실제 DOM 조작을 최소화해 렌더링 성능을 향상시키기 위함

\- DOM 변경은 비싸기 때문에 React는 Virtual DOM을 사용해 변경 사항을 메모리에서 먼저 계산하고, 실제 DOM에는 최소한만 일괄 처리로 반영

\-> 성능 좋아짐

#### 3\. 동작 방식

\- 상태나 props의 변경이 발생하면 변경된 부분만 감지하여 실제 DOM에 반영함 (diffing & patching)

(1) 새로운 VDOM 생성 (Render Phase)

\- 상태/props가 바뀌면 React는 그 순간의 UI를 반영한 새로운 VDOM 트리를 메모리에서 생성함

👉🏻 JSX -> JS 객체(VDOM)로 다시 변환

👉🏻 화면 전체를 다시 그린 것처럼 하지만 실제 DOM은 아직 변경되지 않음

👉🏻 이 단계는 빠른 연산(메모리 연산)이라 부담 거의 없음

\=> React는 상태가 바뀌면 UI전체를 다시 만듦 -> 하지만 메모리에서만

(2) Diffing

\- 이전 VDOM vs 새로운 VDOM 비교 (Reconciliation)

\- React는 화면을 갈아엎지 않고, 이전 VDOM과 새로 생성된 VDOM을 트리구조로 비교해 어디가 달라졌는지 찾음

\- 비교 규칙

-   태그 타입이 같으면 -> 내부 비교 계속
-   태그 타입이 다르면 -> 기존 요소 제거하고 새로 생성
-   텍스트가 다르면 -> 텍스트 노드만 변경
-   리스트는 key 기준으로 비교

\=> React는 정확히 달라진 부분만 찾아내는 알고리즘을 사용함

(3) Patching

\- 실제 DOM에 변경 사항만 반영 (Commit Phase)

\- Diffing으로 찾아낸 변경점을 기반으로 실제 DOM에 필요한 부분만 최소한으로 업데이트함

-   전체 DOM 재생성X, 바뀐 DOM부분만 반영
-   DOM 조작 최소화 -> Reflow/Repaint 최소화 -> 성능 개선

\=> 달라진 부분만 업데이트

\=> VDOM의 핵심 성능 최적화 전략

#### 4\. Key의 중요성

(1) Key란?

\- React가 리스트 렌더링에서 각 요소를 고유하게 식별하기 위한 값

\- VDOM diffing 과정에서 어떤 요소가 그대로인지, 수정됐는지, 삭제됐는지, 새로 추가됐는지 판단하는 기준이 됨

(2) index를 key로 쓰면 안되는 이유

\- 배열의 순서가 바뀌면 Index도 바뀌기 때문

\=> 고유 id를 key로 사용

#### 5\. 불변성과 VDOM

\- React가 상태 업데이트를 감지할 때 사용하는 방법

👉🏻 얕은 비교 + Object.is

\- 즉, 리액트는 값이 바뀌었는지가 아니라 메모리 주소(참조값)이 바뀌었는지를 본다

#### 6\. React 18 과 Concurrent Rendering

(1) Fiber 아키텍처 (React 16~)

👉🏻 리액트 전체 렌더링 작업을 잘게 쪼개어 중단 가능, 우선순위 조절 가능, 재개 가능

👉🏻 즉, 브라우저가 바쁜 상황에서도 렌더링을 부드럽게 할 수 있는 기반

(2) React 18 Concurrent Rendering

\- Fiber 위에서 동작하는 동시성 렌더링 기능

\- 특징

👉🏻 긴 렌더링 작업을 낮은 우선 순위로 처리

👉🏻 사용자 입력(타이핑 등)은 높은 우선 순위로 즉시 반응

👉🏻 미뤄진 렌더링은 백그라운드에서 진행

\=> React 18은 렌더링을 즉각 반응해야 할 작업과 미뤄도 되는 작업으로 나눠 UX를 매우 부드럽게 만듦

#### 7\. 다른 프레임워크의 DOM 처리 방식 비교

(1) Vue

\- VDOM 사용

\- 템플릿을 분석해서 정적/동적 부분을 빌드 타임에 최적화

\- React보다 불필요한 비교를 덜 하도록 자동 최적화

(2) Svelte

\- VDOM 아예 사용 안함

\- 빌드 타임에 분석하여 이 상태가 바뀌면 DOM의 어느 부분을 업데이트해야 하는지를 순수 바닐라 JS 코드로 미리 생성

\- 오버헤드 최소화 -> 매우 빠름

(3) Angular

\- Incremental DOM 사용

\- 템플릿을 컴파일하여 DOM 업데이트 명령형 코드를 생성

\- 변경 사항을 직접 DOM에 적용

---

### 5️⃣ Component

#### 1\. 정의

\- 입력(Props)을 받아서 화면 조각(UI)을 내보내는 작은 프로그램(함수) 단위

#### 2\. 사용 이유

\- 재사용성과 유지보수성을 높이고, 일관된 사용자 경험을 제공하기 위함

(1) 캡슐화

\- 컴포넌트는 스스로 스타일/상태/이벤트를 관리하고, 바깥에서는 이름과 props만 알면 사용 가능

\- 내부 구현을 바꿔도 외부 사용법(props 인터페이스)가 그대로면, 사용하는 쪽 코드를 수정할 필요가 없어 외부 상태와 독립적으로 구현 가능

\- 호출되는 코드와 실제 내부 코드를 분리하면, 디자인이나 로직 변경이 발생하더라도 외부에서의 영향을 최소화할 수 있음

\- 협업 시 내부 로직 개선, 외부 사용으로 역할을 분리해서 사용가능

(2) 재사용성

\- 한 번 만든 컴포넌트를 여러 곳에서, 다양한 props로 재사용 가능

\- 같은 디자인/행동 규칙을 공유하니 UI 일과성이 높아짐

(3) 조합 가능하다 (Composition)

\- 컴포넌트는 다른 컴포넌트를 자식으로 받아 더 큰 UI를 만들 수 있음

\- 작은 블록을 조립해 복잡한 화면을 구성하는 게 React의 핵심 철학

(4) 단방향 데이터 흐름

\- 데이터는 부모 -> 자식으로 내려감

\- 자식은 받은 props를 읽기만 하고, 직접 수정하지 않음

\- 자식에서 변경이 필요하면 콜백으로 부모에게 의도를 전달하고, 부모가 상태를 바꿔 다시 내려줌

\- 데이터 흐름이 한 방향이기에 이해/디버깅이 쉬워짐

#### 3\. 사용 방법

\- JSX 문법을 사용하여 정의하고, JSX 내에서 태그처럼 호출해 사용함

\- 컴포넌트는 입력(props)을 받아 JSX(UI)를 반환하는 함수

(1) 컴포넌트 정의하기

\- 파스칼케이스(대문자 시작)로 이름을 작성해야 React가 컴포넌트로 인식

\- 반드시 JSX를 반환해야 화면에 렌더링됨

```
function Hello() {
  return <h1>안녕하세요!</h1>;
}
```

(2) 컴포넌트 호출하기

\- 태그처럼 <Hello /> 형태로 사용

\- 자식 요소가 필요하면 <Card>...</Card>형태 사용

```
<Hello />
<Card>내용</Card>
```

(3) Props(입력값) 전달

\- 문자열: "text"

\- 숫자/불린/객체/함수: {...}

\- 부모 -> 자식 방향으로 데이터가 흐름

```
function Badge({ label, color, onClick }) {
  return (
    <button style={{ backgroundColor: color }} onClick={onClick}>
      {label}
    </button>
  );
}

<Badge label="NEW" color="#fff" onClick={() => console.log("Click")} />
```

(4) Props 기본값 설정

\- 전달되지 않은 값에 대비해 기본값을 넣어 안전하게 사용 가능

```
function Button({ children, variant = "primary", disabled = false }) {
  return (
    <button className={`btn ${variant}`} disabled={disabled}>
      {children}
    </button>
  );
}

<Button>확인</Button>
<Button variant="ghost" disabled>취소</Button>
```

(5) children 사용하기

\- <Comp>내용</Comp> 사이 내용은 자동으로 children으로 들어옴

```
function Card({ title, children }) {
  return (
    <div>
      <h3>{title}</h3>
      <div>{children}</div>
    </div>
  );
}

<Card title="공지">
  <p>오늘 자정 점검 예정입니다.</p>
</Card>
```

(6) 이벤트 처리 (함수 참조 전달)

\- onClick={함수} ← 함수 “실행”이 아니라 “참조” 전달해야 함

\- 즉시 실행하는 형태(onClick={함수()})는 ❌

```
function Counter({ number, onClick }) {
  return <button onClick={onClick}>클릭 횟수: {number}</button>;
}

function Page() {
  const [n, setN] = useState(0);
  return <Counter number={n} onClick={() => setN(n + 1)} />;
}
```

(7) 조건부 렌더링 & 리스트 렌더링

\- 조건부

```
{isLogin ? <p>환영합니다</p> : <p>로그인이 필요합니다</p>}
{isAdmin && <AdminPanel />}
```

\- 리스트 (map + 고유 key)

```
<ul>
  {items.map((it) => (
    <li key={it.id}>{it.name}</li>
  ))}
</ul>
```

(8) 컴포넌트 합성 (조립)

\- 여러 UI 조각을 하나로 조립

\- 형제 요소는 Fragment로 묶기

```
function Page() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
```

(9) 파일 분리

\- 컴포넌트별로 파일 분리하여 재사용, 관리성 향상

```
// Button.jsx
export default function Button({ children }) {
  return <button>{children}</button>;
}
```

```
// App.jsx
import Button from "./Button";
function App() {
  return <Button>확인</Button>;
}
```

\=> 요약

React 컴포넌트 = 함수 → props 받고 → JSX를 반환  
태그처럼 사용하고, props로 데이터 전달하며, children으로 구성하고,  
조건/리스트 렌더링을 조합해 UI를 만든다.

#### 4\. Key

(1) 정의

\- 리액트가 리스트를 렌더링할 때, 각 항목을 고유하게 식별하기 위한 값

\- 리액트가 이 요소가 이전에도 존재했던 요소인지 판단하도록 도와줌

\- VDOM의 diffing 과정에서 요소 매칭을 위한 기준값

(2) Key의 역할

\- Virtual DOM 비교(diffing) 과정에서

👉🏻 key가 같으면 -> 이전의 같은 DOM 요소로 판단하여 재사용

👉🏻 key가 다르면 -> 새로 만들어야 할 요소로 판단

\=> 정확한 비교 + 최소 DOM 업데이트

\=> 성능 최적화 + 올바른 UI 유지

(3) Key 없을 때 생기는 문제

\- key가 없으면 React는 항목의 변경 여부를 제대로 판단하지 못함

\- 화면이 잘못 갱신됨

\- 배열 순서 변경 시 항목이 뒤섞여보임

\- 입력창의 내용이 이동하거나 엉뚱한 값이 출력됨

\- 불필요한 재렌더링 증가

(4) index를 key로 쓰면 안되는 이유

\- 리스트의 순서가 바뀌면 key도 전부 바뀜

\- 리액트는 완전 다른 요소로 판단하지 못하고 기존 DOM을 잘못 재사용함

(5) 해결방법: 고유한 ID 사용

\- 각 요소가 고유한 식별자를 가지고 있으므로 순서 변경/추가/삭제가 일어나도 안전

\- React가 항목을 정확하게 식별 가능

> 요약  
> Key는 리액트 리스트 요소를 고유하게 식별하기 위한 값이며, VDOM 비교(diffing)에서 핵심적인 역할을 함.  
> index를 key로 사용하면 순서 변경 시 이전 DOM을 잘못 재사용하여 버그가 발생  
> 따라서 고유한 id를 key로 사용하는 것이 가장 안전하고 권장되는 방식
