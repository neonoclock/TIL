
## **🧠 회고**

오늘은 React에서 가장 중요한 개념 중 하나인 props와 state를 배우는 시간이었다. 두 개념 모두 컴포넌트 간 데이터 흐름을 이해하는 데 핵심이어서 처음엔 조금 헷갈렸지만, 차이를 명확히 파악하니 React 구조가 훨씬 잘 보이기 시작했다. props는 부모가 자식에게 전달하는 “변하지 않는 데이터”, state는 컴포넌트 내부에서 변화하며 UI를 다시 렌더링하게 만드는 “변하는 데이터”라는 구분이 특히 중요했다. 실제로 간단한 UI를 만들면서 상태가 바뀔 때 화면이 자동으로 갱신되는 걸 보니, 왜 React가 상태 기반 렌더링을 강조하는지 이해가 되었다. 새로운 개념이라 어렵기도 했지만, 앞으로 만들 기능들 대부분이 props와 state 위에서 돌아간다는 걸 생각하면 오늘 배운 내용이 React 학습의 큰 기반이 될 것 같다.

## **🪽 오늘의 다짐**

React의 핵심 개념을 배워가는 만큼, 이해가 어려워도 포기하지 말고 계속 손으로 실습하며 확실히 내 것으로 만들자. 기본기를 탄탄하게 쌓아서 앞으로 나올 더 깊은 내용들도 흔들리지 않고 받아들일 수 있도록 매일 조금씩 꾸준히 나아가자.

---

## **📝 Today I Learned**

### **1️⃣ Props**

#### **1\. 정의**

\- 컴포넌트 간에 데이터를 전달하기 위해 사용하는 읽기 전용 속성

\- 부모 컴포넌트가 자식 컴포넌트에게 값을 전달하기 위해 사용하는 토로

\- 컴포넌트 외부에서 안쪽으로 흘러 들어오는 데이터

-   Props는 객체 형태로 컴포넌트에 전달됨
-   컴포넌트 안에서는 함수의 매개변수처럼 받아 사용할 수 있음
-   읽기 전용 -> 받은 props를 자식 컴포넌트 내부에서 직접 수정할 수는 없고, 오직 보여주거나 활용만 가능

#### **2\. 사용 이유**

\- UI의 재사용성과 구성의 유연성을 높이기 위함

\- 컴포넌트를 재사용 가능하고, 상황에 맞게 유연하게 구성할 수 있게 해주기 때문

\- props가 없다면, 컴포넌트는 늘 똑같은 UI만 만들 수 있어서 활용도 크게 떨어짐

(1) 컴포넌트 재사용성 증가

\- 컴포넌트는 같은 구조를 가지되, 안의 내용이나 속성만 조금씩 달라질 때가 많음

\- props를 사용하면 같은 컴포넌트를 다양한 방식으로 재사용 가능

(2) 유연한 UI 구성

\- props는 단순히 텍스트나 색깔만 전달하는 게 아니라, 다른 컴포넌트를 children으로 전달 가능

\- 이 덕분에 컴포넌트를 레고 블록처럼 조립해서 유연한 UI 만듦

(3) 데이터 전달과 화면 반영

\- props는 단순히 UI 요소만 바꾸는 게 아니라, 상위 컴포넌트의 데이터를 하위 컴포넌트에 전달하는 중요한 역할을 함

(4) 컴포넌트 간 역할 분리

\- props 덕분에 부모 컴포넌트와 자식 컴포넌트의 역할 분리 가능

\- 부모는 데이터를 준비하고, 자식은 화면에 그리기만 하는 구조

#### **3\. 사용 방법**

\- 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용하며, JSX에서 속성 형태로 작성

\- 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달하는 가장 기본적인 방법

\- JSX에서는 HTML 태그 속성처럼 작성하면 되고, 자식 컴포넌트에서는 props 객체를 통해 해당 값 사용 가능

(1) 문자열 전달

\- props 덕분에 한 컴포넌트를 여러 상황에서 쉽게 재사용 가능

(2) 숫자, 불린, 객체 전달

\- 중괄호 {}를 사용하면 자바스크립트 표현식을 그대로 넘길 수 있음

\- props는 단순한 텍스트뿐만 아니라 다양한 타입의 값을 전달할 수 있음

(3) 함수 전달

\- props는 함수도 전달 가능

\- 자식에서 부모에게 이벤트를 알려줄 수 있음

\- 자식은 단순히 버튼 UI만 담당하고, 실제 동작(비즈니스 로직)은 부모에서 관리 가능

(4) Children 전달하기 (태그 사이의 내용)

\- children props는 컴포넌트의 태그 사이에 들어오는 내용을 전달하기 위해 리액트가 기본적으로 제공하는 내장 props

\- children은 우리가 따로 이름을 정해주지 않아도 자동으로 전달되는 기본 props

\- 컴포넌트 태그 안에 작성한 내용이 있으면 리액트가 자동으로 children으로 전달해줌

\- 레이아웃, 컨테이너, 공통 UI 컴포넌트를 만들때 유용

#### **4\. React에서 Props의 역할**

\- props가 읽기 전용인 이유

👉🏻 리액트의 컴포넌트는 함수

👉🏻 함수는 같은 입력을 받으면 항상 같은 출력을 내야 순수함수라고 부름

\- props를 읽기 전용으로 만든 이유

👉🏻 데이터 흐름을 예측 가능하게 유지하려고

👉🏻 하위 컴포넌트에서 부모의 데이터를 직접 변경하는 것을 금지

👉🏻 값 변경은 반드시 상태 변경 -> 부모에서 새 props 내려줌 형태로 이루어져야함

👉🏻 데이터 변경을 직접 mutate하는 것이 아니라 불변성을 지켜야함

#### **5\. Props Drilling**

\- 필요한 컴포넌트에 값을 전달하기 위해, 중간 컴포넌트들이 그 값을 사용도 안하면서 억지로 받아서 다시 넘겨주는 현상

\- props가 깊은 컴포넌트 트리를 타고 뚫고 내려가는(drill) 상황

(1) 문제 상황

\- 깊은 컴포넌트 트리(App → Page → Layout → Content → Button)에 같은 props(theme="dark")를 계속 넘기면  
중간 컴포넌트들이 쓰지도 않는 props를 억지로 받아 전달해야 해서 코드가 지저분해짐.

(2) 문제점

\- 중간 컴포넌트를 수정할 때 연쇄적으로 변경이 필요하며, 유지보수성이 크게 떨어짐

(3) 해결방법

\- Context API - React 내장 전역 공유 기능

\- 전역 상태 관리 라이브러리 - Redux, Zustand, Recoil등 -> props 전달 없이 하위 컴포넌트에서 값 접근 가능

(4) 주의점

\- depth가 2~3단계 정도면 그냥 prop로 넘기는 것이 가장 직관적일때가 많음

\- 무조건 Context나 Redux를 사용하는 것이 능사는 아님

#### **6\. key**

\- 배열을 map()으로 렌더링할 때 각 항목을 고유하게 식별하기 위해 key 값이 필요

\- index를 key로 사용하면 리스트 순서가 바뀌거나 중간 요소가 삭제될 때 React가 기존 DOM을 잘못 매칭해 버그(입력값 이동, 잘못된 UI)가 발생

\- 항상 고유 ID를 key로 사용하고, index는 리스트 순서가 절대 변하지 않을 때만 “최후의 수단”으로 사용

#### **7\. TS (props 타입 지정)**

\- TypeScript에서 props 인터페이스를 정의하면 컴포넌트에 전달되는 값의 타입을 강제 가능

\- 런타임 오류를 줄이고 컴포넌트 사용을 훨씬 더 안전하게 만들 수 있음

---

### **2️⃣ State**

#### **1\. 정의**

\- 컴포넌트 내부에서 관리되는 값

\- 시간이나 사용자 상호작용에 따라 변할 수 있는 동적인 데이터

\- 컴포넌트가 스스로 기억하고 관리하는 값

-   props: 부모로부터 전달받은 외부 데이터
-   State: 컴포넌트 안에서 정의되고 변화하는 내부 데이터라고 이해할 수 있음

> **❓ 내부 데이터, 외부 데이터**  
> \- 내부 데이터: 컴포넌트 자체가 만들고 관리하는 값  
> \- 외부 데이터: 부모 컴포넌트나 외부에서 전달된 값(props)  
>   
> 내부 데이터는 컴포넌트 스스로 바꿀 수 있지만, 외부 데이터는 전달받은 그대로 사용만 가능

#### **2\. 사용 이유**

\- 사용자 상호작용이나 시간에 따라 변하는 값을 관리하여, 동적인 UI를 만들기 위해 사용

(1) 시간에 따라 변하는 값을 관리하기 위해

(2) props로는 해결할 수 없는 내부 데이터 관리

\- props는 부모가 자식에게 넘겨주는 값이므로, 컴포넌트 스스로의 내부적인 변화는 관리할 수 없음

\- state는 이 부분을 보완해, 컴포넌트 자신이 알아서 관리해야하는 값을 다룸

(3) UI를 동적으로 만들기 위해

\- State는 단순한 숫자나 문자열뿐만 아니라, 화면의 표시 여부나 모양도 제어할 수 있음

#### **3\. 사용 방법**

\- State는 useState 훅(Hook)을 사용하여 선언함

\- 이 훅은 현재 값과 그 값을 변경하는 함수를 한 쌍으로 반환함

```
const [value, setValue] = useState(초기값);
```

\- value: 현재 상태 (값)

\- setValue() : 상태를 변경하는 함수

\- 이 setter 함수를 호출하면 리액트가 컴포넌트를 다시 렌더링하여 화면이 자동으로 업데이트됨

(1) 기본 사용 예시

```
function Counter() {
  const [count, setCount] = useState(0); // count 초기값: 0

  return (
    <div>
      <p>현재 값: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

\- 값을 직접 수정하면 안됨

\- 리액트는 setState함수 호출을 통해서만 상태가 변했다고 인식함

👉🏻 내부 변수 변경만으로는 UI가 업데이트되지 않음

(2) 문자열 상태 관리

```
function Greeting() {
  const [name, setName] = useState("");

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="이름을 입력하세요"
      />
      <p>안녕하세요, {name || "아무개"}님!</p>
    </div>
  );
}
```

\- 텍스트 입력 -> 상태에 저장 -> 화면 반영

이 흐름이 자동으로 연결됨

(3) 불린(boolean) 값 관리 (토글)

```
function Toggle() {
  const [on, setOn] = useState(false);

  return (
    <button onClick={() => setOn(!on)}>
      {on ? "켜짐" : "꺼짐"}
    </button>
  );
}
```

\- 다크모드, 모달 열기/닫기 등에서 매우 자주 쓰는 패턴

(4) 배열 상태 관리

\- 리액트에서는 배열을 직접 수정하면 안됨

\- 항상 새로운 배열을 만들어 업데이트해야 함

```
setTodos([...todos, 새항목]);
```

\- 전개 연산자(...)는 배열을 복사하여 새로운 배열을 만드는 문법

(5) 객체 상태 관리

ex) 여러 폼 입력을 한 번에 관리할 때

```
setProfile({ ...profile, [name]: value });
```

\- 객체도 반드시 기존 객체를 복사한 뒤 수정한 값만 덮어쓴 새로운 객체를 만들어야 리액트가 변화를 감지함

(6) 이전 값을 기반으로 업데이트

\- 여러 번 빠르게 값이 바뀔 때는 prev를 사용하는 것이 안전함

```
setCount(prev => prev + 1);
```

\- prev는 react가 알아서 제공하는 이전 상태 값

(7) 조건부 렌더링에 활용

\- 상태를 UI 표시 여부에 사용 가능

```
{open && <Modal />}
```

\- 불린 값 하나로 모달 전체의 렌더링 여부를 제어

#### **4\. State 특징**

(1) State는 비동기적으로 처리됨

\- 리액트는 성능 최적화를 위해 setState가 호출되었다고 바로바로 화면을 다시 그리지 않음

\- 여러 개의 상태 변경을 모아서(batch) 한 번에 렌더링

\- 배칭

👉🏻 리액트17 : 이벤트 행들러 내부에서만 배칭이 일어남

👉🏻 리액트18 : setTimeout, Promise 등 어디에서 상태를 바꾸든 자동으로 배칭 적용됨

\=> 상태가 업데이트된 뒤의 최신 값을 사용하고 싶다면, useEffect에서 읽는 패턴을 사용함

(2) State는 최소한으로 관리하는 것이 좋음

\- 불필요한 값을 모두 상태로 만들면 관리해야할 값이 늘어나고, 버그 발생 확률도 올라감

#### **5\. State와 다른 도구들의 사용 기준**

(1) 일반 변수 (let, const)

\- 렌더링 때마다 초기화돼도 상관없는 임시값

\- 일시적인 값

\- UI와 연결되지 않음

(2) useRef

\- 렌더링과 상관없이 값을 유지하고 싶을 때

\- 값은 유지해야하지만 UI 업데이트는 필요 없는 경우 (DOM 접근, 스크롤 위치 등)

(3) State (useState)

\- 값이 바뀔때마다 UI도 바뀌어야 하는 경우

\- 입력값, 토글 상태, 모달 열림/닫힘, 리스트, 서버 응답 데이터 등
