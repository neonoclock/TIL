## **🧠 회고**
​
오늘은 React의 LifeCycle, Hooks, Reducer를 배우면서 “React가 어떻게 동작하는지”에 대한 큰 그림을 잡는 시간이었다. 컴포넌트가 렌더링되고 업데이트되고 사라지는 흐름을 이해하니, 그동안 막연했던 useEffect의 실행 시점이 명확해졌고, 단순히 기능을 구현하는 수준을 넘어 “언제 어떤 코드가 실행되어야 하는가”를 생각할 수 있게 되었다. 또한 useState로만 관리하던 상태 로직을 useReducer로 구조화해보면서, 상태 변화 과정을 하나의 흐름으로 관리하는 방법을 배운 점이 특히 신선했다. 조금 어려운 개념들이었지만 직접 손으로 실습하면서 퍼즐 조각이 맞춰지는 느낌이 들었고, React를 더 깊이 이해할 수 있는 기반을 다진 하루였다.
​
## **🪽 오늘의 다짐**
​
앞으로는 컴포넌트를 그냥 만들어 돌리는 것에서 끝내지 않고, 생명주기와 Hooks, Reducer 흐름을 의식하면서 왜 여기서 useEffect가 필요한지, 이 상태는 useState로 충분한지 아니면 useReducer가 더 맞는지 한 번 더 고민해 보면서 코드를 짜는 연습을 꾸준히 해 나가겠다.
​
---
​
## **📝 Today I Learned**
​
### **1️⃣ LifeCycle**
​
#### **1\. 정의**
​
\- 컴포넌트가 생성되고 업데이트되며 소멸하는 과정을 단계별로 관리하는 React의 동작 흐름
​
\- 컴포넌트가 생성(Mount) -> 갱신(Update) -> 제거(Unmount) 되는 과정을 지칭함
​
(1) Mount
​
\- 컴포넌트가 처음으로 화면에 나타나는 시점
​
(2) Update
​
\- props나 state가 바뀌어 화면이 다시 렌더링되는 시점
​
(3) Unmount
​
\- 컴포넌트가 화면에서 완전히 사라지는 시점
​
#### **2\. 알아야 하는 이유**
​
\- API 호출 시점
​
👉🏻 화면이 렌더링될 때마다 계속 API 요청을 보내면, 서버가 불필요한 요청으로 과부하 걸릴 수 있고, AWS 같은 클라우드 비용 폭증 가능
​
👉🏻 화면이 처음 나타났을 때 (mount) 단 한 번 호출해야함
​
\- 성능 최적화
​
👉🏻 검색창에 글자를 입력할 때마다 렌더링이 발생하면 화면 깜빡임 증가, 불필요한 연산이 반복되며 성능 저하
​
👉🏻 정말 데이터가 바뀌었을 때만 해당 부분 업데이트
​
\- 메모리 누수 방지 (남아있는 타이머, 리스너 정리)
​
👉🏻 setInterval(() => count++, 1000);
​
👉🏻 페이지를 나갔는데도 해당 interval이 계속 돌아가고 있으면, 브라우저 백그라운드에서 끝없이 동작하여 메모리 누수 발생, 브라우저 느려지고 성능 떨어짐
​
👉🏻 언마운트 시점에 반드시 정리(clean-up)해야 함
​
  
**(1) Mount**
​
\- 컴포넌트가 화면에 처음으로 등장할 때
​
\- 리액트는 JSX를 실제 DOM 요소로 변환하여 브라우저 화면에 붙이고, 상태(state)는 초기값으로 세팅됨
​
👉🏻 서버에서 데이터를 가져와 초기 UI를 채우고
​
👉🏻 이벤트 리스너나 외부 라이브러리를 연결하며
​
👉🏻 한 번만 실행되어야 하는 초기화 로직을 배치하기에 적절함
​
\- 이 단계를 모르고 코드 작성 시점을 놓치면, 불필요하게 매번 API를 호출하거나, 중복된 이벤트 리스너가 등록되는 문제 겪음
​
**(2) Update**
​
\- 이미 화면에 있던 컴포넌트가 state나 props가 바뀌면서 다시 렌더링되는 시점
​
\- React는 Virtual DOM을 이용해 이전 UI와 새로운 UI를 비교(diffing)하고, 바뀐 부분만 실제 DOM에 반영
​
👉🏻 웹 UI는 사용자 상호작용과 함께 계속 바뀌어야 함
​
👉🏻 Update를 잘 이해해야 어떤 값이 변할 때 어떤 동작을 수행할지 정확히 제어 가능
​
👉🏻 불필요한 렌더링을 줄여 성능을 최적화하는 데도 중요
​
**(3) Unmount**
​
\- 조건부 렌더링 해제, 페이지 이동, 라우팅 전환 등으로 컴포넌트가 화면에서 제거될 때 발생
​
👉🏻 컴포넌트는 화면에서 사라져도 메모리 속에서는 흔적이 남을 수 있음
​
👉🏻 보이지 않는 곳에서 리소스를 계속 잡아먹어 메모리 누수와 예상치 못한 버그로 이어짐
​
👉🏻 Unmount 시점을 활용하면 이런 리소스를 깔끔히 정리(cleanup) 가능
​
👉🏻 리액트의 useEffect는 반환 함수가 Unmount시 자동 실행되도록 설계되어 있어, 이 시점에 정리 코드를 넣으면 안전함
​
#### **3\. 동작 방식**
​
\- 컴포넌트가 생성되고 업데이트되며 소멸되는 전 과정을 순차적으로 관리하는 내부 흐름
​
\- 리액트 컴포넌트는 화면에 나타나고(Mount) -> 상태 변화에 따라 갱신되고 (Update) -> 화면에서 사라지는 (Unmount) 생명주기를 가짐
​
\- 이 흐름을 통해 API 호출, 렌더링 제어, 메모리 정리 등을 적절한 시점에 처리 가능
​
**(1) Mount**
​
\- 컴포넌트가 처음 DOM에 렌더링되는 시점
​
\- 초기 state/props 설정 + JSX -> 실제 DOM 반영
​
\- 이 시점에 초기화 로직 실행
​
👉🏻 API 요청
​
👉🏻 이벤트 리스너 등록
​
👉🏻 외부 라이브러리 초기화
​
**(2) Update**
​
\- state 또는 props 변화로 인해 컴포넌트가 재실행
​
\- 리액트는 Virtual DOM 비교(diffing)을 통해 바뀐 부분만 갱신됨
​
\- 특정 값 변경 시 추가 로직 실행 가능
​
👉🏻 문서 제목 변경
​
👉🏻 특정 조건일 때 API 재호출
​
👉🏻 props 변경 감지
​
**(3) Unmount** 
​
\- 페이지 이동, 조건 변경 등으로 컴포넌트가 DOM에서 제거되는 순간
​
\- 반드시 정리 작업 수행해야 함 (clean-up)
​
👉🏻 타이머 제거 (setInterval, setTimeout)
​
👉🏻 이벤트 리스너 해제
​
👉🏻 Websoket/SSE 종료
​
\- 정리하지 않으면 메모리 누수 발생 -> 성능 저하
​
---
​
### **2️⃣ Hooks**
​
#### **1\. 정의**
​
\- 리액트에서 함수 컴포넌트가 상태, 라이프사이클, 컨텍스트 같은 기능에 접근할 수 있게 해주는 특별한 함수 규칙
​
\- 모든 Hook은 use라는 접두어로 시작하며, 정해진 규칙을 따라야 리액트가 올바르게 동작 가능
​
\- 리액트에서 Hooks는 함수 컴포넌트가 단순한 UI 출력만 하는 수준을 넘어, 상태 관리와 부수 효과 처리까지 담당할 수 있도록 확장해 주는 핵심 매커니즘
​
#### **2\. 알아야 하는 이유**
​
\- 클래스 없이도 상태 관리와 부수 효과를 다룰 수 있음
​
\- 로직을 재사용하며, 코드 가독성과 유지보수성을 높일 수 있기 때문
​
#### **3\. 동작 방식**
​
\- 함수 실행 시 특정 위치에 걸려 리액트가 상태와 효과를 기억하고 추적하는 방식으로 동작
​
**(1) 기본 원리**
​
\- 리액트는 컴포넌트를 렌더링할 때 함수를 매번 다시 실행함
​
\- 그럼에도 useState 값이 계속 유지되는 이유는, 리액트가 Hook이 호출된 순서대로 값을 저장해두기 때문
​
\- 리액트는 내부적으로 Hook을 칸 또는 번호표처럼 관리함
​
👉🏻 순서 기반으로 저장해두었다가, 다음 렌더링에서도 같은 순서의 칸에서 값을 찾아와 Hook에게 전달함
​
**(2) Hook은 순서로 관리됨**
​
\- 리액트가 Hook을 저장하는 방식은 순서 기반이기 때문에 Hook은 항상 동일한 순서로 호출되어야 함
​
**(3) 상태가 유지되는 이유**
​
\- 칸에 계속 넣어둔다
​
\- 값을 계속 같은 칸에 저장해두기 때문에 상태가 이어짐
​
**(4) 리액트 렌더링 방식 (계산 -> 실제 반영)**
​
\- 렌더링 계산 단계
​
👉🏻 함수 컴포넌트를 실행하여 화면을 어떤 모습으로 바꿔야 하는지 계산
​
👉🏻 Hook 등록도 이 단계에서 수행됨
​
\- 커밋 단계 (실제 DOM 적용)
​
👉🏻 계산된 결과를 DOM에 반영
​
👉🏻 useEffect 등 일부 Hook은 이 단계 이후 실행됨
​
👉🏻 화면이 그려진 다음에 실행해야 하는 로직이기 때문
​
**(5) Hook 사용 규칙**
​
\- Hook은 최상위에서만 호출
​
👉🏻 조건문, 반복문, 함수 안쪽에서 또 다른 함수 안 X
​
👉🏻 컴포넌트 함수 시작 부분에서만 호출해야함
​
\- Hook은 항상 같은 순서로 호출
​
👉🏻 렌더링 사이에 호출 순서가 바뀌면 안됨
​
👉🏻 그래야 리액트가 올바른 번호표(칸)을 찾아 값을 줄 수 있음
​
#### **4\. Hook은 반드시 규칙을 따라야 함**
​
\- 리액트가 Hook을 순서 기반으로 기억하기에, 호출 위치가 매우 중요함
​
\- 항상 컴포넌트 최상위에서만 호출
​
\- 조건문, 반복문, 중첩 함수 안에서 호출 금지
​
#### **5\. Hook은 렌더링과 분리된 실행 시점을 가짐**
​
\- 리액트는 화면을 업데이트할 때 두 단계로 나눔
​
👉🏻 렌더링: 컴포넌트 함수를 실행하여 출력할 UI를 계산하는 단계
​
👉🏻 커밋: 계산된 결과를 실제 DOM에 반영하는 단계
​
\- 이 구조 덕분에 다음처럼 동작함
​
👉🏻 useState는 렌더링 사이에서 값을 기억하고 갱신함
​
👉🏻 useEffect는 DOM 업데이트가 끝난 커밋 이후에 실행됨
​
#### **6\. Hook은 로직 재사용을 가능하게 함 (Custom Hook)**
​
\- Hook은 단순한 상태 관리 도구가 아니라, 하나의 기능/로직 단위를 모듈화하는 방법임
​
\- 반복되는 기능을 Custom Hook으로 분리해두면
​
👉🏻 여러 컴포넌트에서 재사용 가능
​
👉🏻 UI 코드(렌더링)와 로직 코드가 깔끔하게 분리됨
​
👉🏻 협업 시 구조가 명확해져 유지보수가 쉬워짐
