## **  
🧠 회고**

오늘은 callback, custom hook, context, error boundary, suspense, concurrent rendering을 배우며 React가 단순한 UI 라이브러리가 아니라, 복잡한 상태·비동기·에러 처리까지 체계적으로 관리하는 프레임워크에 가깝다는 걸 느꼈다. useCallback으로 함수 재생성을 줄이는 이유를 이해했고, 반복되는 로직을 custom hook으로 분리해 코드 재사용성을 크게 높일 수 있다는 점이 특히 인상적이었다. 전역 데이터 흐름을 깔끔하게 정리하는 Context는 props drilling 문제 해결에 유용했고, 예상치 못한 에러에 앱 전체가 죽지 않도록 보호하는 Error Boundary의 역할도 확실히 이해할 수 있었다. 또 Suspense와 Concurrent Rendering을 배우며 React가 비동기 작업과 렌더링을 부드럽게 처리해 사용자 경험을 개선하는 방식까지 고민하고 있다는 걸 알게 되어, 앞으로 컴포넌트를 설계할 때 단순 구현뿐 아니라 안정성·비동기 흐름·UX 최적화까지 고려해야겠다는 생각이 들었다.

## **🪽 오늘의 다짐**

오늘 배운 개념들을 단순히 “알았다”에서 끝내지 않고, 앞으로 컴포넌트를 만들 때마다 반복되는 로직은 커스텀 훅으로 분리하고, 전역 상태는 컨텍스트로 정리하며, 비동기 흐름과 에러 처리까지 책임지는 안정적인 코드를 작성하는 개발자가 되자.  
React가 제공하는 도구들을 하나씩 제대로 활용해, 더 깔끔하고 더 견고한 UI를 만드는 힘을 꾸준히 길러가자.

---

## **📝 Today I Learned**

### **1️⃣ Callback**

#### 1\. 정의

\- 다른 함수의 인자로 전달되어, 특정 시점에 호출되는 함수를 매번 새로 만들지 않고, React에서 필요할 때만 새로 만드는 Hook

\- React 함수 컴포넌트는 렌더링될 때마다 내부에 정의한 함수가 매번 새로 만들어짐

👉🏻 새 함수가 바뀌는 상황을 막기 위해 useCallback이 등장

👉🏻 useCallback은 콜백 함수를 기억해두었다가, 의존성이 변하지 않는 한 같은 함수 참조를 재사용함

#### **2\. 사용 이유**

\- 매 렌더마다 함수가 새로 생성되는 것을 방지해 성능을 최적화하고, 자식 컴포넌트의 불필요한 리렌더링을 막기 위함

**(1) 자식 컴포넌트의 불필요한 리렌더링 방지**

\- 컴포넌트가 렌더링될 때마다 내부에서 정의한 함수는 새로 생성됨

\- 이 함수가 자식 컴포넌트로 props로 전달되면, 값은 같아도 새로운 함수로 취급되어 자식이 불필요하게 다시 렌더링됨

👉🏻 useCallback으로 함수를 메모이제이션하면 참조가 유지되어,

👉🏻 React.memo와 함께 사용할 때 불필요한 리렌더링을 크게 줄일 수 있음

**(2) Effect 의존성 배열을 안정화**

\- useEffect는 의존성 배열의 값이 바뀔 때마다 다시 실행되는데, Effect 내부에서 사용하는 함수가 매 렌더마다 새로 생성되면 그 함수 역시 변화한 값으로 인식됨

👉🏻 불필요한 Effect 재실행 발생

👉🏻 네트워크 요청, 이벤트 실행이 반복되어 성능 저하 가능

👉🏻 useCallback으로 함수를 고정하면 Effext는 정말 필요할 때만 다시 실행됨

**(3) 이벤트 리스너 / 외부 API 사용 시 함수 참조 고정**

\- 브라우저 이벤트 등록(addEventListener)이나 외부 라이브러리 구독/해제는 등록할 때의 함수 참조와 해제할 때의 함수 참조가 동일해야 함

\- 만약 렌더마다 함수가 새로 생성되면

👉🏻 이벤트 해제가 실패하거나

👉🏻 중복 등록되어 메모리 누수 또는 버그 발생

\- useCallback으로 함수 참조를 고정하면 안전하게 등록/해제 가능

**(4) Context Provider 값 안정화**

\- Context Provider에 넘기는 value가 매 렌더마다 새 객체/새 함수로 생성되면, Provider 아래의 모든 소비자 컴포넌트가 전부 리렌더링됨

👉🏻 필요없는 전체 재렌더링 발생

👉🏻 useCallback + useMemo로 값 참조를 모두 안정화해야 함

#### **3\. 사용 방법**

**(1) 기본 문법**

```
const memoizedFunction = useCallback(() => {
  // 실행할 코드
}, [dependency]);
```

\- 첫 번째 인자: 실제 실행할 함수

\- 두 번째 인자: 의존성 배열

👉🏻 의존성이 바뀔 때만 함수가 새로 생성됨

👉🏻 바뀌지 않으면 같은 함수 객체(참조)를 계속 재사용

\- 즉, 의존성이 바뀌기 전까지 이 함수를 다시 만들지 마라는 의미

**(2) 빈 배열로 사용 (의존성 없음)**

```
const handleClick = useCallback(() => {
  console.log("한 번 만든 함수는 계속 유지!");
}, []);
```

\- 컴포넌트 생애 동안 딱 한 번만 함수가 생성됨

\- 자식 컴포넌트에 내려줘도 참조가 안 바뀌므로 불필요한 리렌더링 방지

**(3) 특정 값이 의존하는 함수 만들기**

```
const increment = useCallback(() => {
  setCount(count + 1);
}, [count]);
```

\- count가 바뀔 때마다 새로 생성됨

\- 항상 최신 count 값을 반영해야 할 때 사용

**(4) 함수형 업데이트로 의존성 줄이기**

\- 의존성이 많으면 함수가 자주 다시 생성될 수 있음

\- setState의 함수형 업데이트를 쓰면 의존성 줄이기 가능

```
const increment = useCallback(() => {
  setCount((prev) => prev + 1);   // 이전 값 참조
}, []);
```

👉🏻 의존성 배열에서 count 제거 가능

👉🏻 함수는 한 번만 생성되고 계속 재사용됨

👉🏻 자식 렌더링 빈도도 줄어듦 -> 성능 최적화

**(5) 자식 컴포넌트에게 함수 전달하기**

\- 부모가 만든 함수를 자식에게 내려주면, 함수가 매 렌더마다 새로 만들어진 경우 React.memo로 감싸도 불필요한 리렌더링 발생

👉🏻 이를 방지하려면 useCallback으로 참조를 유지해야함

**(6) useEffect 의존성 안정화**

\- useEffect는 deps에 있는 값이 바뀌면 실행됨

\- 매 렌더마다 함수가 재생성되면 Effect도 계속 재실행되는 문제가 생김

\- useCallback으로 함수 참조를 고정하면 Effect가 정말 필요한 순간에만 실행됨

#### **4\. useCallback 단점**

\- useCallback은 성능 최적화를 위한 도구지만, 모든 경우에 유리한 것이 아

**(1) 메모이제이션 비용 발생**

\- useCallback은 단순히 함수를 기억하는 것처럼 보이지만, 실제로는

👉🏻 함수 참조를 저장하고

👉🏻 의존성 배열을 비교하며

👉🏻 다음 렌더에서 재사용할지 결정하는

추가 비용 발생

\- 함수 생성 비용보다 메모이제이션 비용이 더 크면 성능이 오히려 나빠짐

**(2) 코드 복잡도 증가**

\- useCallback을 남용하면

👉🏻 함수 정의가 길어지고

👉🏻 의존성 배열 관리해야 하고

👉🏻 코드 가독성 떨어짐

**(3) 의존성 배열 관리가 까다로움**

\- 콜백 내부에서 참조하는 값을 의존성 배열에 빠뜨리면

👉🏻 컴포넌트는 최신 상태를 반영하지 못하고

👉🏻 Stale Closure(오래된 값 캡처) 현상 발생

\=> useCallback은 리렌더링 최적화에 유용하지만, 남용하면 성능 저하, 코드 복잡성, 버그를 유발할 수 있다.

---

### **2️⃣ Custom Hook**

#### **1\. 정의**

\- React에서 기본 Hook을 조합, 확장하여 만든 사용자 정의 Hook

\- use 접두사를 붙여 작성하며 재사용 가능한 상태 관리 / 비즈니스 로직 관리

**(1) 일반 Hook**

\- React가 기본적으로 제공하는 기능을 제공하는 Hook들

👉🏻 useState: 상태 관리

👉🏻 useEffect: 부수효과 관리

👉🏻 useContext: 전역 데이터 접근

👉🏻 useReducer: 복잡한 상태 업데이트

👉🏻 useMemo, useCallback: 성능 최적화

\-> 개발자는 React가 제공한 기능을 그대로 가져다 쓰기만 하면 됨

**(2) Custom Hook**

\- 프로젝트에서 반복되는 로직을 하나의 함수로 만들어 재사용하기 위한 Hook

👉🏻 반드시 use 접두사로 시작해야 함

👉🏻 내부에서는 일반 Hook들을 자유롭게 조합 가능

👉🏻 상태 관리, 데이터 fetch, 폼 로직, 스크롤 감지 등 다양한 로직을 캡슐화 가능

\=> 일반 Hook은 React가 제공하는 기본 기능, Custom Hook은 개발자가 필요한 로직을 재사용하기 위해 만든 고급 패턴

#### **2\. 사용 이유**

\- 반복되는 로직을 재사용하고, UI와 로직을 분리해 가독성과 유지보수성을 높이며, 협업 시 일관성을 확보하기 위함

**(1) 가독성 향상**

\- 컴포넌트는 UI만 다루고, 로직은 따로 분리 가능

**(2) 유지보수 용이**

\- 한 군데만 수정해도 여러 컴포넌트에 적용 가능

**(3) 협업 효율성**

\- 팀원들이 같은 규칙으로 로직 재사용 가능

#### **3\. 사용 방법**

\- use 접두사를 붙여 함수로 정의하고, 내부에서 기본 Hook들을 조합하여 로직을 구성한 뒤, 필요한 값과 함수를 반환해 컴포넌트에서 재사용

**(1) 기본 규칙**

\- use로 시작해야한다

\- 컴포넌트 최상위에서만 호출

👉🏻 조건문, 반복문, 이벤트 핸들러 안 X

👉🏻 Hook의 호출 순서가 바뀌지 않아야 React가 내부 state를 정확히 연결할 수 있음

\- 함수형 컴포넌트 또는 다른 Hook 내부에서만 사용

👉🏻 일반 함수에서는 Hook을 사용할 수 없음

**(2) 기본 형태**

\- Custom Hook은 하나의 함수

\- 내부에서 필요한 상태와 로직을 만들고, 컴포넌트가 사용할 값/함수를 반환함

```
function useSomething() {
  // 내부 로직
  return /* 값 또는 함수들 */;
}
```

\- 반환 방식은 배열 or 객체를 자유롭게 선택 (통일성만 지키면 됨)

#### **4\. 활용 예시**

**(1) 토글 상태 관리 (useToggle)**

\- Hook 코드

```
export function useToggle(initial = false) {
  const [value, setValue] = useState(initial);

  const on = useCallback(() => setValue(true), []);
  const off = useCallback(() => setValue(false), []);
  const toggle = useCallback(() => setValue(v => !v), []);

  return { value, on, off, toggle };
}
```

👉🏻 value는 현재 상태

👉🏻 on, off, toggle로 상태 변경

👉🏻 useCallback으로 참조를 고정하여 불필요한 리렌더링 방지

\- 사용

```
const modal = useToggle(false);
modal.value   // true / false
modal.on()    // 열기
modal.off()   // 닫기
modal.toggle()// 반전
```

**(1) Input 관리 (useInput)**

\- Hook 코드

```
export function useInput(initial, validate) {
  const [value, setValue] = useState(initial);
  const [error, setError] = useState();

  const onChange = useCallback((e) => {
    const v = e.target.value;
    setValue(v);
    if (validate) setError(validate(v));
  }, [validate]);

  const reset = useCallback(() => {
    setValue(initial);
    setError(undefined);
  }, [initial]);

  return { value, error, onChange, reset, bind: { value, onChange } };
}
```

👉🏻 값 + 에러 상태 관리

👉🏻 즉시 검증 가능 (validate)

👉🏻 bind 제공 -> <input {...input.bind} />처럼 간단히 바인딩 가능

**(3) 디바운스 값 (useDebounce)**

\- Hook 코드

```
export function useDebounce(value, delay = 300) {
  const [debounced, setDebounced] = useState(value);

  useEffect(() => {
    const id = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(id);
  }, [value, delay]);

  return debounced;
}
```

👉🏻  입력이 지속될 때는 반응하지 않고

👉🏻 입력이 멈췄을 때만 업데이트됨

👉🏻 검색창 API 호출 등에서 필수적인 패턴

**(4) Fetch Wrapper (useFetch)**

\- Hook 코드 요약

```
export function useFetch(url, options, deps = []) {
  const [state, setState] = useState({ data: null, loading: false, error: null });

  const stableOptions = useMemo(() => options, []);

  useEffect(() => {
    if (!url) return;
    const controller = new AbortController();

    const run = async () => {
      setState(s => ({ ...s, loading: true }));
      try {
        const res = await fetch(url, { ...stableOptions, signal: controller.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        setState({ data: await res.json(), loading: false, error: null });
      } catch (e) {
        if (e.name !== "AbortError")
          setState({ data: null, loading: false, error: e });
      }
    };

    run();
    return () => controller.abort();
  }, [url, stableOptions, ...deps]);

  return state;
}
```

👉🏻 data, loading, error를 한 번에 관리

👉🏻 URL 변경 -> 자동 fetch

👉🏻 언마운트 시 fetch 중단 (AbortController)

**(5) 합성 Hook (디바운스 + Fetch)**

```
export function useProducts(keyword) {
  const query = useDebounce(keyword, 300);
  return useFetch(query ? `/api/products?q=${query}` : null, null, [query]);
}
```

👉🏻 검색 입력을 바로 API에 보내지 않고

👉🏻 디바운스된 값으로만 서버 요청 -> 서버 부하 감소

#### **5\. 최종 요약**

**(1) Custom Hook의 목적**

\- 반복되는 로직을 묶어 재사용성 향상

\- 컴포넌트는 UI만 담당하게 해서 가독성 향상

\- 복잡한 로직을 Hook으로 분리해 유지보수성 향상

**(2) Custom Hook 사용 시 핵심 규칙**

\- use로 시작해야 함

\- 최상위에서만 호출

\- 컴포넌트/Hooks 내부에서만 사용 가능

**(3) Custom Hook의 강점**

\- 상태 + 로직 캡슐화

\- 여러 기능 조합 가능

\- 데이터 패치, 입력 관리, 토글 등 다양하게 확장 가능

---

### **3️⃣ Context**

#### **1\. 정의**

\- 컴포넌트 트리 전체에 값을 전달, 공유하기 위한 리액트의 공식 메커니즘

#### **2\. 사용 이유**

\- 멀리 떨어진 컴포넌트들 사이에서 중요한 공통 데이터를 안정적으로 공유하기 위함

\- Prop Drilling 없이 깔끔한 구조를 만들고 전체 앱의 일관성을 유지하기 위함

\- 리액트 애플리케이션이 커질수록 여러 화면에서 동시에 필요로 하는 값이 많아짐

👉🏻 로그인한 사용자 정보, 다크/라이트 모드, 다국어 설정, 현재 선택된 프로젝트

👉🏻 이런 값들을 props로 계속 전달하면 구조가 복잡해지고 유지보수가 매우 어려워짐

👉🏻 Context를 사용

**(1) Prop Drilling 제거**

\- props 계속 전달(prop Drilling)

👉🏻 중간 컴포넌트가 실제로는 필요 없는 데이터를 전달만 해야 해서 코드가 지저분해짐

\- Context 사용

👉🏻 중간 컴포넌트는 전달 역할이 필요 없음

👉🏻 트리 어디에서도 바로 useContext로 필요한 값을 꺼내 쓸 수 있음

**(2) 앱 전역에서 데이터 일관성 유지**

\- Context로 관리하는 데이터는 전역적이고, 여러 컴포넌트가 동시에 동기화되어야 하는 값에 적합함

👉🏻 로그인 유저 정보, 테마 정보, 언어 설정

\- 전역 정보가 바뀌면 필요한 화면만 자동 업데이트

\- 최신 데이터를 항상 유지

**(3) 내부 로직과 UI 사용법 분리 (캡슐화)**

\- Context Provider 내부에는 복잡한 비즈니스 로직이 들어가도, 외부 컴포넌트는 사용법만 동일하게 유지됨

\- 내부 인증 방식이 바뀌어도 컴포넌트는 여전히 login(), logout()만 부르면 됨

\- 즉, Provider만 수정하면 전체 앱에 반영 가능 -> 유지 보수성이 크게 증가

#### **3\. 사용 방법**

\- createContext로 컨텍스트를 만들고 -> 상위에서 Provider로 값을 방송한 뒤 -> 하위에서 useContext로 수신

\- Conetxt는 전역적으로 공유해야 하는 값을 브로드캐스트하고, 트리 어디에서든 구독할 수 있게 해주는 React의 기능

**(1) Context 생성하기 (createContext)**

\- 컨텍스트는 앱 전체에서 사용할 전역 채널 같은 것

```
// ThemeContext.js
import { createContext } from "react";

export const ThemeContext = createContext("light");
```

\- 기본값은 설명용일 뿐, 보통 null 또는 실제 초기값을 넣음

\- 여기서 만든 Context는 채널 이름 같은 것

**(2) Provider로 값 방송하기**

\- Context 값을 실제로 공급하려면 반드시 Provider가 필요

```
// App.jsx
import { useState, useMemo } from "react";
import { ThemeContext } from "./ThemeContext";

export default function App() {
  const [theme, setTheme] = useState("light");

  // 매 렌더마다 value 객체가 바뀌는 문제를 방지 → useMemo로 참조 안정화
  const themeValue = useMemo(() => ({ theme, setTheme }), [theme]);

  return (
    <ThemeContext.Provider value={themeValue}>
      <Page />
    </ThemeContext.Provider>
  );
}
```

\- Provider로 감싼 범위 안에서만 Context 값을 사용할 수 있음

\- value={{ theme, setTheme }}처럼 새 객체를 직접 넣으면 렌더링 때마다 참조가 바뀌어 자식들이 모두 리렌더됨

👉🏻 반드시 useMemo로 안정화

**(3) useContext로 값 수신하기**

\- 트리 어디서든 직접 받아서 쓸 수 있음

\- 중간에 props로 전달할 필요 없음

**(4) 값 + 액션(함수) 함께 제공하기**

\- Context에는 단순 값뿐만 아니라 여러 함수 (로그인, 로그아웃 등)도 전역 서비스처럼 함께 제공 가능

\- Provider 내부

```
// AuthProvider.jsx
import { useState, useMemo } from "react";
import { AuthContext } from "./safe-context";

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);

  const login = (name) => setUser({ name });
  const logout = () => setUser(null);

  const value = useMemo(() => ({ user, login, logout }), [user]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}
```

\- 사용하는 쪽

```
// Header.jsx
import { useAuth } from "./safe-context";

export default function Header() {
  const { user, login, logout } = useAuth();

  return user ? (
    <div>
      <span>{user.name}님</span>
      <button onClick={logout}>로그아웃</button>
    </div>
  ) : (
    <button onClick={() => login("민수")}>로그인</button>
  );
}
```

\- 장점

👉🏻 setUser 같은 내부 상태를 직접 노출하지 않아도 됨 -> 더 안전한 구조

👉🏻 외부에서는 단순히 login(), logout()처럼 서비스 API만 사용하면 됨

👉🏻 Provider 내부 로직이 바뀌어도, 외부 컴포넌트는 변경할 필요 없음 -> 높은 캡슐화

#### **4\. 주의 사항**

**(1) 성능 이슈: Provider value가 바뀌면 하위 전부 리렌더**

\- Context의 value가 변경되면, 그 값을 구독(useContext)하는 모든 하위 컴포넌트가 다시 렌더링됨

\- 모든 전역 값을 한 Context에 몰아 넣으면

👉🏻 theme만 바뀌어도, cart를 쓰는 컴포넌트까지 다 리렌더됨

👉🏻 규모 커질수록 성능 크게 저하

\- Context를 기능별로 분리하기

👉🏻 필요한 곳만 리렌더됨

👉🏻 전역 상태를 여러 작은 Provider로 나누면 체감 성능이 좋아짐

**(2) Context 남발 시 디버깅 어려움**

\- Context는 어디서든 가져다 쓸 수 있어 편하지만

👉🏻 어떤 컴포넌트가 어떤 값을 의존하는지 한눈에 보이지 않음

👉🏻 값 변경이 어디까지 영향을 미치는지 추적하기 어려움

👉🏻 숨은 의존성이 많아져 버그 찾는 시간이 길어짐

\- Context는 정말 전역으로 공유해야하는 값에만 사용해야 함

👉🏻 테마, 로그인 정보, 설정 등

**(3) Provider를 빠뜨리면 발생하는 오류**

\- Provider 없이 useContext만 호출하면

👉🏻 null, undefined, 기본값 등으로 동작

👉🏻 원인 찾기 어려운 런타임에 에러 유발

\- 안전한 패턴: 안전한 useContext

```
const Ctx = createContext(null);

function useSafeCtx() {
  const value = useContext(Ctx);
  if (value == null)
    throw new Error("반드시 <Ctx.Provider> 안에서 사용해야 합니다!");
  return value;
}
```

👉🏻 실수를 즉시 알려줘서 디버깅 난이도를 낮춤

**(4) 서버 상태(데이터 패치)를 Context로 관리하면 금방 한계 도달**

\- Context는 전달 역할만 하는 도구

\- 서버 상태를 관리하기 위한 기능은 없음

👉🏻 캐싱, 리패치, 중복 요청 방지, 백그라운드 업데이트, 에러/로딩 상태 관리

👉🏻 이런 기능은 Context가 처리 불가

\- 추천 대안

👉🏻 React Query

👉🏻 SWR

👉🏻 통신 + 캐싱만을 처리하는 Custom Hook

\- 서버 상태는 전문 도구에게 맡기고, Context는 전역 UI 상태 중심으로 사용하는 것이 좋음

---

### **4️⃣ Error Bounary**

#### **1\. 정의**

> React에서 컴포넌트 하위 트리에서 발생하는 렌더링 관련 오류를 감싸서, 전체 앱이 무너지지 않고 대체 UI를 보여주도록 하는 특별한 컴포넌트

**(1) Error Boundary가 필요한 이유**

\- React 앱에서는 자식 컴포넌트에서 오류가 발생해도 부모까지 영향을 미쳐 전체 화면이 하얗게 사라질 수 있음

👉🏻 이걸 방지하기 위해 특정 컴포넌트 영역만 격리해서 에러를 잡는 역할을 하는 것이 Error Boundary

**(2) Error Boundary가 하는 일**

\- 오류 감지: 렌더링 과정, lifecycle 과정에서 발생하는 에러를 감지한다 (이벤트 핸들러의 에러는 해당되지 않음)

\- 오류 전파 차단: 오류가 상위로 퍼져 전체 앱이 중단되는 것을 막음

\- fallback UI 보여주기: 오류가 발생한 구역만 잠시 차단하고 대체 화면(fallback)을 보여줌

\- 에러 정보 로깅: 수집한 정보를 콘솔 또는 모니터링 서비스로 전달 가능

> **❓ fallback UI**  
> \- 오류 발생 시 임의로 사용자에게 보여주는 화면  
> \- 정상 화면 대신 보여주는 예비 화면  
> 👉🏻 데이터를 불러오지 못했습니다. 문제가 발생했습니다. 새로고침을 시도해주세요 등  
> \- 오류가 난 부분만 대체하고 앱 전체는 멈추지 않게 함  
>   
> \- 왜 중요?  
> 👉🏻 전체 앱이 멈추는 화이트 스크린 방지  
> 👉🏻 사용자 경험을 지켜주는 안전장치  
> 👉🏻 운영 환경에서 오류를 빠르게 감지하고 대응 가능  
> 👉🏻 컴포넌트 단위로 문제를 격리해 안정적인 UI 제공

#### **2\. 사용 이유**

\- 오류가 발생했을 때 전체 앱이 멈추는 것을 막고, 특정 영역만 격리해 안정성을 높이기 위해 사용

**(1) 앱 전체 다운 방지**

\- 하위 컴포넌트에서 오류가 발생해도 그 부분만 차단하고, 나머지 앱은 정상 동작하도록 만들어줌

**(2) 사용자 경험(UX) 보호**

\- 오류가 나도 하얀 화면 대신 안내 문구나 복구 버튼 같은 대체 화면(fallback UI)을 띄워 사용자 혼란을 줄일 수 있음

**(3) 오류 정보 로깅 & 추적**

\- Error boundary는 오류 객체와 컴포넌트 스택을 전달받을 수 있어서, 이를 서버나 Sentry 같은 모니터링 서비스로 보내면 운영 환경에서 발생한 문제를 바로 확인 가능

👉🏻 단순 방어가 아니라 문제 파악/수정에 필수적인 역할도 수행

**(4) 위험한 영역만 부분적으로 격리 가능**

\- 앱 전체를 한 번에 감쌀 수도 있지만, 차트, 광고, 추천 영역처럼 오류 위험도가 높은 특정 부분만 감싸는 것도 가능

\- 특정 컴포넌트만 오류가 나도 해당 영역만 격리되고 페이지 전체는 정상 유지됨

#### **3\. 사용 방법**

\- 하위 트리를 감싸는 방식으로 배치함

\- 오류 발생 시 지정한 풀백 UI가 나타나고, 오류는 로깅 가능

**(1) 설치**

```
npm i react-error-boundary
```

**(2) Fallback UI 만들기**

\- 오류가 발생했을 때 보여줄 대체 화면을 컴포넌트로 만듦

```
function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert">
      <h2>문제가 발생했습니다.</h2>
      <p>{error.message}</p>
      <button onClick={resetErrorBoundary}>다시 시도</button>
    </div>
  );
}
```

\- error: 실제 에러 객체

\- resetErrorBoundary() : Error Boundary 초기화 (재시도)

**(3) 감싸기(Protect) - ErrorBoundary 사용**

\- Error가 날 가능성이 있는 영역을 ErrorBoundary로 감쌈

\- 단순 fallback 사용

```
<ErrorBoundary fallback={<p>문제가 발생했습니다.</p>}>
  <FragileWidget />
</ErrorBoundary>
```

\- fallbackRender: 함수를 사용해 동적 UI 구성

```
<ErrorBoundary
  fallbackRender={({ error, resetErrorBoundary }) => (
    <div>
      <h2>에러 발생</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>다시 시도</button>
    </div>
  )}
>
  <FragileWidget />
</ErrorBoundary>
```

\- FallbackComponent: 컴포넌트로 분리하여 재사용

```
<ErrorBoundary FallbackComponent={ErrorFallback}>
  <FragileWidget />
</ErrorBoundary>
```

**(4) 에러 로깅(onError)**

\- 운영 환경에서는 오류를 기록해야 함

\- ErrorBoundary는 onError에서 오류 정보와 컴포넌트 스택을 받을 수 있음

```
function logError(error, info) {
  console.error("에러:", error);
  console.error("스택:", info.componentStack);
}

<ErrorBoundary FallbackComponent={ErrorFallback} onError={logError}>
  <FragileWidget />
</ErrorBoundary>
```

\-> Sentry, Datadog 등에 전송 가능

**(5) 다시 시도(retry) 기능**

\- Fallback 내부에서 resetErrorBoundary() 호출

```
<button onClick={resetErrorBoundary}>다시 시도</button>
```

\- key 변경으로 강제 리마운트

```
function RetryableBlock() {
  const [retry, setRetry] = useState(0);

  return (
    <>
      <button onClick={() => setRetry(r => r + 1)}>다시 시도</button>
      <ErrorBoundary FallbackComponent={ErrorFallback}>
        <FragileWidget key={retry} />
      </ErrorBoundary>
    </>
  );
}
```

**(6) 비동기/이벤트 에러도 ErrorBoundary로 보냄**

\- Error Boundary는 렌더링 중 발생한 에러만 자동으로 잡음

\- 이벤트, fetch 에러는 직접 ErrorBoundary로 올려 보내야 함

\- useErrorBoundary() 사용

```
function AsyncWidget() {
  const { showBoundary } = useErrorBoundary();

  const handleClick = async () => {
    try {
      await doSomethingAsync();
    } catch (e) {
      showBoundary(e); // ErrorBoundary로 오류 전달
    }
  };

  return <button onClick={handleClick}>실행</button>;
}
```

---

### **5️⃣ Suspense**

#### **1\. 정의**

\- React에서 비동기 작업(데이터 로딩, 코드 스플리팅 등) 중 대기 상태를 다루고, 준비되지 않은 UI 대신 풀백(Fallback)을 보여주는 기능

👉🏻 사용자가 프로필 화면을 보려고 할때 서버에서 데이터가 도착하기 전까지 "불러오는 중..."같은 메시지를 먼저 보여주는 방식

👉🏻 사용자는 단절이 아닌 기다림의 경험을 하게 되고, 애플리케이션은 보다 부드럽게 동작함

#### **2\. 사용 이유**

> 비동기 데이터를 기다리는 동안 사용자 경험을 부드럽게 만들고, 컴포넌트가 준비되지 않은 상태에서 UI가 깨지는 것을 방지하기 위함

\- 리액트 컴포넌트는 원래 즉시 그릴 수 있는 값(state, props)을 기준으로 렌더링함

👉🏻 하지만 실제 앱은 데이터 패칭, 동적 import, 이미지/리소스 로딩처럼 비동기 작업이 완료되어야만 UI를 그릴 수 있는 상황이 많음

👉🏻 이때 Suspense는 '준비 중'과 '완료 상태'를 선언적으로 분리해 일관된 로딩 경험을 제공함

**(1) 로딩 상태를 선언적으로 관리**

```
<Suspense fallback={<p>불러오는 중...</p>}>
  <UserDetails />
</Suspense>
```

\- 로딩 UI를 별도 state 없이 렌더 트리 구조로 선언 가능

\- 로딩 표현 방식이 간단하고 일관됨

**(2) 사용자 경험(UX) 부드럽게 유지**

\- 비동기 작업 중

👉🏻 화면이 빈 채로 몇 초 동안 멈춤

👉🏻 UI 일부가 깜빡이며 보였다 사라짐

👉🏻 준비되지 않은 UI가 잠깐 잘못 보이는 플래시(flash) 

같은 문제 발생

\- Suspense는 항상 먼저 fallback UI를 보여줌

👉🏻 앱이 멈췄다는 느낌 없애고 기다리는 중을 명확하게 전달

👉🏻 자연스럽고 안정적인 로딩 경험 제공

**(3) 비동기 흐름 단순화**

\- 데이터 로딩, 코드 스플리팅, 이미지 로딩 등 서로 다른 비동기 작업을 Suspense 하나로 관리 가능

```
<Suspense fallback={<Spinner />}>
  <Comments />   // 내부에서 fetch
</Suspense>
```

\- 모든 비동기 처리는

👉🏻 준비 안 됨 -> fallback UI 표시

👉🏻 준비 됨 -> 정상 UI 렌더링

이 두 단계만으로 단순화됨

**(4) UI와 비동기 로직의 명확한 분리**

\- 컴포넌트는 준비된 UI만 책임지고, 로딩 중 상태나 통제는 Suspense가 알아서 관리함

\- UI는 UI만 담당

\- 비동기 흐름은 Suspense가 담당

\- 코드의 역할이 선명해지고 유지보수성이 올라감

**(5) 최신 React에서는 필수 요소**

\- React 18 이후의 기능들은 모두 Suspense 기반으로 동작함

👉🏻 서버 컴포넌트

👉🏻 use(fetch()) 데이터 패칭

👉🏻 동적 Import(React.lazy)

👉🏻 스트리밍 SSR

\- 현대 React에서 비동기 UI의 표준은 Suspense이며 앞으로 더 중요해지는 기능

#### **3\. 사용 방법**

\- <Suspense fallback={...}>로 하위 컴포넌트를 감싸고, 로딩 중일 때 보여줄 UI를 fallback 속성에 전달

**(1) 기본 사용 형태**

\- 하위 컴포넌트가 비동기 로딩 중이면, Suspense는 즉시 fallback UI를 보여줌

```
<Suspense fallback={<p>불러오는 중...</p>}>
  <Profile />   {/* 내부에서 데이터를 기다리는 컴포넌트 */}
</Suspense>
```

**(2) 클라이언트 컴포넌트 (Promise throw 패턴)**

\- 순수 클라이언트 컴포넌트에서 Suspense를 사용하려면 아직 준비되지 않은 시점에 Promise를 throw하는 래퍼가 필요함

👉🏻 pending -> Promise throw -> fallback UI 표시

👉🏻  success: 값 반환

👉🏻  error → Error throw → ErrorBoundary로 전달

\- 이 구조가 Suspense가 작동하는 핵심원리

```
resource.read(); 
// 준비 전 → Promise throw → Suspense fallback
// 실패 → Error throw → ErrorBoundary fallback
// 성공 → 데이터 반환
```

**(3) 서버 컴포넌트 (use() 기반 데이터 대기)**

\- React 19 이후, 서버 컴포넌트에서는 use()로 Promise를 직접 기다릴 수 있음

```
<Suspense fallback={<p>로딩 중…</p>}>
  <UsersList />   {/* 내부에서 use(fetchPromise) */}
</Suspense>
```

\- 서버에서는 이미 기다림이 처리된 HTML을 스트리밍할 수 있어 Suspense가 더욱 자연스럽게 동작함

**(4) 부분적 로딩 (중첩 Suspense)**

\- 여러 개의 섹션을 각각 Suspense로 감싸면, 준비된 부분부터 즉시 렌더링하며 UX를 부드럽게 만든다

```
<Suspense fallback={<p>통계 로딩…</p>}>
  <Stats />
</Suspense>

<Suspense fallback={<p>피드 로딩…</p>}>
  <Feed />
</Suspense>
```

**(5) Skeleton UI와 함께 사용하기**

\- fallback에 단순 문구보다 스켈레톤 레이아웃을 넣으면 깜빡임 없이 자연스러움

```
<Suspense fallback={<ProfileSkeleton />}>
  <ProfileCard />
</Suspense>
```

**(6) Suspense + ErrorBoundary 조합 (필수 패턴)**

\- Suspense는 로딩을 담당하고, ErrorBoundary는 실패를 담당함

```
<ErrorBoundary FallbackComponent={ErrorFallback}>
  <Suspense fallback={<p>로딩 중...</p>}>
    <Products />
  </Suspense>
</ErrorBoundary>
```

👉🏻 로딩: Suspense

👉🏻 에러: ErrorBoundary

두 개를 함께 써야 로딩/실패/성공이 전체 흐름이 깔끔하게 완성됨

**(7) 다시 시도(retry) 패턴**

\- ErrorBoundary의 reset기능 + key 리마운트 전략 조합

```
<ErrorBoundary
  onReset={() => setVersion(v => v + 1)}
  resetKeys={[version]}
>
  <Suspense fallback={<p>로딩…</p>}>
    <Products key={version} />
  </Suspense>
</ErrorBoundary>
```

\- 버튼 클릭 -> version 변경 -> 컴포넌트 리마운트 -> 다시 로딩

**(8) 이미지, 리소스 로딩에도 사용 가능**

\- Suspense는 준비되지 않은 상태 (Promise)가 throw되면 무엇이든 기다릴 수 있음

\- 이미지 프리로드도 가능

```
<Suspense fallback={<Skeleton />}>
  <RealImage />
</Suspense>
```

---

### **6️⃣ Concurrent Rendering**

#### **1\. 정의**

\- React가 내부적으로 렌더링 작업을 끊어서 쪼개고 우선순위를 조정하여 사용자 인터랙션을 우선 처리하도록 한 새로운 렌더링 방식

> **❓Concurrent**  
> \- ReactdML Concurrent Rending은 CPU 멀티스레드 병렬 실행이 아니라, 하나의 스레드 안에서 작업을 잘게 쪼개어 우선 순위를 조정하는 방식  
> \- 우선순위 스케줄링

#### **2\. 사용 이유**

> 긴 렌더링 작업이 있더라도 UI가 멈춘 것처럼 보이지 않게 하여 사용자 경험(UX)을 부드럽게 만들기 위해

\- 기존의 렌더링 방식 (동기 렌더링)은 한 번 렌더링이 시작되면 끝날 때까지 멈추지 못하는 문제가 있었음

\- 그래서 큰 리스트 렌더링, 복잡한 차트, 입력 시 필터링, 무거운 연산이 있는 UI 같은 작업이 있을 때 브라우저가 잠깐 멈춘 것처럼 보이는 현상 (input 지연, 렉, 깜빡임)이 자주 발생

👉🏻 사용자는 이것을 앱이 느리다, 버그라고 느낌

👉🏻 Concurrent Rendering

\- React는 렌더링을 작은 조각으로 나누고, 각 조각 사이에 브라우저에게 기회를 줌

👉🏻 무거운 렌더링 작업

👉🏻 대량 리스트 렌더링

👉🏻 복잡한 컴포넌트 계산

\- 이런 작업들이 있어도, 타이핑, 클릭, 스크롤 같은 중요한 상호작용이 우선 처리됨

👉🏻 사용자는 앱이 빠르고 부드럽게 느껴짐

**(1) UI가 멈춘 것처럼 보이는 현상 제거**

\- 브라우저는 사용자의 행동에 즉각 반응하고, 렌더링은 그 뒤에 이어 진행됨

**(2) 입력 지연, 스크롤 끊김 감소**

\- 특히 검색창 필터링 같은 동적 UI에 큰 효과

**(3) 개발자가 성능 최적화를 덜 신경 써도 됨**

\- 기존에는 직접 해야 했던 Debounce, Throttle 등이 많은 경우 필요 없어짐

> **❓ 리액트는 어떻게 작업을 쪼개나요?**  
> \- React Fiber 아키텍처 덕분  
> \- 리액트 렌더링은 여러 작은 단위로 나누고, 각 단위 사이에서 브라우저에게 제어권을 넘겨줌  
> 👉🏻 그래서 렌더링 도중에도 클릭->바로 반응, 타이핑->즉시 반영 가능

#### **3\. 사용 방법**

\- React 19에서는 기본 활성화

\- 개발자는 useTranstition, startTransition으로 덜 급한 업데이트를 표시하여 UI 반응성 유지 가능

**(1) React 18+에서는 자동으로 동작**

\- React는 자동으로 렌더링 작업을 잘게 나누고, 타이핑이나 클릭 같은 긴급 이벤트를 우선 처리함

\- 설정 없이도 앱은 더 부드럽게 동작함

\- 하지만 '이 작업은 급하지 않으니 여유 있을 때 처리해도 된다'라고 React에게 알려주면 UI가 더 자연스러워짐

👉🏻 useTransition, startTransition 사용

**(2) useTransition 기본 구조**

```
const [isPending, startTransition] = useTransition();
```

\- startTransition(fn)

👉🏻 fn 안의 상태 업데이트를 낮은 우선순위(transition)로 실행함

\- isPending

👉🏻 transition 작업이 실행 중이면 true

👉🏻 로딩 UI 표시 등에 사용

> 성능이 빨라지는 것이 아니라, 사용자 입장에서 더 부드럽게 느껴지도록 만드는 기술

**(3) 핵심 사용 패턴**

```
function handleChange(e) {
  const value = e.target.value;

  setQuery(value); // 즉시 반영되는 긴급 업데이트

  startTransition(() => {
    // 무거운 연산(리스트 필터, 정렬 등)은 비긴급 업데이트로 처리
    setFiltered(items.filter(it => it.includes(value)));
  });
}
```

\- 입력창은 지연 없이 반응

\- 필터링/정렬 등 큰 렌더링 작업은 뒤로 밀림

\- UI는 끊김 없이 반응

**(4) API와 함께 쓰는 패턴**

\- Transition은 네트워크 속도 자체는 바꾸지 않음

\- 하지만 응답을 반영하는 무거운 렌더링을 뒤로 보내 UI 즉시성을 지킴

```
fetch(`/api/search?q=${query}`)
  .then(res => res.json())
  .then(data => {
    startTransition(() => {
      setList(data.items); // 결과 반영은 '천천히'
    });
  });
```

\- fetch 속도는 동일

\- 하지만 결과 렌더링이 UI를 막지 않음

\- 연속 입력 시 AbortController로 이전 요청 취소 가능

**(5) 탭 전환/라우팅에서 부드러운 전환 만들기**

\- 탭을 누르면 UI가 잠시 멈추는 느낌이 들 수 있는데, 그 탭의 무거운 렌더링만 transition으로 처리하면 매끄러워짐

```
setActiveTab(tab);   // 즉시 UI 반응
startTransition(() => loadTabData(tab)); // 큰 렌더링은 여유 있게
```

**(6) 대량 리스트 정렬/필터링에 매우 유용**

```
function changeSort(by) {
  setSort(by); // 즉시 반영

  startTransition(() => {
    setSorted(heavySort(items, by)); // 느린 작업은 뒤로 보냄
  });
}
```

\- 사용자는 드롭다운 선택이 바로 반응했다고 느끼지만, 정렬 작업은 백그라운드처럼 처리됨

> Concurrent Rendering은 자동으로 동작하며,  
> useTransition / startTransition을 사용해 덜 급한 UI 업데이트를 분리하면 UI가 매우 부드럽게 유지됨
