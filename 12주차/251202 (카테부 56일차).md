## **🧠 회고**
​
오늘은 Route, Form, Fetch를 배우면서 프론트엔드에서 “사용자 흐름 → 입력 처리 → 서버 통신”이 하나의 큰 흐름으로 이어져 있다는 걸 이해한 하루였다. 라우팅을 통해 페이지 구조와 이동 흐름을 설계하는 법을 익혔고, Form에서는 단순 입력을 넘어서 검증·상태관리·에러 메시지 등 실제 서비스에 필요한 요소들이 얼마나 중요한지 깨달았다. 마지막으로 Fetch를 통해 서버와 데이터를 주고받는 기본기를 다지며, 결국 프론트엔드의 핵심은 사용자의 행동을 정확히 읽고, 필요한 데이터를 받아와 자연스럽게 화면에 반영하는 것이라는 걸 느꼈다.
​
## **🪽 오늘의 다짐**
​
앞으로는 사용자 흐름을 먼저 생각하고, 라우트–폼–페치가 자연스럽게 이어지는 구조를 스스로 설계할 수 있는 개발자가 되자. 단순히 동작하는 코드가 아니라, 흐름이 명확하고 견고한 코드를 작성하는 습관을 꾸준히 만들어가자.
​
---
​
## **📝 Today I Learned**
​
### **1️⃣ Route**
​
#### **1\. 정의**
​
\- 제품/웹에서 URL을 통해 화면, 기능, 데이터의 위치를 약속하는 체계
​
\- URL과 컴포넌트(또는 페이지)를 연결해주는 규칙
​
\- 페이지 전체를 새로고침하지 않고도 브라우저 주소를 바꾸며 다른 화면을 렌더링할 수 있게 해줌
​
#### **2\. 사용 이유**
​
> 단일 HTML인 React 구조에서 새로고침 없이 주소화 화면을 매핑하기 위함
​
\- React(특히 SPA)에서는 한 번 HTML, JS를 로드하고 나서 전체 새로고침 없이 화면만 바꿔 보여줌
​
\- 이때 주소와 화면을 매핑해주는 Route가 없으면 지금 이 컴포넌트가 어떤 페이지인지 금세 헷갈리게 됨
​
**(1) 새로고침 없는 빠른 화면 전환**
​
\- /products -> /products/123 이동 시 브라우저가 다시 로드하지 않음
​
\- 깜빡임 없이 즉시 컴포넌트를 교체해 자연스러운 전환 제공
​
\- 모바일 앱처럼 부드러운 UX
​
**(2) 성능 최적화 (코드 스플리팅, 프리패치)**
​
\- React Router는 페이지 단위로 코드를 나눌 수 있어 성능을 높일 수 있음
​
👉🏻 사용자가 아직 방문하지 않은 페이지의 JS를 미리 다운로드
​
👉🏻 실제로 이동할 때는 즉시 표시
​
👉🏻 대형 쇼핑몰처럼 페이지가 많은 앱에서 매우 중요
​
**(3) 경로 기반 접근 제어 (권한 관리)**
​
\- 라우터는 미들웨어 역할도 할 수 있음
​
👉🏻 /admin 페이지는 관리자인 경우만 접근
​
👉🏻 로그인 안했으면 /login으로 자동 이동
​
👉🏻 특정 사용자만 특정 페이지를 볼 수 있도록 제어
​
\- 라우팅이 없으면 이런 기능을 직접 만들어야 함
​
**(4) 동적 파라미터, 쿼리로 내부 상태를 URL에 저장**
​
```
/products/123?tab=review
```
​
\- 동적 파라미터
​
👉🏻 /products/:id -> /products/123
​
👉🏻 여러 상품 상세를 단 1개의 라우트로 처리 가능
​
\- 쿼리
​
👉🏻 ?tab=review
​
👉🏻 필터, 탭 상태를 URL에 저장해서 새로고침해도 유지
​
👉🏻URL 공유 시 동일 화면 재현 가능
​
**(5) 실제 예시 코드**
​
```
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";
import ProductList from "./ProductList";
import ProductDetail from "./ProductDetail";
​
function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/products">상품 목록</Link>
      </nav>
​
      <Routes>
        <Route path="/products" element={<ProductList />} />
        <Route path="/products/:id" element={<ProductDetail />} />
      </Routes>
    </BrowserRouter>
  );
}
```
​
\- products : ProductList 표시
​
\- /products/123 : ProductDetail 표시
​
> **비유로 이해하기**  
> \- React Route는 네비게이션 앱과 같음  
> 👉🏻 현재 주소(URL)을 보고  
> 👉🏻 어떤 화면(지도, 상세 정보 등)을 보여줄지 즉시 결정해줌  
> \- SPA는 실제 페이지 이동이 없기 때문에, Route가 없으면 현재 화면이 무엇인지 파악하기가 매우 어려움
​
#### **3\. 사용 방법**
​
\- URL 경로에 따라 어떤 컴포넌트를 렌더링 할지 정해 사용
​
**(1) BrowserRouter**
​
\- 라우팅의 최상위 컨테이너
​
\- 앱 전체에서 라우팅을 사용하기 위해 가장 바깥을 BrowserRouter로 감쌈
​
```
import { BrowserRouter } from "react-router-dom";
import App from "./App";
​
ReactDOM.createRoot(document.getElementById("root")).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```
​
\- BrowserRouter 아래에서만 <Routes>, useNavigate 등이 정상 동작함
​
**(2) Routes & Route**
​
\- URL과 컴포넌트를 매핑하는 규칙
​
\- <Routes> : 여러 Route 규칙을 관리하는 스위치 박스
​
\- <Route> : 경로(path)와 렌더링할 컴포넌트(element)를 선언
​
```
import { Routes, Route } from "react-router-dom";
​
export default function App() {
  return (
    <Routes>
      <Route path="/" element={<Layout />}>
        <Route index element={<Home />} />
        <Route path="products" element={<Products />} />
        <Route path="products/:id" element={<ProductDetail />} />
        <Route path="*" element={<NotFound />} />
      </Route>
    </Routes>
  );
}
```
​
👉🏻 :id 같은 동적 경로도 가능
​
👉🏻 index는 / 기본 페이지를 의미
​
👉🏻 "\*"는 존재하지 않는 모든 경로 -> 404처리
​
**(3) Link / NavLink** 
​
\- 새로고침 없이 이동하는 버튼
​
\- <a href>는 전체 페이지를 새로고침하므로, SPA에서는 Link를 사용해야 함
​
```
import { Link, NavLink } from "react-router-dom";
​
<nav>
  <NavLink to="/" end>Home</NavLink>
  <NavLink to="/products">Products</NavLink>
</nav>
​
<Link to="/products/123?tab=review">상품 123 리뷰</Link>
```
​
\- NavLink는 현재 선택된 메뉴에 스타일을 주는 용도로 사용
​
\- 전체 새로고침 없이 즉시 이동
​
**(4) Outlet**
​
\- 부모 레이아웃에서 자식 페이지가 들어갈 자리
​
\- 공통 레이아웃(헤더/사이드바 등)을 유지하면서 아래 영역만 라우팅으로 교체할 때 사용
​
```
import { NavLink, Outlet } from "react-router-dom";
​
export default function Layout() {
  return (
    <>
      <nav>
        <NavLink to="/" end>홈</NavLink>
        <NavLink to="/about">소개</NavLink>
      </nav>
​
      {/* 자식 라우트가 여기 렌더링됨 */}
      <main>
        <Outlet />
      </main>
    </>
  );
}
```
​
**(5) useNavigate()**
​
\- 코드(이벤트)로 라우팅 이동
​
\- 버튼 클릭, 폼 제출 후 이동 등 코드 안에서 페이지 이동이 필요할 때 사용
​
```
import { useNavigate } from "react-router-dom";
​
export default function Form() {
  const navigate = useNavigate();
​
  const onSubmit = (e) => {
    e.preventDefault();
    navigate("/products");
  };
​
  return <form onSubmit={onSubmit}>...</form>;
}
```
​
**(6) useParams()**
​
\- 동적 URL 값 읽기
​
\- /products/:id 같은 경로에서 실제 id 값 읽기
​
```
import { useParams } from "react-router-dom";
​
export default function ProductDetail() {
  const { id } = useParams();
  return <h1>Product #{id}</h1>;
}
```
​
**(7) useSearchParams()**
​
\- 쿼리스트링 읽기/설정
​
\- ?tab=review&page=2 같은 값 처리
​
```
import { useSearchParams } from "react-router-dom";
​
export default function Products() {
  const [params, setParams] = useSearchParams();
​
  const tab = params.get("tab") ?? "all";
  const setTab = (t) => setParams({ tab: t });
​
  return (
    <>
      <button onClick={() => setTab("review")}>리뷰</button>
      <p>현재 탭: {tab}</p>
    </>
  );
}
```
​
**(8) useLocation()**
​
\- 현재 URL 변경 감지
​
\- 페이지 이동 시 스크롤 복귀, 분석 트래킹 등에서 사용
​
```
import { useEffect } from "react";
import { useLocation } from "react-router-dom";
​
export default function ScrollTop() {
  const { pathname } = useLocation();
  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]);
  return null;
}
```
​
**(9) Navigate 컴포넌트**
​
\- 특정 URL로 자동 이동
​
\- 과거 주소를 새 주소로 보내는 리다이렉트 패턴
​
```
import { Navigate, Route, Routes } from "react-router-dom";
​
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/old" element={<Navigate to="/" replace />} />
</Routes>;
```
​
> **요약**  
> \- React Router는 SPA에서 URL 경로에 따라 어떤 화면을 보여줄지 결정하는 도구  
> \- <BrowserRouter>로 감싸고 <Routes>로 규칙을 선언하여, Link,useNavigate 등을 통해 새로고침 없이 부드럽게 페이지 전환 가능
​
---
​
### **2️⃣ Form**
​
#### **1\. 정의**
​
>  웹, 리액트에서 사용자 입력을 수집, 검증, 제출하는 UI와 상태의 묶음
​
\- 단순히 화면에 보이는 <form> 태그만 의미하는 것이 아님
​
\- 입력 UI + 상태 관리 + 검증 + 제출 로직이 결합된 개념
​
**(1) 웹에서의 Form**
​
\- 사용자에게 입력 UI 제공
​
👉🏻 <input>, <select>, <textarea>
​
\- 값을 모아서 서버에 제출
​
\- 버튼 클릭으로 submit 동작 실행
​
\- 사용자의 데이터를 수집해 서버로 보내기 위한 UI 묶음
​
**(2) React에서의 Form**
​
\- UI + state + validation + submit + error 처리 + 성능 관리
​
\- 리액트는 SPA이기에 페이지가 새로 고쳐지지 않고, 입력값을 실시간으로 검사하거나 동적으로 UI를 바꿔야함
​
👉🏻 따라서 Form은 단순 UI가 아니라 하나의 기능 단위(feature uniit)로 다룸
​
\- React Form이 포함하는 요소
​
👉🏻 입력값 상태 관리 (useState / useReducer)
​
👉🏻 검증 로직 (예: 이메일 형식 확인)
​
👉🏻 에러 메시지 표시
​
👉🏻 제출 핸들러 (onSubmit)
​
👉🏻 서버 통신 (fetch / API)
​
👉🏻 로딩 상태 관리
​
👉🏻 성능 최적화 (불필요한 리렌더링 방지)
​
**(3) SPA 환경에서 Form이 중요한 이유**
​
\- SPA(Single Page Application)에서는 페이지 전체를 새로고침하지 않고 현재 UI 일부만 갱신함
​
\- 즉, 입력값 검증, 에러 표시, 버튼 활성화, 제출 후 처리 등이 모두 클라이언트에서 즉시 이루어져야함
​
\- React Form은 기능을 직접 구현하거나 라이브러리(React Hook Form)를 사용해 관리해야 함
​
👉🏻 입력값 변할 때마다 즉시 상태 갱신
​
👉🏻 실시간 검증
​
👉🏻 제출 중 로딩 표시
​
👉🏻 API 호출 후 성공, 실패 처리
​
👉🏻 에러 메시지 표시
​
👉🏻 입력값 초기화
​
#### **2\. 사용 이유**
​
>  정확한 데이터 수집과 즉시 피드백(유효성, 에러 표시), 접근성(라벨/포커스/키보드), 서버 통신의 일관화 필요
​
\- 입력 UI 전체를 하나의 구조적 단위로 묶고, 데이터 수집부터 검증, 제출까지 예측 가능하고 안정적으로 동작하도록 만들기 위함
​
\- 입력 필드가 늘어나면 개별 상태 관리만으로는 한계가 발생함
​
\- Form은 이런 복잡성을 줄여줌
​
**(1) 정확한 데이터 수집**
​
\- 여러 input을 따로 useState로 관리하면 필드가 늘어날수록 상태, 핸들러가 폭발적으로 증가함
​
\- Form을 사용하면
​
👉🏻 <form>내부의 <input name="..."> 값이 자동으로 하나의 그룹으로 묶음
​
👉🏻 new FormData(e.target) 단 한 줄로 모든 값을 객체처럼 추출 가능
​
\- 즉, 필드 수가 늘어도 제출 로직이 단순해짐
​
**(2) 즉시 피드백 - 유효성 검사 & 에러 메시지**
​
\- Form 구조를 사용하면
​
👉🏻 기본 HTML5 유효성 검사(required, pattern, type=email)를 자동으로 제공
​
👉🏻 React에서는 실시간 검증 로직과 에러 표시를 손쉽게 결합 가능
​
👉🏻 큰 폼에서도 사용자가 즉시 피드백을 받을 수 있음
​
\- 즉, 사용자는 실시간으로 오류를 확인하고, 서버는 검증된 데이터만 받게 됨
​
**(3) 접근성(A11y) 자동 확보**
​
\- Form은 웹 표준에 따라 다음 기능을 자동 제공
​
👉🏻 엔터키로 제출
​
👉🏻 Tab으로 입력칸 이동
​
👉🏻 자동완성 기능
​
👉🏻 label과 input의 연계
​
👉🏻 키보드 사용자, 스크린리더 사용자 접근성 지원
​
\- 따라서 초보자가 집근성 직접 구현 부담을 크게 줄일 수 있음
​
**(4) 성능 최적화가 쉬움**
​
\- 특히 Ref 기반 Form 관리(react-hook-form 등)은 입력할 때마다 리렌더링이 일어나지 않음
​
\- 입력 시 매번 화면이 다시 그려지는 Controlled 방식보다 훨씬 가볍고 빠름
​
\- 대규모 폼에서도 성능이 안정적
​
**(5) 서버 전송 흐름이 일관적이고 안정적**
​
\- Form을 사용하면 제출 프로세스가 명확해짐
​
👉🏻 입력값 수집
​
👉🏻 유효성 검사
​
👉🏻 제출
​
👉🏻 API 통신
​
👉🏻 성공, 실패 처리
​
\- React 앱에서 Form은 UI와 서버 간 데이터 흐름을 표준화해 유지보수성을 높임
​
#### **3\. Form을 사용하면 생기는 직접적인 이점**
​
**(1) 브라우저가 값들을 자동으로 묶어줌**
​
\- FormData로 한 번에 추출 가능
​
\- 필드 수가 많아도 제출 코드가 변하지 않음
​
**(2) 기본 접근성을 무료로 제공**
​
\- 엔터 제출, 자동완성, 필드 그룹화, 포커스 이동 등
​
**(3) 입력마다 리렌더링을 줄여 성능 향상**
​
\- Ref 기반 라이브러리로 입력 시 리렌더링 최소화
​
**(4) 제출 로직과 입력 로직을 하나의 구조로 캡슐화**
​
\- 컴포넌트가 정돈되고 유지보수 쉬워짐
​
> **❓ Ref 기반 Form 관리**  
> \- 입력 중에는 리렌더링을 하지 않고, 제출 시점에만 값 읽기  
> \- 입력할 때도 매우 빠르고, 수십 개의 필드가 있어도 성능 저하가 거의 없음
​
#### **4\. 사용 방법**
​
\- 리렌더를 최소화하고, 필드 단위로 값, 에러를 관리해서 대규모 폼에서도 성능과 예측 가능성을 유지하기 위해 useForm 훅으로 관리
​
**(1) useForm 훅이 하는 역할**
​
> 입력값은 ref에, 화면에 보여야 하는 것(에러, 제출 상태 등)은 state로 관리해서 폼 전체를 빠르게 + 예측 가능하게 동작하게 함
​
\- 내부에서 관리하는 것들
​
👉🏻 valuesRef: 모든 필드의 현재 값 저장 (리렌더 X)
​
👉🏻 rulesRef: 각 필드의 검증 규칙 저장
​
👉🏻 inputsRef: 실제 <input>, <select> 같은 DOM 노드 저장 (reset 시 DOM 직접 제어)
​
👉🏻 errors(state): 화면에 보여줄 에러 메시지 모음
​
👉🏻 isSubmitting(state): 제출 중 여부 (버튼 비활성화 등 UI에 사용)
​
#### **5\. 핵심 API**
​
**(1) register(name, rules)**
​
\-  이 input은 이 이름(name)과 이 규칙(rules)으로 관리해줘라고 폼에 등록하는 함수
​
```
<input {...register("email", {
  required: { message: "이메일은 필수입니다." },
  pattern: { value: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, message: "이메일 형식이 아닙니다." },
})} />
```
​
\- register가 해주는 것
​
👉🏻name 부여
​
👉🏻ref 콜백 부여 -> 커밋 후 실제 DOM을 inputsRef에 저장
​
👉🏻onChange -> 타이핑할 때 valuesRef.current\[name\]에 값 저장 + 필요한 경우 즉시 검증
​
👉🏻onBlur -> 포커스 빠질 때 한 번 더 검사
​
👉🏻초기값이 있다면 defaultValue, defaultChecked 세팅
​
\- 결과적으로, input 태그 하나만 써도 값 저장 + 검증 + DOM 초기화까지 자동 처리됨
​
**(2) setValue(name, value, {shouldValidate })**
​
\- 내부 값(ref)만 바꾸거나, 값 바꾸면서 바로 검증까지 하고 싶을 때 사용
​
👉🏻 valuesRef.current\[name\] = value 로 저장 (리렌더 X)
​
👉🏻 shouldValidate: true면  
→ validateField로 검사 후 errors state 업데이트  
→ 해당 필드 에러 UI만 리렌더
​
**(3) getValues()**
​
\- 현재 폼의 값 전체를 객체로 받고 싶을 때
​
```
const values = getValues(); // { email: "...", password: "...", ... }
```
​
**(4) reset(nextValues?)**
​
\- 폼 전체를 초기 상태(또는 지정한 값)로 리셋
​
👉🏻 valuesRef.current = {...nextValues} 로 내부 값 갈아끼우고
​
👉🏻errors 초기화
​
👉🏻 inputsRef에서 실제 DOM 을 돌면서:
​
-   checkbox → checked 조정
-   radio → 선택된 것만 checked = true
-   select multiple → selected 옵션 맞춰줌
-   일반 input → el.value = 값
​
\- 그래서 상태 + 화면이 동시에 초기화됨
​
**(5) handleSubmit(onValid, onInvalid)**
​
\- 폼 제출 이벤트 래퍼
​
\- 전체 검증 -> 성공/실패 콜백 호출 흐름을 캡슐화
​
\- 동작 순서
​
👉🏻 e.preventDefault()로 기본 제출 막기
​
👉🏻 validateAll()로 모든 필드 검사
​
👉🏻 에러 있으면  
→ onInvalid(errors, { values }) 호출
​
👉🏻 에러 없으면  
→ isSubmitting = true  
→ onValid(values, { reset, setValue, getValues }) 호출  
→ 끝나면 isSubmitting = false
​
#### **6\. 검증 로직 validateField(value, rules)**
​
> 한 필드에 대해 첫 번째로 걸리는 규칙의 에러 메시지 반환
​
\- 지원하는 규칙
​
👉🏻  required: 비어있거나 공백뿐이면 에러
​
👉🏻  minLength / maxLength
​
👉🏻 pattern: 정규식 테스트
​
👉🏻 validate: 사용자 정의 함수, true면 통과, 문자열이면 그게 에러메시지
​
```
const msg = validateField(value, {
  required: { message: "필수 입력입니다." },
  minLength: { value: 3, message: "3자 이상" },
  validate: v => v.endsWith(".com") || ".com만 허용",
});
```
​
#### **7\. 왜 ref + state(error) 구조를 쓰는가?**
​
\- useState로 모든 필드 값을 관리하면
​
👉🏻 입력할 때마다 리렌더 -> 필드가 많으면 버벅임
​
\- useRef로 값만 담아두면
​
👉🏻 값이 바뀌어도 리렌더 X -> 입력감이 부드러움
​
\- 대신, 화면에 진짜 보여야 하는 것만 state로
​
👉🏻 에러 메시지
​
👉🏻 제출 중 상태 등
​
\- 눈에 보여야 하는 것만 렌더링 비용 지불
​
#### **8\. 실제 입력~제출 타임라인 (짧게)**
​
\- 이메일 한 글자 입력 -> blur -> 제출 버튼 클릭 순서라면
​
**(1) 입력**
​
\- 브라우저가 input value 바꿈
​
\- onChange → setValue("email", "a", { shouldValidate: true })
​
\- valuesRef 갱신, 필요하면 errors만 업데이트(해당 필드 에러만 리렌더)
​
**(2) blur**
​
\- onBlur → 마지막 한 번 더 검사 → errors.email 업데이트
​
**(3) 제출**
​
\- handleSubmit → preventDefault()
​
\- validateAll() → 전체 검사
​
\- 에러 있으면 onInvalid(errors)
​
\- 없으면 onValid(values, { reset }) 호출
​
\- 서버 성공 시 reset()으로 전체 초기화
​
> **한줄 정리**  
> \- 우리가 만든 useForm은  
> 입력값은 ref로 조용히 모으고,  
> 화면에는 에러/제출 상태만 state로 노출해서  
> 성능좋은 폼 + 예측 가능한 검증/제출 흐름을 만드는 커스텀 훅
​
---
​
### **3️⃣ Fetch**
​
#### **1\. 정의**
​
\- 웹 브라우저, Node 환경에서 HTTP 요청을 보내고 응답을 받는 표준 API
​
\- React에서는 주로 클라이언트나 서버 컴포넌트에서 데이터를 가져올 때 사용됨
​
#### **2\. 사용 이유**
​
\- 외부 서버와 통신하여 UI에 필요한 데이터를 가져오고, 비동기적으로 상태를 업데이트하기 위해 필요
​
**(1) 서버와 데이터 통신을 위한 표준 도구**
​
\- 웹 앱은 대부분의 데이터를 서버에서 가져와야 함
​
👉🏻 쇼핑몰 -> 상품 목록
​
👉🏻 블로그 -> 글 목록
​
👉🏻 SNS -> 피드, 댓글
​
\- 이 모든 작업을 가장 단순하고 표준화된 방식으로 처리하는 도구가 fetch
​
**(2) XHR보다 단순하고 React와 잘 맞는 Promise 기반 API**
​
\- 과거에는 XMLHttpRequest(XHR)을 썼지만
​
👉🏻 콜백 지옥
​
👉🏻 에러 처리 불편
​
👉🏻 코드가 지저분해짐
​
\- 반면 fetch는
​
👉🏻 Promise 기반
​
👉🏻 async/await와 자연스럽게 사용
​
👉🏻 에러 처리 방식도 일관적
​
**(3) 비동기 데이터로 UI 자연스럽게 업데이트**
​
\- 리액트에서는 서버 응답을 state에 저장하고 화면을 부드럽게 갱신 가능
​
```
useEffect(() => {
  fetch("/api/products")
    .then(res => res.json())
    .then(setProducts);
}, []);
```
​
\- 사용자는
​
👉🏻 새로고침 -> 전체 화면 깜빡임 대신
​
👉🏻 UI 뼈대 먼저 -> 데이터 채워짐 경험함 -> 체감 속도가 빠름
​
**(4) 요청 취소 기능(AbortController)로 안전한 네트워크 관리**
​
\- 컴포넌트가 사라졌는데 요청이 남아 있으면
​
👉🏻 메모리 낭비, React 경고 발생
​
\- fetch는 AbortController로 요청을 안전하게 취소 가능
​
```
useEffect(() => {
  const controller = new AbortController();
​
  fetch("/api/products", { signal: controller.signal });
​
  return () => controller.abort();
}, []);
```
​
> **❓ AbortController**  
> \- 요청에 연결된 signal을 중단해서 (fetch내부에서 바로 감지) 네트워크 요청을 즉시 취소하는 기술
​
**(5) 캐시 정책을 제어해 성능 최적화**
​
\- fetch는 캐시 정책을 직접 제어할 수 있음
​
> **❓ 캐시**  
> \- 이미 받은 데이터를 저장해두었다가, 같은 요청이 오면 꺼내주는 저장소
​
\- 네트워크 비용을 줄이고 속도를 높임
​
> **요약**  
> \- Fetch는 서버와 데이터를 주고받기 위한 현대적 표준 API  
> \- 비동기적으로 데이터를 불러와 React의 상태에 반영해 UI를 부드럽게 갱신하고,  
> \- XHR보다 코드는 단순해지고, AbortController와 캐시 정책으로 안전성과 성능 챙길 수 있음
​
#### **3\. 사용 방법**
​
\- fetch(url, optional)로 요청 보내고 await response.json()으로 응답 처리
​
**(1) 기본 사용 패턴**
​
\- 요청 -> 응답(JSON 변환) -> 상태 업데이트 -> 화면 갱신
​
\- React에서는 이를 보통 useEffect와 useState로 처리함
​
```
useEffect(() => {
  fetch("/api/products")
    .then(res => res.json())
    .then(json => setData(json))
    .catch(err => console.error(err));
}, []);
```
​
**(2) 로딩/성공/실패 상태 관리**
​
\- 사용자에게 현재 상태를 알려주기 위해 로딩/에러/데이터를 함께 관리함
​
```
const [state, setState] = useState({
  loading: false,
  error: null,
  data: null,
});
```
​
\- 요청 과정
​
👉🏻 요청 시작 -> loading: true
​
👉🏻 응답 성공 -> data 업데이트
​
👉🏻 응답 실패 -> error 업데이트
​
**(3) res.ok 체크가 필요한 이유**
​
\- fetch는 HTTP 오류 (404/500)가 있어도 네트워크 요청이 성공했기만 하 Promise를 reject하지 않음
​
\- 그래서 반드시 확인해야 함
​
```
if (!res.ok) throw new Error(`HTTP ${res.status}`);
```
​
**(4) 컴포넌트가 사라질 때 요청 취소하기 - AbortController**
​
\- 화면 전환 후에도 요청이 남아 있으면 메모리 낭비 & 경고 발생
​
\- 그래서 언마운트 시 요청 취소
​
```
const controller = new AbortController();
​
fetch(url, { signal: controller.signal });
​
return () => controller.abort();
```
​
**(5) 캐시 옵션으로 최신성/성능 제어**
​
\- 항상 최신 데이터가 필요할 때
​
```
fetch("/api/products", { cache: "no-store" });
```
​
\- 기본 (브라우저 캐시 사용)
​
```
fetch("/api/products");
```
​
**(6) JSON 파싱 실패 대비**
​
\- 서버가 JSOM이 아닌 응답을 주면 .json()이 에러를 던짐
​
\- 안정적으로 처리하려면 try/catch로 감쌈
​
```
async function safeJson(res) {
  try {
    return await res.json();
  } catch {
    throw new Error("JSON 파싱 실패");
  }
}
```
​
**(7) 일정 간격으로 자동 재조회 (폴링)**
​
\- 실시간처럼 보여야 할 때 사용할 수 있는 패턴
​
```
setInterval(run, 5000);
```
​
\- 언마운트 시에는
​
👉🏻 clearInterval(timer)
​
👉🏻 controller.abort()
​
를 반드시 해줘야 메모리 누수 없음
​
**(8) Fetch에 타임아웃 걸기**
​
\- fetch는 기본 타임아웃이 없어서 직접 구현함
​
```
const controller = new AbortController();
setTimeout(() => controller.abort(), 3000);
​
fetch(url, { signal: controller.signal });
```
​
**(9) 재사용을 위한 커스텀 훅 패턴**
​
\- 매 화면에서 Fetch 로직 반복할 필요 없이 공통 패턴을 useFetch로 만들면 깔끔해짐
​
```
const { loading, error, data } = useFetch("/api/users?page=1", {
  deps: [page],
  options: { cache: "no-store" },
});
```
​
> **요약**  
> \- Fetch는 서버와 데이터를 주고받는 가장 기본적이고 강력한 도구  
> \- React에서는 비동기 데이터를 받아 UI를 자연스럽게 갱신하는 핵심 기능
​
> **Fetch 사용 시 핵심 포인트**  
> 1\. 요청 -> JSON 변환 -> 상태 업데이트 기본 흐름 이해  
> 2\. 로딩, 에러, 데이터 상태를 반드시 함께 관리하기  
> 3\. res.ok 체크로 HTTP 오류 잡기  
> 4\. AbortController로 컴포넌트 언마운트 처리하기  
> 5\. 캐시 정책 제어해 최신성/성능 조절하기  
> 6\. JSON 파싱 예외 대비  
> 7\. 폴링/타임아웃 구현 가능  
> 8\. 로직이 반복되면 커스텀 훅으로 분리하기
