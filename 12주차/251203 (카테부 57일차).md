​
## **🧠 회고**
​
오늘은 CSR, SSR, Portal을 배우면서 “브라우저가 화면을 어떻게 만들고, 어떤 방식으로 사용자에게 더 좋은 경험을 줄 수 있는가”를 깊이 이해한 하루였다. CSR은 클라이언트에서 모든 렌더링을 처리해 인터랙션은 빠르지만 초기 로딩이 느릴 수 있다는 점을 알았고, SSR은 서버에서 HTML을 먼저 만들어 보내기 때문에 초기 화면이 즉시 보이고 SEO에 유리하다는 장점을 배웠다. 그리고 Portal을 통해 “DOM 트리 구조와 별개로 특정 요소를 원하는 위치에 렌더링할 수 있다”는 개념을 이해하면서 모달, 드롭다운처럼 UI 계층 구조가 복잡한 컴포넌트들을 더 깔끔하게 구현할 수 있다는 걸 깨달았다.
​
## **🪽 오늘의 다짐**
​
화면을 그리는 방식(CSR/SSR)과 UI 구조를 다루는 방식(Portal)을 상황에 맞게 선택할 줄 아는 개발자가 되기 위해, 앞으로 페이지를 설계할 때 사용자 경험·초기 로딩·SEO·UI 구조를 함께 고려하는 사고를 꾸준히 연습하자.
​
---
​
## **📝 Today I Learned**
​
### **1️⃣  CSR**
​
#### **1\. 정의**
​
\- Client-Side Rendering
​
\- 웹 페이지의 UI를 브라우저(클라이언트)에서 JS로 직접 렌더링하는 방식
​
\- 서버는 데이터만 보내고, 화면을 그리는 일은 브라우저가 담당
​
#### **2\. 사용 이유**
​
\- 사용자의 경험을 향상시키고, 동적인 페이지 상호작용을 원할하게 하기 때문
​
**(1) 빠른 페이지 전환과 앱 같은 경험**
​
\- 한 번 스크립트를 받아오면 그 이후에는 서버에서 전체 페이지를 다시 내려받지 않아도 되므로, 화면 전환이 앱처럼 부드럽고 끊김 없이 이뤄짐
​
**(2) 즉각적인 상호작용**
​
\- 버튼 클릭, 검색 필터, 모달 같은 동작을 브라우저 안의 자바스크립트가 직접 처리하기 때문에, 서버 왕복 없이 즉시 반응함
​
**(3) 유연한 UI 조작, 맞춤화**
​
\- 로그인 상태, 사용자 설정, 위치, 뷰포트 크기 등 클라이언트의 문맥 정보를 활용해 서버를 거치지 않고도 다양한 UI/UX를 동적으로 조작 가능
​
**(4) 서버 부하 감소**
​
\- 초기 HTML/JS를 내려준 뒤에는 API 요청만으로 데이터만 전달받으면 됨
​
\- 서버가 매 요청마다 페이지 전체를 렌더링하지 않아도 되어 부하 분산 가능
​
**(5) 풍부한 프론트엔드 생태계 활용**
​
\- 브라우저에서 직접 그림
​
👉🏻 다양한 프론트엔드 라이브러리, 상태관리, 라우팅을 자유롭게 붙여 복잡한 UI도 클라이언트 단에서 구현 가능
​
#### **3\. 동작 방식**
​
\- HTML 틀 + JS 파일만 먼저 받고, 이후 화면 구성은 브라우저가 직접하는 방식
​
**(1) 사용자가 주소 입력**
​
\- 브라우저가 서버에 '첫 화면 주세요'하고 요청 보냄
​
**(2) 서버가 HTML 틀 + React JS 파일 전달**
​
\- 내용은 거의 없고, 빈 구조(HTML)와 React 실행 파일(JS)만 내려옴
​
**(3) 브라우저가 HTML을 읽고 기본 UI 구성**
​
\- DOM 뼈대를 만들고, CSS 적용
​
**(4) React 스크립트 실행 -> 앱 부팅**
​
\- JS가 실행되면서 React 앱이 메모리에서 만들어지고, 이벤트 리스너도 연결됨
​
**(5) 브라우저가 서버에 데이터 요청 (API 통신)**
​
\- 상품 목록 주세요, 유저 정보 주세요 같은 필요한 데이터만 비동기로 요청
​
**(6) 데이터 수신 -> 화면 내용 채우기**
​
\- React가 상태를 갱신하고 바뀐 부분만 다시 렌더링해서 UI 구성
​
**(7) 사용자 행동(클릭/입력)에 즉시 반응**
​
\- 이미 이벤트 리스너가 클라이언트에 있으므로 페이지 새로고침 없이 즉각 반응
​
**(8) 페이지 이동도 전체 리로드 없이 처리**
​
\- React Router가 history API를 사용해 URL만 바꾸고, 필요한 데이터만 다시 요청해 UI 교체
​
**(9) 재방문 시 캐시 덕분에 더 빨라짐**
​
\- JS/CSS 파일을 브라우저가 캐시해 다음 방문 속도가 빨라짐
​
**(10) 로딩, 오류 UI까지 브라우저가 제어**
​
\- 로딩 스피너, 에러 메시지, 재시도 버튼 등도 클라이언트에서 관리
​
> **정리**  
> \- CSR: 처음엔 빈 화면 + JS만 받고, 나머지 화면은 브라우저가 데이터 가져와 직접 만드는 렌더링 방식  
> \- 필요한 데이터만 부분적으로 요청하고, 화면을 끊김없이 바꿀 수 있음  
> \- React같은 SPA가 빠르고 부드럽게 느껴지는 이유임
​
---
​
### **2️⃣  SSR**
​
#### **1\. 정의**
​
\- Server-Side Rendering
​
\- React 서버가 사용자 요청 시 필요한 데이터를 미리 가져와 HTML을 만들어 내려보냄
​
\- 브라우저는 그 HTML을 먼저 그린 뒤 React 스크립트가 이벤트와 상태를 주입해 완전한 앱으로 만드는 방식
​
#### **2\. 사용 이유**
​
\- 초기 로딩 속도와 SEO(검색 엔진 최적화)를 개선
​
\- 빈 화면 대신 즉시 보이는 HTML을 제공해 사용자 경험을 향상시키기 위함
​
**(1) 초기 표시 속도 (FCP/LCP) 개선**
​
\- 서버가 데이터를 가져와 HTML을 만든 뒤 보내기 때문에 사용자는 화면이 빠르게 뜬다고 느낌
​
👉🏻 CSR: 처음엔 빈화면 -> JS 다운로드 -> JS 실행 -> 데이터 fetch -> 그제야 내용 보임
​
👉🏻 SSR: 서버가 내용을 넣어서 HTML을 보내므로 -> 사용자는 바로 실제 콘텐츠 확인 가능
​
> **❓ FCP**  
> \- First Contentful Paint  
> \- 화면에 첫 글자, 이미지 등이 보이는 시점
​
> **❓ LCP**  
> \- 화면에서 가장 큰 요소(히어로 이미지, 제목 등)가 완전히 보이는 시점
​
**(2) SEO(검색 엔진 최적화)에 강함 - 구글/네이버에 잘 노출됨**
​
\- 검색 엔진 크롤러는 HTML을 읽어야 페이지 내용을 파악 가능
​
\- CSR  
👉🏻 JS 실행 후에야 화면 내용이 만들어짐
​
👉🏻 일부 검색 엔진은 내용을 제대로 못읽는 경우 있음
​
\- SSR  
👉🏻 HTML에 이미 완성된 콘텐츠가 들어있음
​
👉🏻 크롤러가 그대로 읽을 수 있으므로 검색 최적화가 훨씬 잘 됨
​
> **❓ SEO**  
> \- Search Engine Optimization  
> \- 내 페이지가 구글, 네이버 등 검색 엔진에서 더 잘보이도록 최적화하는 작업
​
**(3) SNS 공유(OG/Twitter Card)에서 안정적인 미리보기 제공**
​
\- 카카오톡, 페이스북, 트위터 등은 공유된 URL의 HTML에 적힌 OG(Open Graph) 정보를 읽어서 미리보기 카드 생성
​
\- CSR 페이지
​
👉🏻 JS 실행 전에는 OG태그가 비어 있을 가능성이 있음
​
\- SSR 
​
👉🏻 서버가 완선된 HTML을 보내므로 공유 카드가 깨지지 않음
​
**(4) 저사양 기기, 저속 네트워크에서도 좋은 UX**
​
\- 스마트폰 성능이 낮거나 3G 환경에서는 JS 실행이 매우 느림
​
\- CSR  
👉🏻 JS를 다운로드하고, 해석하고, 실행해야 화면 보임
​
👉🏻 저사양 환경에서 매우 느림
​
\- SSR
​
👉🏻 서버에서 이미 만든 HTML을 즉시 전달
​
👉🏻 JS 없이도 콘텐츠 보이므로 UX 안정적
​
**(5) 캐싱이 매우 유리함**
​
\- HTML 자체를 서버나 Edge(전 세계에 분산된 CDN 서버)에 캐싱할 수 있음
​
👉🏻 재방문자에게 매우 빠른 응답 제공
​
👉🏻 트래픽 절감
​
👉🏻 부하 감소
​
\- CSR은 API 결과를 따로 캐싱해야해서 구조 복잡
​
**(6) 콘텐츠 신뢰도 및 접근성 높아짐**
​
\- JS가 잠시 실패해도 SSR 페이지는 기본 내용이 HTML에 포함되어 있기 때문에 사용자는 아무것도 보이지 않는 상태 겪지 않음
​
\- CSR 치명적 문제
​
👉🏻 JS 오류 -> 화면 전체가 빈 화면
​
👉🏻 SSR은 JS 오류가 있어도 최소한 기본 텍스트 콘텐츠는 보임
​
\- 접근성 측면에서도 안정적
​
> SSR은 화면을 빠르게 보여주고(초기 렌더링 개선),  
> 검색 엔진이 읽기 쉽고(SEO),  
> 저성능 환경에서도 안정적인 사용자 경험을 주는 방식
​
#### **3\. 동작 방식**
​
\- 사용자가 웹 사이트에 접속할 때 서버에서 데이터를 포함한 HTML을 미리 렌더링하여 내려 줌
​
\- 브라우저가 이를 먼저 그린 뒤 React 스크립트를 실행해 이벤트와 상태를 붙여 앱으로 완성함
​
**(1) 사용자가 URL 입력**
​
\- 브라우저가 서버에 요청
​
**(2) 서버가 데이터까지 포함된 HTML 생성**
​
\- 서버에서 필요한 API 요청 -> React 컴포넌트 렌더링 -> 완성된 HTML 생성
​
👉🏻 사용자에게 바로 보여줄 수 있는 상태로 내려보냄
​
**(3) 브라우저는 HTML을 먼저 그림**
​
\- 도착한 HTML을 바로 렌더링해서 즉시 페이지 내용이 보임
​
\- 아직 버튼을 눌러도 동작하지 않을 수 있지만, 빈화면은 아님
​
**(4) React 스크립트 다운로드 + 실행 준비**
​
\- 브라우저가 React.js 번들을 다운로드하고 실행할 준비를 함
​
\- HTML은 보이지만, 앱은 아직 작동 전 상태
​
**(5) Hydration(하이드레이션) 시작**
​
\- React가 브라우저에 있는 HTML을 읽고
​
👉🏻 이벤트 연결(클릭, 입력 등)
​
👉🏻 내부 상태 초기화
​
👉🏻 컴포넌트 구조와 동기화
​
**(6) 앱 완성 - 버튼, 입력, 라우팅 모두 정상 동작**
​
\- Hydration 완료 후에는 CSR과 완전히 동일한 인터랙티브 앱이 됨
​
\- 부분 렌더링, 상태 업데이트도 자연스럽게 진행됨
​
**(7) 추가 데이터 요청 / 페이지 전환**
​
\- 페이지 이동 시 서버가 새 HTML을 렌더링해 보내줄 수도 있고,
​
\- 클라이언트 라우터로 CSR처럼 전환할 수도 있음
​
\- React 19는 Streaming SSR / Selective Hydration으로 더 빠른 초기 경험 제공
​
> **❓ Streaming SSR**  
> \- HTML 전체를 다 만들 때까지 기다리지 않고, 준비된 부분부터 조금씩 브라우저로 흘려보내는 기술  
> \- 화면이 더 빨리 뜸
​
> **❓ Selective Hydration**  
> \- 화면 전체가 아니라 사용자가 지금 보고 필요한 부분부터 React 기능을 붙이는 방식  
> 👉🏻 초기 성능 향상
​
**(8) SEO, 초기 로딩에 유리**
​
\- 검색 엔진이 HTML을 바로 읽을 수 있어 SEO가 강함
​
\- 사용자도 스켈레톤 대신 진짜 콘텐츠를 바로 보게 됨
​
**(9) 캐싱, 재방문 시 더 빠름**
​
\- HTML 자체를 CDN/브라우저 캐시에 저장 가능
​
\- JS도 캐시에 저장 
​
👉🏻 재방문 성능 좋음
​
👉🏻 CSR보다 캐싱 전략이 확실하고 단순함
​
> SSR은 서버에서 미리 HTML을 완성해 보내 빠르게 화면을 띄우고,  
> 브라우저는 그것을 기반으로 React를 붙여 작동시키는 방식
​
---
​
### **3️⃣  Portal**
​
#### **1\. 정의**
​
> React에서 자식 컴포넌트를 부모의 트리는 유지한 채 DOM의 다른 컨테이너에 렌더링하는 기능
​
\- 컴포넌트 트리는 그대로 두고 DOM만 다른 곳으로 옮겨 렌더링할 수 있게 해주는 통로
​
\- 보통 모달, 툴팁, 드롭다운처럼 부모 요소의 스타일 제약(overflow, z-index)을 받지 않도록 별도 컨테이너(#modal-root)에 UI를 그릴 때 사용함
​
\- 즉, react안에서는 상태와 이벤트 버블링은 원래 부모를 따라가지만, 실제 DOM 위치만 원하는 컨테이너로 이동시키는 메커니즘
​
#### **2\. 사용 이유**
​
\- 모달, 툴팁, 드롭다운처럼 부모의 overflow, z-index 제약을 받지 않도록 별도 루트에 UI를 렌더링하기 위함
​
**(1) 부모 요소의 제약(overflow, z-index)에서 벗어나기 위함**
​
\- 모달, 드롭다운, 툴팁은 화면 위에 떠야 하는데,
​
👉🏻 부모 요소에 overflow: hidden
​
👉🏻 부모에 position: relative
​
👉🏻 부모에 transform
​
\- 이런 것들이 걸려 있으면 UI가 잘리거나 z-index로도 위에 못 올라오는 문제가 생김
​
\- Portal은 이런 UI를 <body> 아래로 옮겨 그리므로 항상 정상적으로 떠 있는 레이어를 만들 수 있음
​
**(2) DOM 위치만 바뀌고, React 상태, 이벤트는 그대로 유지됨**
​
\- Portal의 장점
​
👉🏻 UI는 body 아래에서 렌더됨 (DOM 분리)
​
👉🏻 하지만 React 트리 구조는 그대로 유지됨
​
👉🏻 Context, 상태 공유, 이벤트 버블링도 전부 정상 작동
​
\- 즉, 화면에서는 분리되어 있지만, React 입장에서는 같은 컴포넌트 구조
​
**(3) 모달/팝업 접근성 구현이 더 쉬움**
​
\- 접근성을 지키려면 모달은 DOM 최상단 근처에 있어야 함
​
\- Portal을 쓰면 다음을 쉽게 구현 가능
​
👉🏻 포커스 트랩 (모달 안에서 포커스 갇히기)
​
👉🏻 ESC 눌러 닫기
​
👉🏻 스크린 리더가 올바른 순서로 읽기
​
👉🏻 배경 스크롤 막기
​
**(4) 전역 UI 레이어 관리가 간단함**
​
\- 애플리케이션이 커지면 공통 레이어들이 많아짐
​
👉🏻 토스트, 알림, 컨텍스트 메뉴, 드래그 미리보기, 여러 모달
​
👉🏻 각 컴포넌트 안에 박아두면 구조가 복잡해지고 충돌이 생김
​
\- Portal을 쓰면 전역 루트를 하나 만들어 깔끔하게 관리 가능
​
```
<body>
  <div id="root"></div>
  <div id="modal-root"></div>
  <div id="toast-root"></div>
</body>
```
​
\- UI 레이어가 정리되고 유지보수가 좋아짐
​
**(5) CSS position: fixed의 한계를 피할 수 있음**
​
\- 부모 요소에 transtorm, filter, perspective 등이 걸려 있으면 fixed가 fixed가 아니게 됨 (부모 기준으로 잡힘)
​
\- portal은 이런 문제를 근본적으로 해결함
​
👉🏻 부모 CSS 영향에서 완전히 자유로움
​
**(6) 동적으로 여러 레이어를 띄우기 쉬움**
​
\- 여러 개 모달을 동시에 띄우기
​
\- 툴팁이 여러 컴포넌트에서 생성되기
​
\- 조건에 따라 여러 팝업을 렌더링하기
​
\- Portal은 DOM 어디에 있든 관계 없이 React 트리만 맞으면 되므로 동적 생성/삭제가 매우 쉬움
​
**(7) 성능과 UX의 일관성을 유지하기 좋음**
​
\- Portal로 모든 오버레이 UI를 같은 DOM 위치에 렌더하면
​
👉🏻 DOM 구조가 단순하고 평평해져 렌더 비용 감소
​
👉🏻 z-index 충돌이 줄어듦
​
👉🏻 사용자 경험이 일관됨 (모달이 항상 같은 위치에서 뜸)
​
> **요약**  
> Portal은 DOM 위치는 따로 두되 React 트리와 상태는 유지하여, 복잡한 UI(모달/툴팁/드롭다운)를 부모의 CSS 제약 없이 안전하게 렌더링하기 위한 기술
​
#### **3\. 사용 방법**
​
\- HTML에 <div id="modal-root" />를 추가하고, 컴포넌트에서 createPortal(<요소/>, modalRoot) 형태로 렌더링
​
**(1) HTML에 Portal 전용 컨테이너 만들기**
​
\- public/index.html
​
```
<body>
  <div id="root"></div>
  <div id="modal-root"></div> <!-- Portal이 렌더링될 위치 -->
</body>
```
​
\- 여기로 모달, 툴팁, 드롭다운 렌더링
​
👉🏻 부모 요소의 overflow, z-index 같은 CSS 제약 받지 않게 됨
​
**(2) createPortal로 특정 DOM에 렌더링하기**
​
```
import { createPortal } from "react-dom";
​
export default function App() {
  const modalRoot = document.getElementById("modal-root");
​
  return (
    <>
      <h1>일반 UI</h1>
      {createPortal(
        <p>나는 modal-root에 렌더링되는 Portal 요소!</p>,
        modalRoot
      )}
    </>
  );
}
```
​
\- JSX는 APP 안에 적었지만
​
\- 실제 DOM은 #modal-root 아래에 렌더링 됨
​
\- 이벤트 버블링, Context, 상태는 정상적으로 연결됨
​
**(3) 모달 컴포넌트에서 Portal 사용하기**
​
\- Portal을 제일 많이 사용하는 예: 모달
​
```
import { createPortal } from "react-dom";
import "./modal.css";
​
export default function Modal({ open, onClose, title, children }) {
  if (!open) return null;
​
  const modalRoot = document.getElementById("modal-root");
​
  const overlay = (
    <div className="modal-overlay" onClick={onClose}>
      <div
        className="modal-panel"
        onClick={(e) => e.stopPropagation()} // 내부 클릭은 닫기 금지
      >
        {title && <h2>{title}</h2>}
        {children}
        <button onClick={onClose}>닫기</button>
      </div>
    </div>
  );
​
  return createPortal(overlay, modalRoot);
}
```
​
**(4) 필요한 부가 기능도 쉽게 적용 가능**
​
\- ESC 키로 닫기
​
\- 배경 스크롤 잠금
​
\- role="dialog" + aria-modal = "true"로 접근성 강화
​
\- overlay 클릭 시 닫기 + 내부 클릭은 유지
​
\- Portal은 DOM 위치만 바꾸고 React 상태, Context는 그대로 유지되므로 모달 UX를 구현하기 아주 쉬워짐
​
> **요약**  
> Portal은 React 컴포넌트는 그대로 유지하되, DOM만 별도 위치에 렌더링해 모달, 툴팁, 드롭다운 같은 UI를 CSS 제약 없이 안정적으로 띄우기 위한 기능
