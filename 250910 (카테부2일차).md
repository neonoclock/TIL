# 🧠 회고
오늘은 JVM에 대해 더 심화적으로 학습하였다.
배우면 배울수록 정말 많이 부족하다는 점과 그렇기에 더욱 노력해야겠다는 다짐을 하게 된다... 파이팅

# 💪🏻 오늘의 다짐
1. 꾸준히 복습하기
2. 완전히 이해하고 넘어가기
3. 하루 루틴 정하고 지키기
4. 검색할 때 공식 문서 활용 잘하기
5. 식곤증 이겨내기 (... 저녁에 마라샹궈먹고 혈당스파이크 맞고 낮?밤?잠을 자버렸다)

<br/><br/>
<br/><br/>

# 📝 Today I Learned
## JVM (Java Virtual Machine)
### 1. 정의
- 자바 바이트코드를 실행하는 가상 머신
- 자바 프로그램이 운영체제에 관계없이 동일하게 동작할 수 있도록 해주는 핵심 실행 엔진
- 자바 소스 코드 -> 컴파일 과정 -> 바이트 코드 (.class)
   => 바이트 코드는 사람이 직접 읽을 수 없고, 운영체제도 직접 실행 불가능
   => JVM이 바이트 코드 해석 or JIT 컴파일을 통해 실행 가능한 형태로 바꿔줌
   => 동일한 .class 파일을 어떤 환경에서도 실행 가능!
  
```
❓ JIT (Just-In-Time) 컴파일
자바 바이트 코드를 프로그램 실행 도중에 실시간으로 기계어로 변환해 실행 성능을 높이는 기술

1. 처음에는 바이트코드를 해석하며 실행
2. 자주 실행되는 코드 감지
3. JIT 컴파일러가 해당 부분을 기계어로 바꿔 캐싱
4. 이후에는 해석 없이 바로 기계어로 실행
5. 성능 향상
=> 인터프리터 방식의 유연성과 컴파일 방식의 속도를 절충한 실행 방식
```
❓ 캐싱
자주 사용하는 데이터를 미리 저장해 두어 빠르게 접근할 수 있도록 하는 기술
```

<br/><br/>
<br/><br/>


## 2. 사용 이유 (WHY?)
- 자바 애플리케이션을 운영체제와 무관하게 동일하게 실행 가능
- 각 운영체제별로 제공되는 별도의 구현체 위에서 바이트코드 해석하거나 컴파일하여 실행
   => 소스 코드 수정 없이 다양한 환경에서 동일한 프로그램 실행 가능
- 메모리 관리, 예외 처리, 보안, JIT 최적화 등 여러 실행 환경 기능 제공
   => 안정적인 프로그램 구동 지원

```
❓ 구현체
어떤 설계도(인터페이스 or 추상 클래스)를 실제로 동작하게 만든 쿠체적인 코드나 클래스
```
```
❓ 클래스
객체를 만들기 위한 속성과 메서드를 정의한 설계도
```

<br/><br/>
<br/><br/>


## 3. 동작 방식
- 자바: 전통적인 컴파일 언어(C, C++)와 인터프리터 언어(JavaScrpt, Python)의 장점을 모두 합친 방식
- 자바 코드: 컴파일 -> 바이트 코드 생성 -> JVM 실행
   => JVM: 바이트 코드 해석 + 실행 / 프로그램이 안전하고 운영체제에 상관없이 실행되도록 제어

```
❓ 컴파일 언어
- 코드를 한 번에 기계어로 변환(컴파일) 한 후 실행
- 실행 속도 빠름, 오류 사전에 잡힘
- C, C++
```
```
❓ 인터프리터 언어
- 코드를 한 줄씩 해석 -> 즉시 실행
- 실행 속도 느리지만 수정과 테스트 빠름
- Javascript, Python
```
```
❓ 자바
- 인터프리터 언어의 장점과 컴파일 언어의 장점 결합
- 바이트코드로 컴파일 -> JVM이 이를 해석하거나 JIT 컴파일로 실행
```


** (1) 자바 소스 코드 작성 (.java) **
- 개발자가 일반적 텍스트 형식의 .java 파일로 자바 소스 코드 작성



** (2) 컴파일 단계 (.java 사용) **
- 작성된 소스코드는 javac 명령어를 통해 컴파일
   => 바이트코드 생성 



** (3) 클래스 로딩 (Class Loader) **
- JVM은 클래스 로더를 사용해 실행 시점에 필요한 .class 파일 읽어 들임
-> 클래스 구조 정보를 런타임 데이터 영역 중 하나인 메서드 영역에 로드
  => WHY?
       클래스 정보를 효율적으로 관리하고 재사용하기 위해
- 이 과정은 동적으로 이루어짐: 프로그램 실행 중에 어떤 작업이 수행됨
- 지연 로딩 방식: 필요할 때만 클래스를 메모리에 올림

```
❓ 메서드 영역
JVM 내부 메모리 중 클래스 정보가 저장되는 공간
- 클래스 이름, 메서드 이름 등 저장
- 프로그램 실행 중 클래스가 로딩되면 이 영역에 배치
```
```
❓ 지연 로딩
필요할 때만 리소스를 메모리에 올림
=> 실행 속도 개선, 성능 최적화
```
```
❓ 동적
프로그램 실행 중에 필요한 작업이 이루어지는 것
```


<Class Loader>
클래스 로더를 사용해 클래스 파일을 로딩 (3단계)

a. 로딩(Loading)
- 외부 저장소(파일 시스템, JAR 파일 등)에서 .class 파일을 찾아 읽음
- 해당 클래스 정보를 JVM 메모리의 메서드 영역에 올림
- 해당 클래스 JVM이 인식 가능해짐



b. 링킹 (Linking)
- 로딩된 클래스가 실제로 사용되기 전, 해당 클래스가 올바르게 정의되어 있는지 확인 후 실행에 필요한 준비 작업 수행
- 준비 과정

검증 (Verifying)
클래스 파일의 구조가 JVM 명세에 맞게 정확히 작성되었는지 검사
잘못된 명령어 사용, 접근 제한 위반, 타입 불일치 확인
보안, 안정성

준비 (Preparing)
클래스에 정의된 static 변수들을 위한 메모리를 JVM이 확보
static 변수들은 기본값(숫자는 0, 참조형은 null 등)으로 초기화
아직 실제 값이 설정되는 단계는 아님

해결 (Resolving)
클래스 내부에서 참조하고 있는 다른 클래스, 메서드, 필드 등에 대해 심볼릭 레퍼런스를 다이렉트 레퍼런스로 바꿔줌
"누구를 참조하는가"를 실행 가능한 방식으로 연결

```
❓ 심볼릭 레퍼런스 (Symbolic Reference)
클래스, 메서드, 필드 등을 문자열 형태(심볼)로 참조하는 방식
- 이름 기반 참조, 간접적인 참조
ex) 서울시청
```
```
❓ 다이렉트 레퍼런스 (Direct Reference)
JVM이 실행 중에 객체나 클래스에 직접 접근할 수 있는 실제 메모리 주소 또는 내부 포인터
=> 컴파일 시점이나 클래스 로딩 초기에는 클래스나 메서드, 필드 등을 문자열로만 알고 있음 (심볼릭 레퍼런스)
=> 클래스가 JVM에 로딩되고 링킹 됨
=> JVM이 심볼릭 레퍼런스를 진짜 메모리 상의 주소나 참조 정보로 바꿔줌 (다이렉트 레퍼런스)

- WHY?
실행 시 빠르고 직접적인 접근을 위해
```
```
❓ Static 변수 (정적 변수)
클래스에 소속된 변수로 객체를 만들지 않아도 공유되는 변수
- 모든 객체가 하나를 공유
- JVM의 메서드 영역에 저장 (객체가 아닌 클래스에 소속된 변수)

WHEN?
- 공통된 값을 저장해야 할 때 (전체 객체 수, 설정 값)
- 상수 선언할 때

WHY?
- 메모리 절약
- 접근 편의성
```

c. 초기화 (Intializing)
- 클래스의 static 변수들이 실제 코드에 정의된 값으로 초기화





** (4) 실행 준비: Runtime Data Area (런타임 데이터 영역) 구성 **
자바 프로그램을 실행할 때 사용되는 데이터를 위한 메모리 구조


a. 메서드 영역
- JVM이 시작될 때 생성되는 메모리 공간
- 모든 스레드가 공유하는 구조 (동시성 문제)
- 자바 프로그램의 클래스 구조, 실행 로직에 대한 핵심 정보 저장

1. 런타임 상수 풀 (Runtime Constant Pool)
- 클래스 파일 내부에는 상수값이나 심볼(문자열, 메서드 참조 등)을 모아둔 constant pool table 존재
- 이 테이블의 데이터는 JVM이 클래스를 로드하며 메서드 영역 내부의 런타임 상수 풀로 변환되어 저장
- 필요한 정보 참조, 중복되는 값 없이 공유 -> 메모리 효율 높임
- 공통 참조 데이터 저장소

2. 필드/메서드 데이터 (Field and Method Metadata)
- 클래스에 정의된 변수, 메서드 이름, 리턴 타입, 매개변수 타입 등 메서드 시그니처 정보 저장
- 실행 코드 X
- JVM이 해당 클래스의 구조를 이해하고 실행을 준비할 수 있도록 설계된 "정의 정보"

3. 메서드 코드 (Method Bytecode)
- 클래스에 정의된 각 메서드의 바이트 코드가 저장되는 공간
- JVM은 이 바이트코드를 인터프리트 하거나 JIT 컴파일하여 실제로 프로그램 실행
- 메서드 본문의 바이트코드, 예외 처리 정보 포함
- 호출 시마다 스택 영역에서 프레임을 만들어 실행

```
❓ 프레임
JVM이 메서드 실행을 위해 생성하는 스택 내 작업 공간
생성자 코드 (Constructor Bytecode)
클래스의 인스턴스를 생성할 때 호출되는 생성자의 바이트 코드 저장
객체 초기화에 필요한 로직 포함
메서드 코드와 유사하게 바이트코드 형식으로 구성
```
```
❓ 인스턴스
클래스를 바탕으로 실제로 메모리에 만들어진 '실체(객체)'
```




b. 힙 영역
- JVM이 실행 중 동적으로 생성하는 객체들을 저장하는 메모리 공간
- 모든 스레드가 공유 (메서드 영역과 함께)
- JVM이 자동으로 메모리를 할당 -> 사용이 끝난 객체는 가비지 컬렉션의 대상이 됨 (자동 메모리 관리)
- new 연산자로 생성된 객체 인스턴스 배열과 같은 참조 타입(Reference Type)의 실제 데이터가 저장됨
- 힙에 저장된 객체는 스스로 접근되지 않으며, 반드시 스택 영역에 존재하는 참조 변수(레퍼런스)를 통해 접근

```
❓ new 연산자
- 자바에서 클래스를 바탕으로 실제 객체(= 인스턴스)를 만드는 키워드
- 힙 메모리에 공간을 할당하고 객체를 생성하는 역할
```
```
❓ 기본 타입
- int, double, char, boolean 등
- 스택에 직접 저장
```
```
❓ 참조 타입
- String, Person, 배열 등
- 스택에는 참조값(주소)만 저장
- 힙에 저장
```
```
❓ 힙에 참조 타입이 저장?
- 힙에는 참조 타입의 값, 즉 객체 인스턴스 그 자체가 저장
👉🏻 객체 자체 (필드 값, 메서드 테이블 등)가 저장

- 객체의 주소값(레퍼런스)는 스택에 저장
👉🏻주소(레퍼런스)만 저장, 객체는 X
```
```
❓ 가비지 컬렉션
더 이상 참조되지 않는 객체를 JVM이 자동으로 탐지해 메모리에서 제거하는 기능
- 개발자가 직접 메모리를 해제하지 않아도 되도록 도와줌
```




c. 스택 영역 (JVM Stack, Stack Area)
- JVM이 메서드를 실행할 때 사용하는 임시 저장 공간
- 기본형 변수나 메서드 실행 정보 등이 저장됨
- 각 스레드마다 고유한 스택 생성 -> 메서드가 호출될 때마다 스택 프레임이 쌓임 -> 메서드가 종료되면 해당 프레임은 제거
- LIFO 구조로 동작: 가장 마지막에 쌓인 프레임이 가장 먼저 제거됨
- 메서드가 호출될 때마다 해당 메서드만을 위한 스택 프레임 하나씩 생성

```
❓ 스택 프레임
메서드가 호출될 때 생성되는 독립적인 실행 단위
- 메서드 실행에 필요한 모든 정보 저장
- 메서드의 매개 변수, 지역 변수, 연산 중간 결과, 리턴값
👉🏻 메서드 실행이 종료되면 해당 프레임 자동 제거, 저장된 정보 접근 불가능

메서드의 매개변수
- 메서드가 호출될 때 외부에서 전달받는 입력 값
- 프레임이 생성될 때 함께 저장

지역 변수
- 메서드 내부에서 선언된 변수
- 해당 메서드가 실행되는 동안만 유효
- 프레임 안에 저장

연산 도중 발생하는 임시 값
- 연산을 수행하는 중간 과정에서 생성되는 일시적 데이터
- 연산 스택에 저장

리턴 값
- 메서드 실행 결과로 반환되는 값
- 호출한 측으로 돌려주기 전까지 프레임에 저장

예외 처리 및 제어 흐름 정보 등
- 예외 발생 시 처리 흐름을 관리하거나, 메서드가 종료되면 어디로 돌아갈지 지정하는 정보 포함
```






d. PC Register (프로그램 카운터 레지스터)
- 각 스레드마다 독립적으로 생성되는 메모리 공간
- 현재 해당 스레드가 실행 중인 JVM 명령어의 주소 저장
👉🏻 JVM이 어떤 명령어를 수행하고 있는지, 다음에 어떤 명령어를 실행할 것인지를 추적하기 위한 '실행 흐름 기록 장치'

```
❓ 레지스터
현재 실행 중인 명령어의 위치나 중간 연산 겨로가 등을 임시로 저장하기 위한 작은 메모리
- 자바 프로그램에서 하나의 스레드는 독립적으로 실행
   -> 각 스레드는 자신만의 PC 레지스터 가지고 있음
   -> PC 레지스터: 해당 스레드가 어떤 바이트코드 명령어를 실행 중인지를 추적
   -> JVM: 주소 정보를 기반으로 명령어 순차적으로 읽고, 조건에 따라 점프하거나 분기하여 프로그램 흐름 제어
- 스레드가 네이티브 메서드(C/C++)를 실행 중
   -> 자바의 PC 레지스터는 정의되지 않은 상태 (undefined)
```




E. Native Method Stack (네이티브 메서드 스택)
- C, C++, 어셈블리 등 다른 언어로 작성된 네이티브 코드를 실행하기 위해 사용되는 별도의 스택 메모리 영역
- 자바 프로그램 내에서 외부 네이티브 함수 호출
   -> 해당 메서드는 자바의 JVM 스택이 아닌 네이티브 메셔드 스택에 쌓여 실행

```
❓JNI
자바 코드에서 C/C++ 같은 네이티브 코드를 호출해 OS·하드웨어 기능이나 성능 최적화를 활용할 수 있게 해주는 인터페이스
- 자바 

WHY?
자바는 기본적으로 JVM 위에서 바이트 코드 형태로 실행되지만, 운영체제나 하드웨어에 밀접한 기능을 사용해야 할 때가 있기 때문
```



### (5) Execution Engine (실행 엔진)
- 클래스 로더에 의해 메모리에 적재된 바이트 코드를 실제로 실행하는 핵심 구성 요소



#### a. Interpreter (인터프리터)
- 자바 바이트 코드를 명령어 단위로 하나씩 읽고, 즉시 해석하여 실행하는 방식
- JVM은 기본적으로 인터프리터를 이용해 바이트 코드 실행
- 프로그램이 처음 실행될 때 빠르게 시작할 수 있음
- 같은 메서드가 반복해서 호출하는 경우, 매번 동일한 바이트 코드를 해석해야 하기에 실행 속도가 느려짐
- 이러한 성능문제 보완을 위해 JVM은 JIT 컴파일러 함께 사용

#### b. JIT Compiler (Just-In-Time 컴파일러)
- JVM이 프로그램 실행 중 자주 실행되는 코드(Hot Code)를 감지 -> 해당 바이트 코드 전체를 한 번에 기계어로 컴파일
이후에는 이 코드를 다시 해석 X
- 변환된 기계어 그대로 실행
- 인터프리팅을 반복하는 대신, 일정 기준 이상으로 많이 호출되는 메서드는 JIT 컴파일을 통해 최적화된 코드로 바꿈 -> 이를 캐싱해두었다가 재사용하는 방식
- 핫스팟, 핫코드 : 이때 감지되는 반복 실행 구간!
- BUT... 바이트코드를 기계어로 변환하는 과정 자체에도 일정한 시간과 자원이 소모 -> 처음부터 JIT 방식으로 실행 X
  ->초기: 인터프리터로 빠르게 실행 시작
  ->핫코드로 판단되는 경우에만: JIT 컴파일을 적용
  => 하이브리드 실행 전략

```
❓ 인터프리터가 있는 이유?
바이트코드를 한 줄씩 해석하며 바로 실행할 수 있도록 해주는 실행 방식
- 프로그램 빠르게 시작 가능: JIT 컴파일러처럼 전체 코드를 미리 기계어로 변환하지 않아도 되기에
- 바이트코드를 이해하고 각 플랫폼에 맞게 실행하는 핵심 역할

BUT 같은 메서드나 루프가 반복해서 호출하는 경우, 매번 동일한 바이트 코드를 해석해야 하기에 실행 속도가 느려짐
-> 이런 경우, JVM은 해당 코드를 핫코드로 인식
-> JIT 컴파일러가 이를 네이티브 코드(기계어)로 변환
-> 이후: 해당 코드는 인터프리터가 아닌 JIT 컴파일된 코드로 직접 실행됨

=> 실행 속도 크게 향상!
```


---

뭔가 더 예쁘고 직관적이고 가독성 있게 정리할 수 있을 것 같은데..!
손으로 필기하는 것이 더 익숙해서 그런지 아직 어색하다... 
적응해야지!
파이팅...
