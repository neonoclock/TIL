# 🧠 회고
오늘은 가비지 컬렉션(GC), 클래스, 상속에 대하여 학습하였다.
GC부분 배울 때 재미있었다! 이해가 잘되어서 뿌듯했다. (어제 GC부분 조금 다뤄보아서 그런가?) 클래스와 상속은 계속 코드로 직접 실습하며 익숙해져봐야할 것 같다... 파이팅...


---

# 🪽 오늘의 다짐
- 나의 언어로 설명할 수 있도록 하기  
- 예습 조금이라도 해보기  
- 공식 문서 찾아보는 습관 잡기  
- 저녁먹고 식곤증 이겨내기...

---

# 📝 Today I Learned

## Garbage Collection

### 1. 정의
- 더 이상 사용되지 않는 객체를 자동으로 메모리에서 제거하는 JVM의 메모리 관리 기능  
- 자바에서 생성된 객체는 힙의 메모리 영역에 저장 (해당 객체를 가리키는 참조가 존재할 때만 유효)  
  👉🏻 BUT 어떤 객체도 해당 인스턴스를 참조하지 않게 되면  
  👉🏻 그 객체는 더 이상 사용X  
  👉🏻 메모리만 차지하는 '가비지'가 됨  

❓ 참조  
어떤 변수가 객체를 가리키고 있는 상태  

---

### 2. 사용 이유
- 개발자가 직접 메모리를 해제하지 않아도, 불필요한 객체를 자동으로 정리할 수 있기 때문  
- 개발자는 객체 생성에만 집중하면 됨 (해제 따로 고려 X)  
  👉🏻 메모리 누수나 잘못된 해제로 인한 오류 줄일 수 있음  
  👉🏻 코드 간결, 안정적  
  👉🏻 대규모 프로젝트 & 긴 시간 실행되는 프로그램 : 메모리 관리 자동화 → 성능 저하, 시스템 불안정 예방 가능  
  👉🏻 한정된 힙 메모리 효율적 사용 가능  

---

### 3. 동작 방식
- 힙 영역을 주기적으로 스캔  
  👉🏻 도달할 수 없는 객체 식별  
  👉🏻 참조 그래프를 따라 살아있는 객체만 남긴 후 메모리 해제  

#### (1) 힙 메모리 구조와 세대 분할
- **Young Generation (영 세대)**  
  - 새로 생성된 객체 저장, 수명 짧음, Minor GC 자주 발생  
  - Eden, Survivor 0/1 영역으로 구성  
  - S0, S1 두 개가 존재하는 이유: Ping-pong 방식으로 GC 시마다 번갈아 복사  

- **Old Generation (올드 세대)**  
  - Young 세대를 거쳐 일정 시간 이상 생존한 객체 저장  
  - 수명 긴 객체, 메모리 넓음  
  - GC 빈도 낮지만 Major GC 발생 시 오래 걸림  
  - Major GC는 Stop-The-World(STW) 현상 유발  

❓ Stop-The-World  
GC가 실행되는 동안 JVM이 모든 애플리케이션 스레드를 일시적으로 중단시키는 현상  

❓ 왜 스레드를 멈추는가  
- 객체 참조 관계를 정확히 파악하기 위해  
- 재배치 시 메모리 주소가 바뀌면 오류 발생 가능  
- 데이터 일관성 보장 필요  

#### (2) Minor GC 와 Major GC
- **Minor GC**: Eden 가득 찼을 때 발생, Survivor로 복사 후 Promotion 가능  
- **Major GC**: Old 영역 대상, 처리 시간 오래 걸림, STW 발생  
- **Full GC**: JVM 전체 영역(Young+Old+Metaspace) 대상  

❓ 메타스페이스(Metaspace)  
클래스 메타데이터(이름, 상속, 메서드, 필드 등) 저장  

#### (3) GC 전체 동작 과정
a. 객체가 힙에 생성됨 → 참조가 유지되면 생존  
b. 참조가 끊기면 Unreachable  
c. GC Root에서 도달 가능한 객체 탐색 → 마킹  
d. 마킹되지 않은 객체 제거 (Sweep)  
e. 단편화 방지 위해 Compaction 수행  
f. 주기적이지 않고 메모리 상황 따라 비동기적으로 수행  

⭐️ GC는 단순히 객체 제거가 아니라 **성능과 안정성을 동시에 유지하는 핵심 메커니즘**  

---

### 4. 자바에서 GC가 중요한 이유
1. 서비스 중단 방지 (STW 제어)  
2. 응답 지연/처리량 병목의 원인  
3. 잘못된 설정 → 운영 장애로 직결  
4. 튜닝/모니터링 가능한 핵심 지표  

👉🏻 결론: GC는 서비스 품질과 운영 리스크를 결정짓는 JVM 핵심 기능  

---

## Class

### 1. 정의
- 관련된 속성과 메서드를 묶어서 객체를 생성하기 위한 템플릿  

### 2. 사용 이유
- 코드 재사용성·유지보수성 향상  
- 속성과 동작을 하나의 단위(객체)로 구조화하여 모듈화  

---

### 3. 사용 방법
- `class` 키워드로 정의 → `new` 키워드로 객체 생성 → 필드와 메서드 사용  

- Main 클래스: 프로그램 실행의 진입점  
- `public static void main(String[] args)`: 실행 시작 메서드  

---

### 4. 정보
- **메서드**: 객체 동작 정의. 인스턴스/정적/반환/void 구분  
- **접근 제어자**: `public`, `private`, `default`, `protected`  
- **생성자**: 객체 초기화, 클래스명과 동일, 반환형 없음  
- **인스턴스**: `new`로 생성된 객체  
- **this**: 현재 객체 참조  
- **추상 메서드**: abstract 키워드, 하위 클래스에서 구현 필요  

❓ 오버로딩 vs 오버라이딩  
- 오버로딩: 같은 이름, 다른 매개변수  
- 오버라이딩: 부모 메서드 재정의  

- **Inner 클래스**: 외부 인스턴스에 종속  
- **Nested 클래스**: `static`으로 선언, 독립적 생성 가능  

---

## 상속 (Inheritance)

### 1. 정의
- 자식 클래스가 부모 클래스의 필드와 메서드를 물려받아 재사용/확장  
- `extends` 키워드 사용  
- 생성자는 상속되지 않음 → `super()`로 부모 생성자 호출  

---

### 2. 사용 이유
- 코드 재사용  
- 유지보수성·유연성 향상  
- 확장성 확보  

---

### 3. 사용 방법
- 자식 클래스 정의 시 `extends` 사용  
- 오버라이딩으로 부모 메서드 동작 재정의 가능  
- 생성자에서 `super()` 호출 가능  

⭐️ 자바는 다중 상속 불가능  
