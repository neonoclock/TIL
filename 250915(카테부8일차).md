
# 🧠 회고

오늘 방대한 양의 진도를 나갔다...

타입, 스트링, 다형성(오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅), 캡슐화, 인터페이스에 대해 학습하였는데 내용이 많은 만큼 복습이 중요할 것 같다.

# 🪽 오늘의 다짐

시간 활용 잘하기
복습 꼼꼼히 하기
식곤증 이겨내기

# 📝 Today I Learned

## 1️⃣ 타입 (Type)

### 1. 정의

- 변수나 값이 가질 수 있는 데이터의 종류와 형식을 지정하는 자바의 기본 개념
- 데이터의 해석 방식, 연산 가능 여부, 메모리 사용 방식 결정
- 컴파일 시점에 타입 오류를 잡음
  👉🏻 코드 안정성, 예측 가능성 높여줌
- 자바 = 정적타입 언어
  👉🏻 모든 변수는 사용되기 전, 타입을 명확하게 선언해야 함

#### ❓ 정적타입 언어

- 변수를 선언할 때 타입을 미리 정해두는 언어
- 컴파일 시점에 타입 검사를 함
- JAVA, C, C++
  장점: 실행 속도 빠름, 오류 미리 잡음 (안전성)
  단점: 코드 작성 시 번거로움

#### ❓ 동적타입 언어

- 변수를 선언할 때 타입을 정하지 않고, 실행 중에 타입이 결정되는 언어
- 런타임 시점에 타입 검사를 함
- Python, JavaScript
  장점: 코드 간결, 개발 속도 빠름 (유연)
  단점: 실행 중 에러 발생 가능, 대규모 프로젝트에서 위험

### 2. 타입

#### (1) 기본 타입 (Primitive Type) = 원시 타입

- 값 그 자체를 저장하는 타입
  `int` : 정수 (4바이트)
  `double` : 실수 (8바이트)
  `char` : 문자 (2바이트, 유니코드)
  `boolean` : 참/거짓 (1비트 개념)
  `byte` : 작은 정수 (-128 ~ 127)
  `short` : 정수 (2바이트)
  `long` : 큰 정수 (8바이트)
  `float` : 실수 (4바이트)

#### (2) 참조 타입

- 값 자체가 아닌, 값이 저장된 메모리 주소(참조)를 저장하는 타입
- 변수에 실제 데이터가 아닌 객체나 배열의 위치를 가리키는 정보가 저장
- 객체 지향 프로그래밍의 핵심
  **클래스**
  사용자가 정의하거나 자바에서 제공하는 설계도
  객체를 생성하는 기반이 되는 타입
  **배열**
  동일한 타입의 값을 연속적으로 저장
  인덱스로 접근할 수 있는 자료 구조
  **인터페이스**
  구현 클래스가 따라야 할 규칙(메서드 시그니처 등)을 정의하는 타입
  **열거형 (enum)**
  미리 정의된 상수 집합을 갖는 타입
  선택 가능한 값이 제한되어 있음

### 3. 알아야하는 이유

- 변수나 값이 어떤 데이터를 담을 수 있는지, 어떻게 처리되고 동작되는지 정확히 이해하고 예측할 수 있기 때문
- 타입 잘못 사용
  👉🏻 컴파일 오류, 프로그램이 의도와 다르게 동작
  👉🏻 타입에 대한 정확한 이해는 오류없이 올바르게 코드를 작성하기 위해 반드시 필요

### 4. 사용 방법

- 변수 앞에 데이터 타입을 작성해 변수에 저장할 수 있는 데이터의 종류를 지정
- 기본 문법
  `타입 변수이름 = 값;`
- 예시
  `int age = 26;` // 정수형
  `double height = 177.5;` // 실수형
  `char grade = 'A' ;` // 문자형
  `boolean isPassed = true;` // 논리형
  `String name = 'Wayne';` // 참조형 (클래스)
- 타입에 맞는 값만 저장 가능
  `int number = 10;`
  `number = "Adapterz";` //컴파일 오류: 문자열은 int에 저장 못함

### 5. 정보

#### (1) final

- 한 번 초기화한 변수나 필드의 값을 이후에 변경할 수 없도록 제한하는 자바의 제한자
- 값을 한 번만 할당 가능, 이후에는 다시 대입 X

#### ❓ 제한자

- 자바에서 클래스, 변수, 메서드 등에 부가적인 속성이나 제약을 부여하는 키워드
- 접근 제어자: `public`, `private`
- 제한자 (동작 방식이나 사용 가능성을 제한 및 제어): `final`, `static`, `abstract`
- 대상 앞에 붙여서 의미를 바꾸며, 코드의 동작 방식이나 사용 가능성을 명확히 표현하는 역할

`final int MAX_SPEED = 120;`
`MAX_SPEED = 150;` //오류 발생: final 변수는 값 변경 불가

- 주로 상수를 선언할 때 사용
- 값이 고정되어야 하는 상황에서 안정성과 명확성을 보장
- 참조값은 변경 X, 객체 내부 상태는 변경 O

#### (2) static

- 클래스 단위로 공유되는 필드나 메서드를 정의할 때 사용
- 객체 없이도 클래스 이름만으로 접근 가능

```java
public class Car {
    static int getMaxSpeed() {
        return 240;
    }
}
int maxSpeed = Car.getMaxSpeed(); // 객체 없이 호출 가능
```

- `static`으로 선언된 필드나 메서드는 JVM이 클래스를 로딩할 때 메서드 영역에 단 한 번만 생성된다.
  👉🏻 이후 프로그램이 종료될 때까지 해당 클래스의 모든 객체가 공유하며 사용 가능하다
- 객체마다 새로 생성되지 않고, 클래스 자체에 소속된 하나의 공용 메모리 공간이 유지된다.

#### ❓ static을 사용하는 이유

1.  **공통된 데이터 또는 기능을 클래스 단위로 관리하기 위해**
    - `static` 키워드를 사용하면 객체를 생성하지 않고도 해당 필드나 메서드 접근 가능
    👉🏻 따라서 모든 인스턴스가 동일한 값을 참조해야 하는 변수나, 상태와 무관한 계산 로직 등에 사용
2.  **프로그램 진입점 정의를 위해**
    - JAVA 프로그램은 `main` 메서드를 통해 실행됨
    👉🏻 이 메서드는 반드시 `static`이어야 함
3.  **유틸리티 메서드 구성 시 객체 생성을 방지하기 위해**

#### ❓ 유틸리티 메서드

특정 객체의 상태(필드 값)에 의존하지 않고, 자주 쓰이는 기능을 재사용하기 위해 따로 만들어 놓은 메서드

#### (3) Wrapper

- `int`, `double`, `boolean`과 같은 기본 자료형을 객체로 감싸는 클래스
- 기본 타입을 객체처럼 다룰 수 있도록 해줌
- 자바의 객체 지향적인 처리 방식과 컬렉션 프레임워크 사용 시 필수적

#### ❓ 컬렉션 프레임워크

데이터를 저장, 검색, 삭제, 정렬 등 효율적으로 다루기 위한 표준화된 클래스와 인터페이스의 집합

- 필요한 이유
  👉🏻 기본형 데이터를 객체처럼 다룰 수 있도록 해줌
  👉🏻컬렉션 사용, `null` 표현, 유틸리티 메서드 활용, 객체 지향 기능과의 호환
- 주요 Wrapper 클래스
  `byte` - `Byte`
  `short` - `Short`
  `int` - `Integer`
  `long` - `Long`
  `float` - `Float`
  `double` - `Double`
  `char` - `Character`
  `boolean` - `Boolean`

#### (4) 오토박싱, 언박싱

- 기본 타입과 래퍼 타입 간에 값을 변환할 때 개발자가 명시적으로 형 변환을 하지 않아도 자바가 자동으로 변환해주는 기능
  **a. 오토 박싱**
  - 기본 타입을 자동으로 래퍼 클래스 객체로 변환해주는 기능
    ex) `int`값을 `Integer` 객체에 자동으로 감싸주는 동작
  **b. 언박싱**
  - 래퍼 클래스 객체를 다시 기본 타입으로 자동 변환하는 기능
    ex) `Integer`객체에서 `int` 값만 꺼내는 동작

## 2️⃣ String

### 1. 정의

- 문자의 연속을 표현하는 불변 객체인 문자열 자료형
- 문자열: 큰따옴표를 사용해 표현, 문자열 리터럴을 사용하면 JVM 내부의 String Pool이라는 영역에 저장
- String 객체는 한 번 생성되면 내용을 변경할 수 없는 불변 객체

### 2. 사용 이유

- 문자열을 손쉽게 표현하고 조작할 수 있도록 다양한 기능을 제공하기 때문
  **선언이 간편함**
  문자열은 큰따옴표만으로 표현할 수 있어 코드의 가독성이 높고, 직관적으로 선언 가능
  **다양한 내장 기능 제공**
  **불변 객체 구조**
  한 번 생성되면 내부 값을 변경할 수 없는 불변 객체로 설계되어 있음
  코드 안정성과 스레드 안정성 높여줌
  **메모리 효율성**
  동일한 문자열 리터럴은 JVM의 String Constant Pool에서 공유됨
  중복 객체 생성을 줄이고 메모리 효율적 사용 가능

#### ❓ 문자열 리터럴

코드에서 큰따옴표("")로 직접 작성된 문자열 값
- JVM의 String Constant Pool에 저장되어 동일한 하나의 객체로 공유

### 3. 사용 방법

#### (1) 문자열 선언

`String greeting = "Hello, Adapterz!"`

#### (2) 문자열 비교

```java
String a = "Adapterz";
String b = "Adapterz";
String c = new String("Adapterz");

System.out.println(a == b); //true (같은 리터럴, 같은 객체)
System.out.println(a == c); //false (다른 객체)
System.out.println(a.equals(c)); //true (값이 같음)
```

- 문자열 값을 비교할 때는 `equals()` 메소드 사용

#### (3) 주요 메서드

- `length()` : 문자열의 길이 반환
  `"Adapterz".length()`
  `8`
- `charAt(i)` : i번째 문자 반환
  `"Adapterz".charAt(2)`
  `'a'`
- `substring(a, b)`: a~b-1 범위의 부분 문자열 추출
  `"Adapterz".substring(0,3)`
  `"Ada"`
- `toUpperCase()` : 대문자로 변환
  `"Adapterz".toUpperCase()`
  `"ADAPTERZ"`
- `contains(str)`: 특정 문자열 포함 여부 확인
  `"Adapterz".contains("ter")`
  `true`

## 3️⃣ 다형성

### 1. 정의

- 하나의 타입으로 여러 객체를 다룰 수 있도록 하여, 동일한 코드가 상황에 따라 다른 동작을 수행하게 하는 객체 지향 특성
- 자바에서는 주로 부모 클래스나 인터페이스 타입으로 자식 객체를 참조하는 방식으로 다형성이 구현

#### ❓ 인터페이스

- 클래스가 반드시 구현해야 할 메서드의 형태만 정의한 설계 구조
- 자체적으로 동작코드는 없음
- 오직 메서드 시그니처만 선언
- 클래스는 인터페이스를 구현함으로써, 정해진 규칙에 따라 동작을 보장

### 2. 다형성 종류

#### (1) 정적 다형성 (오버로딩)

- 메서드 이름은 같지만 매개변수의 형태나 개수를 다르게 정의하여 여러 버전을 만드는 것

#### (2) 동적 다형성 (오버라이딩)

- 상속받은 메서드를 자식 클래스에서 다시 정의해 새로운 동작으로 만드는 것
  => 컴파일 타임과 런타임에서 각각 다르게 동작

#### ❓ 컴파일 타임

소스 코드를 자바 컴파일러가 바이트코드로 변환하는 시점
- 코드를 실행하기 전, 개발 도구가 코드를 분석하고 오류를 잡는 과정

#### ❓ 런타임

컴파일된 프로그램이 실제로 실행되는 시점
- 메모리 할당, 메서드 호출, 예외 발생 등이 일어남

### 3. 사용 이유

- 코드 수정을 최소화하면서 다양한 기능을 유연하게 확장 가능

### 4. 사용 방법

- 주로 오버로딩과 오버라이딩을 통해 사용됨

## 4️⃣ 다형성 - 오버로딩 (Overloading)

### 1. 정의

- 하나의 클래스 안에서 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입을 다르게 작성하는 개념

### 2. 사용 이유

- 코드의 일관성과 가독성을 높일 수 있기 때문
- 하나의 의미 있는 이름을 중심으로 다양한 입력 방식에 유연하게 대응 가능
- 일관성, 확장성, 유지보수성 향상
- 생성자 오버로딩
  👉🏻 객체 생성 시 입력 값의 유무나 종류에 따라 다른 초기화 방식 적용 가능
  👉🏻클래스 사용자에게 더 유연하고 직관적인 인터페이스 제공 가능

### 3. 사용 방법

- 하나의 클래스 안에 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입을 다르게 작성
- 메서드 이름은 같더라도, 자바는 매개변수 목록(시그니처)를 기준으로 각각 다른 메서드로 인식

#### ❓ 메서드 시그니처

- 메서드 이름, 매개변수의 개수, 타입, 순서로 구성된 식별 정보
- 리턴 타입은 시그니처 포함 X
- 메서드 이름이 같더라도 시그니처가 다르면 오버로딩 가능

## 5️⃣ 다형성 - 오버라이딩 (Overriding)

### 1. 정의

- 부모 클래스의 메서드를 자식 클래스에서 재정의하여 동작을 바꾸는 개념
- 자식 클래스에서 메서드의 이름, 매개변수, 리턴 타입을 동일하게 유지하면서 본문만 바꿔서 다시 정의하는 것

### 2. 사용 이유

- 상속받은 메서드의 동작을 자식 클래스의 상황에 맞게 바꿔 코드의 유연성과 확장성을 높이기 위해
- 상속 구조를 유지하면서 객체의 종류에 따라 맞춤 동작 적용 가능
  👉🏻 코드의 일관성과 동작의 유연성 동시 확보 가능

### 3. 사용 방법

- 자식 클래스에서 부모 클래스의 메서드와 동일한 시그니처로 메서드 다시 정의
  👉🏻 `@Override` 어노테이션을 붙여 사용

#### ❓ 어노테이션

- 자바 코드에 추가적인 정보를 부여하는 메타데이터
- 코드에 직접적인 영향 X
- 컴파일러나 실행 환경(JVM)이 해당 정보를 참고해 특정 동작을 수행하도록 도움

## 6️⃣ 다형성 - 업캐스팅 (Upcasting)

### 1. 정의

- 구현체(클래스)를 그것이 구현한 인터페이스나 상속받은 상위 클래스 타입으로 참조하는 것
- 여러 자식 클래스가 공통된 동작을 가지고 있을 때, 그 동작을 상위 타입으로 추상화하여 하나의 타입으로 다룰 수 있도록 함
- 코드의 일관성 유지 가능
- 다양한 구현체를 유연하게 교체할 수 있음

### 2. 종류

#### (1) 직접적인 업캐스팅

- 자식 클래스의 객체를 부모 타입 변수에 직접 대입
- 명시적 형변환 없이 컴파일러 자동 수행
- 주로 변수 선언 시점에 사용
- 한 객체만 다룰 때 사용
- 다형성 구조의 기반을 만드는 가장 기본적 형태

#### (2) 간접적인 업캐스팅

- 자식 객체를 컬렉션에 담거나, 메서드 인자로 전달하는 과정에서 자동으로 상위 타입으로 형변환
- 여러 구현체를 공통 타입으로 묶어 일괄 처리
- 다형성을 구현하는데 매우 유용

### 3. 사용 이유

- 각기 다른 객체를 공통된 상위 타입으로 통합
  👉🏻 다형성을 일관된 방식으로 적용하기 위해
- 각 객체의 구체적인 클래스에 관계없이 동일한 방식으로 동작 호출
- 업캐스팅은 다형성을 실현하고, 새로운 클래스가 추가되더라도 기존 코드를 수정하지 않고 확장할 수 있도록 도와주며, 구현체에 대한 의존성을 줄여 유지보수성을 높여줌
- 장점
  코드를 통합된 방식으로 작성 가능
  새로운 객체가 추가되더라도 기존 코드 수정하지 않아도 됨
  상위 타입만 알고 있어도 테스트 및 호출 가능

#### ❓ 업캐스팅 vs 오버라이딩

**업캐스팅**
- 다형성이 가능한 설계 구조를 만들기 위한 전제 조건
- 다양한 객체를 공통된 상위 타입으로 통일해 하나의 코드 흐름으로 처리할 수 있도록 함
**오버라이딩**
- 그 구조 내에서 객체별로 다른 동작을 가능하게 만드는 메커니즘
- 그 통일된 흐름에서 각 객체가 고유한 방식으로 동작하도록 정의하는 방법

#### ❓ 제네릭

- 클래스나 메서드를 다양한 타입으로 재사용할 수 있게 만드는 문법
- `List`

## 7️⃣ 다형성 - 다운캐스팅 (Downcasting)

### 1. 정의

- 부모 클래스 타입으로 참조된 객체를 다시 자식 클래스 타입으로 변환하는 것

```java
// Vehicle 인터페이스를 구현한 Bus 객체를 생성하고, Vehicle 타입으로 업캐스팅하여 참조하고 있다.
Vehicle vehicle = new Bus(); //업캐스팅

// 업캐스팅된 객체를 다시 Bus 타입으로 다운캐스팅하고, Bus 클래스에만 존재하는 기능을 호출할 수 있다.
Bus bus = (Bus) vehicle; //다운캐스팅
bus.excel(); // Bus 고유 기능 호출
```

### 2. 사용 이유

- 상위 타입으로 추상화된 객체를 다시 자식 타입으로 변환해, 자식 클래스에만 정의된 기능이나 필드에 접근하기 위해
- 공통 타입으로 처리된 객체의 구체적 기능에 다시 접근하기 위한 도구

### 3. 사용 방법

- 상위 타입으로 참조된 객체를 다시 원래의 하위 타입으로 변환하여, 하위 타입 고유의 기능을 사용

### 4. 핵심 특징

- **강제 형변환 필요**: `(하위타입)` 형식으로 명시적 변환 해야함
- **타입 검사 필수**: 잘못된 다운캐스팅은 `ClassCastException` 발생
- **하위 타입 고유 기능 호출 가능**: 상위 타입에는 없는 메서드 접근 가능
- **업캐스팅된 객체만 다운캐스팅 가능**: 애초에 상위 타입으로 참조된 객체여야 안전

## 8️⃣캡슐화 (Encapsulation)

### 1. 정의

- 객체의 내부 상태를 외부에서 직접 접근하지 못하도록 감춤
  👉🏻 메서드를 통해 간접적으로 접근하도록 하는 객체지향 개념
- 객체의 내부 구현 보호
- 제어된 방식으로만 접근할 수 있도록 보장하는 구조적 개념

### 2. 사용 이유

- 객체 내부 상태를 외부적으로 보호
- 데이터의 무분별한 접근이나 변경 방지

### 3. 사용 방법

- 클래스의 필드(멤버 변수)를 `private`으로 선언하여 외부에서 직접 접근하지 못하도록 차단
  👉🏻 필드에 접근하거나 값을 설정할 수 있도록 `public` 접근 제어자를 가진 `getter`와 `setter` 메서드 정의
- 캡슐화는 접근 제어자(`private`, `public`)을 통해 필드 보호와 접근 경로를 명확히 구분하고, 객체 내부 상태를 외부로부터 안전하게 유지하기 위한 기본적인 구현 방식

#### ❓ getter , setter

`private` 필드 (멤버 변수)에 간접적으로 접근하거나 값을 설정할 수 있도록하는 메서드
- `getter`: 값을 읽는 메서드 : `get필드명()`
- `setter`: 값을 설정하는 메서드 : `set필드명(값)`

#### ❓ 멤버 변수

= 필드
- 클래스 안에 선언된 변수
- 객체가 가지는 속성(데이터)를 저장하는 변수

## 9️⃣인터페이스 (Interface)

### 1. 정의

- 구현 세부사항 없이 클래스가 구현해야 할 메서드의 집합만을 정의한 설계 명세서
- "이 기능을 반드시 제공해야 한다"는 명시적 요구사항의 집합
- 메서드의 이름과 매개변수만을 정의, 실제 동작은 포함 X
- 구현은 오직 해당 인터페이스를 따르는 클래스에서 이루어짐
  👉🏻 명세와 구현을 구분함
  👉🏻 유연하고 확장 가능한 설계 가능
- 인터페이스를 구현하는 클래스는 그 안에 선언된 모든 메서드를 반드시 오버라이딩하여 구현해야 함
- 하나의 클래스가 여러 인터페이스를 동시에 구현 가능

### 2. 사용 이유

- 기능이 미완성된 설계 단계에서도 구조를 먼저 정의하고, 구현자 간 역할 분리
  👉🏻 유연하고 확장 가능한 개발
- 실제 구현이 달라질 수 있는 상황
  👉🏻 상위 코드는 인터페이스만 알고 있으면 됨
  👉🏻 유연한 확장, 대체 구현, 테스크 더블(mock) 사용 쉬워짐

#### ❓ 테스트 더블

- 실제 객체 대신 테스트 목적으로 사용하는 가짜 객체
- 빠르고 안정적인 단위 테스트 가능
- 외부 환경에 의존하지 않고 코드 동작 검증 가능

#### ❓ mock, stub

**stub**
- 미리 정해둔 값만 단순히 반환하는 테스트용 객체
- 데이터 제공에 초점
**mock**
- 호출 여부, 호출 횟수, 전달된 인자까지 기록하고 검증할 수 있는 객체
- 행동 검증에 초점

### 3. 사용 방법

- `interface`로 선언
  👉🏻 클래스에서 `implements`로 구현
  👉🏻 구현한 객체를 인터페이스 타입으로 사용
- 인터페이스 안에는 본문 없는 메서드 선언만 존재
  👉🏻 이 메서드들은 기본적으로 `public abstract`

#### ❓ public abstract

- `public`: 어디서든 접근 가능함
- `abstract`: 구현 없이 선언만 된 메서드
  => 해당 메서드는 반드시 하위 클래스에서 구현 되어야 함

### 4. 기본 형식

```java
public interface 인터페이스이름 {
    반환형 메서드이름(매개변수);
}
```

### 5. 인터페이스 vs 추상 클래스

#### (1) 핵심 차이점

- **인터페이스**
  공통된 메서드의 이름(형태)만 정의하고, 그 구현은 강제하지 않음
  인터페이스는 "이 메서드를 반드시 구현해야 한다"는 계약을 정의
  구현 클래스는 그 인터페이스를 따르는 한 반드시 메서드 재정의 해야함
- **추상 클래스**
  공통된 메서드의 정의 뿐만 아니라, 일부 구현도 함께 제공
  일부 기능은 미리 구현해두고, 나머지는 자식 클래스에서 선택적으로 재정의하게 함으로써 기능 재사용과 확장 유도하는 구조

#### (2) 사용 맥락과 목적

- **인터페이스**
  구현을 강제하고, 유연한 구조 설계에 유리하기 때문에 전략 패턴이나 의존성 주입 구조에서 널리 사용
  어떻게 동작할지 정해지지 않은 상태에서, 반드시 구현해야 할 메서드만 정의
  구현 분리와 유연한 확장을 위한 구조
- **추상 클래스**
  공통 동작을 일부 구현해두고, 세부 동작만 자식에게 위임하고 싶을 때 사용
  공통 로직은 미리 정의해두고, 필요한 부분만 자식에게 위임
  기능 공유와 점진적 확장을 위한 구조

---

+

**React-hook-form**
- 리액트에서 폼(Form) 상태와 유효성 검사를 쉽게 관리할 수 있게 해주는 라이브러리

**덕타이핑**
- 객체가 특정 클래스에서 상속받았는지는 중요하지 않고, 그 객체가 필요한 메서드/속성을 가지고 있으면 그걸로 충분하다는 개념.
```
