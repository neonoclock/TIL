

# 🧠 회고

오늘은 Thread, Runnable, Executor에 대하여 학습하였다.

이해하는 데 어렵지만... 어려운만큼 열심히 해야겠다는 다짐을 했다. 감내하고 견디는 힘을 기르자!

그리고 오늘 멘토링을 하였는데 팀원분들이 질문을 너무 잘해주셔서 많이 배우고 분위기도 좋았다 ...🥺

덕분에 얻어가는 것도 많았고 다음에는 나도 질문을 할 수 있도록 노력을 ㅠㅠ... (아직 질문하는게 쉽지 않음...)

---

## 🪽 오늘의 다짐

- CS 공부하기
- 시간 활용 잘하기
- 복습 꼼꼼히 하기
- 코드 예시 실습하기
- 개발 블로그 보기 [https://www.techblogposts.com/ko/blogs](https://www.techblogposts.com/ko/blogs)

---

# 📝 Today I Learned

## 1️⃣ 스레드 (Thread)

### 1. 정의

- 하나의 프로그램(프로세스) 내에서 동시에 실행될 수 있는 독립적인 실행 흐름 단위
- 자바 애플리케이션은 기본적으로 `main()` 메서드에서 시작되는 하나의 스레드(메인 스레드)로 실행
  - 👉🏻 필요에 따라 여러 개의 스레드 생성
  - 👉🏻 여러 작업을 동시에 처리하는 병렬 실행(동시성) 가능

#### ❓ 프로세스 vs 스레드

| 구분      | 프로세스                                      | 스레드                                      |
|-----------|-----------------------------------------------|---------------------------------------------|
| 정의      | 운영체제에서 실행 중인 프로그램의 독립 단위    | 프로세스 안에서 실행되는 실행 흐름의 단위    |
| 메모리    | 각자 독립된 메모리 공간 가짐                  | 같은 프로세스의 자원을 공유하며 실행         |
| 전환 비용 | 문맥 전환 비용 큼                             | 문맥 전환이 가볍고 빠름                     |
| 영향      | 하나가 죽어도 다른 프로세스에 영향 적음       | 자원 공유로 하나의 오류가 전체에 영향 가능  |

#### ❓ 동시성 vs 병렬성

- **동시성**: 여러 작업을 번갈아가며 처리해서 동시에 실행되는 것처럼 보이는 것
- **병렬성**: 여러 작업을 실제로 동시에 처리하는 것

#### ❓ 멀티 스레드 vs 멀티 프로세스

- **멀티 프로세스**: 하나의 작업을 여러 개의 프로세스로 나누어 실행 (각 프로세스는 독립 메모리)
- **멀티 스레드**: 하나의 프로세스 안에서 여러 실행 흐름(스레드)을 만들어 동시에 작업 처리 (같은 메모리 공간 공유)

### 2. 사용 이유

- 여러 작업을 동시에 실행해 애플리케이션의 성능과 응답성을 높이기 위해
- 다중 작업을 하나의 실행 흐름에서 순차적으로 처리하면 전체 응답 느려짐, 사용자 경험 저하, 자원 비효율적 사용

#### 실무 관점

- **백그라운드 작업 분리**: 이메일 발송, 알림 저장, 파일 업로드 등 메인 흐름에서 분리
- **대용량 데이터 병렬 처리**: 배치 작업, 파일 처리, DB 연산 등 병렬 분산처리로 성능 향상
- **사용자 경험 개선**: 채팅, 다운로드, 실시간 알림 등 UI와 상호작용하는 기능의 비동기 처리

### 3. 사용 방법

- `Thread` 클래스를 상속하거나, `Runnable` 인터페이스를 구현한 후, `.start()` 메서드 호출

#### ❓ run()이 아닌 start()로 호출하는 이유

- `run()`을 직접 호출하면 별도 스레드가 생성되지 않고 현재 스레드에서 실행됨 → 멀티 스레드가 아님

### 4. 주요 메서드 정리

- **start()**: 스레드를 새로운 실행 흐름으로 시작
- **run()**: 스레드가 실행할 실제 코드 정의 (직접 호출 시 새로운 스레드 생성 X)
- **sleep(long millis)**: 현재 스레드를 지정한 시간(ms)만큼 일시 정지
- **join()**: 다른 스레드가 종료될 때까지 대기
- **interrupt()**: 스레드에 중단 요청 (강제 종료는 아님)

#### ❓ 스레드 내부에서 예외 발생

- 그 스레드는 조용히 종료됨
  - 👉🏻 메인 스레드 등 다른 코드에서는 예외 발생 사실조차 모름
- 예외가 처리되지 않으면 로그만 출력되고 시스템 흐름에는 영향 없어 보임
- 시스템 일부 기능이 멈췄음에도 UI나 메인 흐름이 정상처럼 보일 수 있어 치명적 버그가 방치될 수 있음

#### ❓ 스레드 내부에서 예외 처리

1. 스레드 내부에서 try-catch로 직접 예외 감싸기 (기본 방어)
2. `UncaughtExceptionHandler` 등록하여 예외 감지 및 후속 조치

---

## 2️⃣ Runnable

### 1. 정의

- 스레드가 실행할 작업(코드)을 정의하기 위한 표준 인터페이스
- 단 하나의 메서드 `run()`만을 가짐
- 해당 메서드 안에 스레드가 수행할 코드 작성
- 실행 로직을 별도의 클래스로 분리하거나 유연하게 주입하기 위해 만들어짐
- Thread 객체와 실행할 코드 분리 → 상속 제약 없이 실행 로직을 다양하게 재사용 가능

### 2. 사용 이유

- 실행 로직을 유연하게 정의하고, 다양한 비동기 환경에서 재사용 가능하게 하기 위해

#### (1) 실행 로직과 실행 제어 분리

- 실행할 작업을 객체로 전달하는 구조
  - 👉🏻 실행 제어와 실행 로직 분리, 재사용 및 테스트 용이

#### (2) 실무에서 비동기 도구의 기반

- 동시성과 병렬처리를 안정적으로 관리하기 위해 스레드 풀 기반 도구 사용

##### ❓ 스레드 풀

- 필요할 때마다 스레드를 새로 만들지 않고, 미리 만들어둔 스레드를 재사용
- 스레드 생성/소멸 비용 절감, 동시에 실행되는 스레드 수 제한

##### ❓ 동기 vs 비동기

- **동기**: 작업을 순서대로 실행, 앞선 작업이 끝나야 다음 작업 시작
- **비동기**: 작업을 요청한 뒤 결과를 기다리지 않고 다음 작업 바로 수행

#### (3) 람다식과 함께 사용 시 코드 간결

- 별도의 클래스를 만들지 않아도 됨
- 간단한 후처리, 로깅, 알람 전송 등 한 줄로 비동기 처리 가능

##### ❓ 람다식

- 자바에서 간단한 메서드를 한 줄의 식(표현식)으로 작성할 수 있는 문법
- 함수형 인터페이스 구현 시 주로 사용, 코드 간결/가독성 향상

#### (4) 상속 제한 없이 어떤 클래스와도 함께 사용 가능

- Runnable은 인터페이스이므로, 이미 다른 클래스를 상속 중인 경우에도 자유롭게 구현 가능

### 4. 사용 방법

- `run()` 메서드를 구현한 실행 로직을 Thread에 전달하여, 별도의 스레드에서 실행

#### (1) Runnable 인터페이스 구현

#### (2) Thread에 Runnable 전달 후 실행

- Runnable 구현 객체를 Thread 생성자의 인자로 전달하여 실행
  - 👉🏻 실행 흐름과 실행할 작업(로직) 분리

##### ❓ ExecutorService

- 자바에서 스레드 풀을 관리하고 작업 실행을 맡아주는 서비스
- 개발자가 직접 스레드를 만들고 종료하는 복잡한 과정을 대신 처리
  - 👉🏻 여러 작업 병렬 실행, 스레드 실행 자동 관리

#### (3) 람다식으로 간결하게 표현 (자바8 이상)

### 5. 다른 기술과의 비교

#### (1) Thread vs Runnable

| 구분      | Runnable (인터페이스)         | Thread (클래스)           |
|-----------|------------------------------|---------------------------|
| 역할      | 실행할 작업 정의 (run 메서드) | 실제 실행 주체            |
| 관계      | 인터페이스                   | Runnable 구현 클래스      |
| 사용 방식 | Thread에 전달되어 실행        | 직접 start()로 실행       |
| 장점      | 코드와 실행 분리 가능         | 단순 테스트/빠른 실행 용이|

---

## 3️⃣ ExecutorService

### 1. 정의

- 스레드 풀 기반의 비동기 작업 실행을 관리하는 고수준 스레드 실행 서비스 인터페이스
- 기존: Thread를 직접 생성해 실행 로직 관리
  - 👉🏻 ExecutorService: 작업 실행, 스레드 생성/재사용/종료까지 자동 관리
- 작업 대기열, 스레드 풀 함께 관리
- 외부에서 전달된 작업(Runnable, Callable)을 받아 스레드 풀 내에서 효율적으로 처리

#### ❓ Callable

- 스레드에서 실행 가능한 작업을 정의하며 `call()` 메서드를 통해 값을 반환하고 예외를 던질 수 있음

### 2. 구조

#### (1) 작업 제출

- `executor.submit()` 또는 `executor.execute()`로 작업 제출 → 내부 큐로 전달
- 작업은 Runnable 또는 Callable 구현 형태

#### (2) BlockingQueue

- 전달된 작업은 BlockingQueue에 저장 (FIFO)
- 스레드 수보다 많은 작업이 들어올 경우 자동 대기 버퍼 역할

#### (3) Thread Pool

- 미리 생성된 스레드 풀의 스레드가 큐에 있는 작업을 하나씩 꺼내 실행
- 작업 완료된 스레드는 사라지지 않고 재사용을 위해 풀에 반환
  - 👉🏻 매번 스레드 생성 비용 절감, 자원 안정적 관리

### 3. 사용 이유

- 스레드를 직접 관리하지 않고도, 대량 작업을 안전하게 병렬 처리하고 시스템 자원을 예측 가능하게 제어하기 위함

#### 실무 관점

1. **스레드 자원관리 자동화**: 한 번 생성한 스레드를 재사용, 불필요한 자원 낭비 차단
2. **대량 작업의 안정적 분산 처리**: 스레드 수와 큐 용량 제어, 작업 순차적 분산 처리
3. **실행 환경 설정 가능**: 스레드 수, 큐 크기, 타임아웃, 예외 처리, 거부 정책 등 설정 가능
4. **스프링 비동기 구조와 통합**: `@Async`, `@Scheduled` 등 내부적으로 ExecutorService 기반
5. **운영 편의성 향상**: 스레드 이름, 풀 이름, 작업 구조 체계화 → 실행 흐름/오류 명확 구분

##### ❓ OOM (Out Of Memory)

- 자바 프로그램이 사용할 수 있는 메모리를 모두 소진해 더 이상 객체를 생성할 수 없을 때 발생하는 오류
- 주로 스레드를 과도하게 생성하거나, 작업이 무한히 쌓일 때 발생

### 4. 사용 방법

- ExecutorService를 생성한 뒤, 작업을 제출하고, 실행이 끝나면 반드시 종료

#### 주요 메서드

- **newFixedThreadPool(int nThreads)**: 지정한 개수(n)의 스레드를 고정으로 유지하는 풀 생성
- **newCachedThreadPool()**: 필요한 만큼 스레드를 무한히 생성, 유휴 시 제거
- **newSingleThreadExecutor()**: 하나의 스레드로 구성된 풀, 모든 작업을 순차적으로 실행
- **newScheduledThreadPool(int corePoolSize)**: 일정 시간 지연 후 실행/주기적 반복 실행 작업용 풀

##### ❓ 스레드풀

- 미리 생성된 여러 개의 스레드를 재사용하여 작업 처리
- 반복적/대량 작업 처리에 유리, 객체 생성/해제 줄여 시스템 안정성 높임

### 5. 작업 제출 (execute() vs submit())

| 메서드         | 특징                                                         | 용도                           |
|----------------|-------------------------------------------------------------|--------------------------------|
| execute(Runnable) | 결과 반환 없음, 예외 정보 전달 X, 정상 종료 여부 확인 불가 | 결과가 중요하지 않은 단순 작업 |
| submit(Runnable/Callable) | Future 객체 반환, 결과/예외 추적 가능                  | 결과/예외 추적 필요한 작업     |

### 6. 실행 종료 처리 (shutdown() vs shutdownNow())

- **shutdown()**: Executor 종료 요청, 큐에 있는 작업 모두 완료 후 종료 (권장)
- **shutdownNow()**: 대기 중인 작업 취소, 실행 중인 스레드에 인터럽트 요청 (강제 종료 필요 시)

