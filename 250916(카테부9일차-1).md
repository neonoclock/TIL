## **🧠 회고**

오늘은 Thread, Runnable, Executor에 대하여 학습하였다.

이해하는 데 어렵지만... 어려운만큼 열심히 해야겠다는 다짐을 했다.

그리고 오늘 멘토링을 하였는데 팀원분들이 질문을 너무 잘해주셔서 많이 배우고 분위기도 좋았다 ...🥺

덕분에 얻어가는 것도 많았고 다음에는 나도 질문을 할 수 있도록 노력을 ㅠㅠ... (아직 질문하는게 쉽지 않음...)

## **🪽 오늘의 다짐**

1.  CS 공부하기
2.  시간 활용 잘하기
3.  복습 꼼꼼히 하기
4.  코드 예시 실습하기

---

## **📝 Yesterday I Learned (어제 정리 못한 부분 마저 정리!)**

### **1️⃣  제너릭 (Generic(<T>))**

#### **1\. 정의**

\- 데이터 타입을 클래스나 메서드가 사용할 때까지 지정하지 않고, 나중에 지정할 수 있도록 해주는 타입 매개변수 문법

\- 특정 자료형에 의존하지 않고, 코드 작성 시점에는 타임을 정하지 않은 채로 작성

   👉🏻 객체를 생성하거나 메서드를 호출할 때 구체적인 타입을 지정할 수 있게 함

\- 타입을 변수처럼 취급

   👉🏻 다양한 타입에 대해 동일한 코드 구조를 재사용할 수 있도록 함

\- 자바 컴파일러가 타입 검사를 더 엄격하게 할 수 있게함

   👉🏻 타입 안정성 보장

   👉🏻 잘못된 형변환이나 런타임 오류 예방하는데 도움

> **❓ ClassCastException**  
> 잘못된 타입 변환을 시도할 때 발생하는 오류

#### **2\. 사용 방법**

\- 클래스나 메서드 이름 옆에 <T>를 선언하고, 사용할 때 구체적인 타입을 지정

**(1) 기본 문법**

```
public class 클래스이름<T> {
	private T 변수명:
    
    public 클래스이름(T 매개변수) {
    	this.변수명 = 매개변수;
    }
    
    public T 메서드이름() {
    	return this.변수명;
    }
}
```

**(2) 메서드에 사용하는 제네릭**

\- 클래스 전체가 아니라, 특정 메서드에서만 사용할 수도 있음

\- 메서드 선언부 앞에 <T> 붙여 타입 매개변수 지정

\- 따로 형변환 하지 않아도 됨

\- 하나의 메서드로 다양한 타입을 유연하게 처리 가능

**(3) 인터페이스에서 제네릭 사용**

\- 인터페이스에 <T> 선언

  👉🏻 그 인터페이스를 구현하는 클래스에서 구체적인 타입 지정

**(4) 여러 타입 매개변수 사용**

\- 필요하다면 두 개 이상의 타입 매개변수도 동시에 선언 가능

\- 동일한 클래스 구조를 유지하면서도 다양한 정보의 조합을 표현할 수 있음

\- 유연하고 재사용 가능한 설계

---

### **2️⃣  와일드카드 (? extends / super)**

#### **1\. 정의**

\- 제네릭 타입을 사용할 때, 구체적인 타입을 명시하지 않고 어떤 타입이든 가능한 것을 표현하거나 특정 범위 안에서만 허용되도록 제한할 수 있는 문법 요소

\- 제네릭 타입 표현을 유연하게 하기 위한 문법적 장치

\- 자바의 타입 시스템에서 구체적인 타입을 명시하지 않고도 타입을 일반화할 수 있게 해줌

| ? | \- 불특정한 어떤 타입이든 허용하는 의미   \- 타입에 관계없이 모든 제네릭 객체를 참조할 수 있도록 표현 |
| --- | --- |
| ? extends T | \- T타입 또는 그 하위 타입만 허용   \- 주로 데이터를 읽기 전용으로 사용할 떄 사용 |
| ? super T | \- T타입 또는 그 상위 타입만 허용   \- 주로 안전하게 데이터를 추가(쓰기)할 수 있도록 할 때 사용 |

#### **2\. 사용 이유**

\- 다양한 타입을 유연하게 다룰 수 있도록 하기 위해서

\- 정확한 타입을 몰라도 공통된 구조로 다양한 제네릭 타입을 처리할 수 있도록 코드 작성 가능

#### **3\. 사용 방법**

\- 제네릭 타입의 구체적인 타입 대신 ?, ? extends, ? super를 사용해 타입의 범위를 일반화하거나 제한

**(1) 기본 문법**

```
<?>  // 모든 타입 허용 
<? extends T> //T와 그 하위 타입만 허용 (상위 제한)
<? super T> //T와 그 상위 타입만 허용 (하한 제한)
```

-   **<?>**
    -   모든 타입 허용
    -   가장 일반적인 형태
    -   구체적인 타입을 알 필요는 없지만 어떤 타입의 객체든 받아야할 때 사용
    -   List<Integer>, List<String> 등 어떤 타입의 리스트든 인자로 받기 가능
    -   단, 구체적인 타입이 명확하지 않기 때문에 리스트에 요소를 추가하는 것은 허용되지 않음
-   **<? extends T>**
    -   상한 제한 
    -   T 타입 또는 그 하위 타입만 허용
    -   읽기 전용에 적합한 형태
    -   List<Integer>, List<Double> 등을 받을 수 있음
    -   요소를 읽을 수는 있지만 새로운 값을 추가는 못함
        -   리스트가 실제로 어떤 하위 타입인지 알 수 없기 때문
-   **<? super T>**
    -   하한 제한
    -   T 타입 또는 그 상위 타입만 허용하되, 쓰기(추가)에 적합한 구조
    -   List<Integer>, List<Number>,List<Object> 등을 받을 수 있음
    -   그 안에 Integer 타입의 값을 안전하게 추가 가능
    -   단, 읽어올 때는 Object 타입으로 처리해야하므로 타입 정보는 제한

---

### **3️⃣ 컬렉션 인터페이스 - List**

> ❓ 컬렉션 인터페이스  
> \- 자바에서 데이터의 집합을 다루기 위한 표준 구조를 정의한 상위 타입  
> \- List, Set 같은 자료구조는 모두 이 인터페이스를 구현  
> \- 요소 추가, 삭제, 검색 등의 공통 기능을 일관된 방식으로 사용할 수 있도록 해줌

#### **1\. List의 정의**

\- 순서가 유지되며, 중복을 허용하는 요소의 집합을 표현하는 컬렉션 인터페이스

\- 컬렉션 인터페이스

-   데이터를 모아서 저장하고 관리하기 위한 구조이 상위 개념
-   List와 같은 자료구조는 이 인터페이스를 통해 공통된 방식으로 처리됨
-   요소 추가, 삭제, 검색 등 기본 동작 정의
-   자료형에 관계없이 사용 가능

**(1) List**

\- Collection 인터페이스를 상속

\- 각 요소는 0부터 시작하는 인덱스를 가지며 위치 기반으로 접근, 삽입, 삭제 가능

\- 요소를 추가한 순서대로 저장

\- 동일한 값이 여러 번 들어갈 수 있음

\- 필요한 경우 특정 위치의 요소를 조회하거나 교체할 수 있는 구조 제공

\- 구현체

-   **ArrayList**
    -   내부적으로 배열을 기반
    -   인덱스를 통한 요소 접근 속도가 빠름
    -   중간에 데이터를 삽입하거나 삭제할 때 요소 이동이 필요하여 성능 떨어짐
-   **LinkedList**
    -   노드 기반의 연결 구조 사용
    -   데이터 삽입, 삭제 빠름
    -   원하는 위치에 접근하려면 순차 탐색 필요 -> 접근 속도 느림
-   **Vector**
    -   ArrayList와 거의 동일한 구조이지만, 동기화를 기본으로 제공하기에 멀티스레드 환경에서 스레드 안전하게 동작

> **❓ 동기화**  
> \- 여러 스레드가 동시에 하나의 객체나 메서드에 접근할 때, 데이터 충돌 없이 순차적으로 처리되도록 제어하는 것

#### **2\. 사용 이유**

\- 순서가 있는 데이터를 유연하게 저장하고 처리

\- 구현체와의 결합을 최소화

\- List 인터페이스

-   요소의 저장 순서를 유지하면서 중복을 허용하는 컬렉션이 필요할 때 가장 적합

\- ArrayList, LinkedList 등 다양한 구현체가 존재하더라도 List 타입으로 작성하면

   👉🏻 구현체를 바꾸지 않고도 동일한 방식으로 처리 가능

   👉🏻 코드의 유연성과 유지보수성 높일 수 있음

#### **3\. 사용 방법**

\- 순서가 있는 데이터를 인덱스를 기준으로 추가, 조회, 수정, 삭제하는 방식으로 사용

**(1) 기본 문법**

\- 변수 타입은 List로 선언

\- 오른쪽에서 구현체로 객체 생성

```
List<타입> 변수명 = new 구현체<>();
```

-   **요소 추가 - add(E e)**
    -   리스트 끝에 새로운 요소 추가
-   **요소 삽입 - add(int index, E e)**
    -   지정한 위치에 요소 삽입
    -   기존 요소들은 뒤로 밀려남
-   **요소 조회 - get(int index)**
    -   리스트에서 특정 위치에 있는 요소 반환
-   **요소 수정 - set(int index, E e)**
    -   지정한 위치의 요소를 새로운 값으로 바꿈
-   **요소 삭제 - remove(int index)**
    -   해당 인덱스 위치의 요소 제거
-   **요소 포함 여부 확인 - contains(Object o)**
    -   리스트에 특정 값이 포함되어 있는지 확인
-   **요소 개수 확인 - size()**
    -   현재 리스트에 저장된 요소의 개수 반환
-   **리스트 비어 있는지 확인 - isEmpty()**
    -    리스트가 비어 있는지 확인
-   **리스트 비우기 - clear()**
    -   리스트에 있는 모든 요소 제거
-   **요소의 위치 찾기 - indexOf(Object o)**
    -   지정한 값이 처음 등장하는 인덱스 반환
    -   없으면 -1
-   **부분 리스트 반환 - subList(int fromIndex, int toIndex)**
    -    원래 리스트의 일부분을 잘라 새 리스트처럼 반환
    -   끝 인덱스는 포함 X

---

### 4️⃣ 컬렉션 인터페이스 - Set

#### **1\. 정의**

\- 중복을 허용하지 않고, 순서를 보장하지 않는 요소들의 집합을 표현하는 컬렉션 인터페이스

\- 요소의 추가, 삭제, 탐색 등 기본 기능을 제공하면서도 중복 값 자동 제거

\- 요소 간의 저장 순서 보장 X

\- equals(), hashCode() 메서드를 기준으로 유일성 판단

\- 같은 값은 여러 번 저장하려고 해도 한 번만 유지되는 구조

> **❓ equals()**  
> \- 두 객체가 논리적으로 같은 값인지를 비교하는 메서드  
> \- 논리적: 객체의 생성 시점이나 참조와 무관하게, 객체가 의미하는 정보가 같으면 동일하다고 간주하는 것

> **❓ hashCode()**   
> \- 객체를 해시 기반 자료구조에서 사용할 때 정수 값을 반환하는 메서드  
> \- 객체가 어느 위치(버킷)에 저장될지를 결정  
> \- 버킷: 해시 기반 자료구조 내부에서 데이터를 저장하는 실제 공간 (슬롯)

\-> Set, Map과 같은 컬렉션에서 객체를 올바르게 비교하고 저장하기 위해 반드시 함께 재정의 해야 함

\-> 두 메서드는 항상 함께 오버라이딩해야 컬렉션에서 정확하게 작동

\=> 그렇지 않으면 동일한 값인데도 중복으로 인식되지 않거나, 검색 실패 가능

#### **2\. 사용 이유**

\- 중복 없는 데이터를 저장하고 , 순서보다 유일성이 중요한 상황에서 간결하게 처리하기 위해

#### **3\. 사용 방법**

```
Set<타입> 변수명 = new 구현체<>();
```

**(1) 요소 추가 - add(E, e)**

\- 집합에 새로운 요소 추가

\- 동일한 요소가 존재하면 추가되지 않음

**(2) 요소 포함 여부 확인 - contains(Object o)**

\- 지정한 요소가 집합에 포함되어 있는지를 확인

**(3) 요소 삭제 - remove(Object o)**

\- 지정한 요소가 존재하면 집합에서 제거

**(4) 요소 개수 확인 - size()**

\- 현재 집합에 저장된 요소의 개수 반환

**(5) 집합 비우기 - clear()**

\- 집합의 모든 요소 제거

**(6) 집합이 비어 있는지 확인 - isEmpty()**

\- 집합이 비어 있는지를 true, false로 반환

**(7) 전체 요소 순회 - 향상된 for문**

\- Set은 인덱스가 없기에 일반적인 for문 대신 향상된 for문을 사용해 요소 순회

💡 Set은 저장된 순서를 보장하지 않기에, 출력 순서가 입력 순서와 다를 수 있음

---

### **4️⃣ 컬렉션 인터페이스 - Map**

#### **1\. 정의**

\- 하나의 키(key)에 하나의 값(value)를 대응시켜 저장하는 구조를 제공하는 컬렉션 인터페이스

\- 값을 추가하거나 검색, 삭제할 때 항상 키를 기준으로 작업 이루어짐

\- 키를 모르면 해당 값을 직접 접근할 수 없음

#### **2\. 주요 Map 구현체**

**(1) HashMap**

\- 가장 일반적으로 사용

\- 내부적으로 해시 테이블을 기반으로 동작

\- 데이터를 저장할 때, 먼저 키 객체의 hashCode() 메서드를 호출하여 정수형 해시값을 생성

   👉🏻이 해시값은 내부 배열의 크기를 기준으로 계산

   👉🏻 어떤 인덱스(버킷 위치)에 데이터를 저장할지 결정

> **❓ 해시 테이블**  
> \- 키를 해시 함수로 정수값(해시값)으로 바꾼 뒤, 이 값을 이용해 배열의 인덱스를 계산하고 데이터를 저장하는 자료 구조  
> \- 키를 직접 저장하지 않고, 그 키가 어디에 저장되어야 하는지를 계산해서 배열의 특정 위치에 저장

> **❓ 해시 충돌**  
> \- 서로 다른 키가 동일한 해시코드를 가질 수 있는 상황

\- Hashmap은 해시 충돌을 해결하기 위해 체이닝 방식 사용

> **❓ 체이닝(Chaining)**  
> \- 같은 버킷 인덱스에 여러 개의 키-값 쌍이 저장될 수 있도록 연결 리스트를 구성하는 방식

**(2) LinkedHashMap**

\- Hashmap과 동일하게 해시 테이블을 기반으로 동작하지만, 요소 간의 삽입 순서를 유지할 수 있도록 내부적으로 연결 리스트를 함께 사용

\- 데이터를 저장할 때마다, 그 입력 순서대로 요소들이 이중 연결 리스트로 연결

\- 순회 시에도 입력된 순서대로 꺼낼 수 있음

**(3) TreeMap**

[##_Image|kage@b41J9q/btsQCtQIGPG/AAAAAAAAAAAAAAAAAAAAALnPCT4i3-WE8aOnq0tEmqvbCc8DQzjZXx0xtK8cecZ1/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1759244399&amp;allow_ip=&amp;allow_referer=&amp;signature=9YfxQFvIxoEavchnUS%2BmlfmOwPo%3D|CDM|1.3|{"originWidth":500,"originHeight":241,"style":"alignCenter"}_##]

\- 내부적으로 이진탐색트리(Red-Black Tree)를 기반으로 동작

\- 데이터를 저장할 때마다 키를 기준으로 자동 정렬

\- 기본적으로 오름차순 정렬

\- 정렬기준

-   키가 구현한 Comparable의 compareTo() 메서드
-   외부에서 전달된 Comparator 객체

> **❓ 키가 구현한 Comparable의 compareTo() 메서드? 외부에서 전달된 Comparator 객체?**  
> \- TreeMap은 데이터를 정렬하기 위해 키끼리의 크기 비교가 가능해야 함  
>   👉🏻 기준: Comparable, Comparator  
>   
> **Comparable**  
> \- 키 클래스 자체가 정렬 기준을 구현하는 방식  
> \- 키 클래스에 compareTo()메서드 정의 -> 두 키를 비교해 정렬 순서 결정  
>   
> **Comparator**  
> \- 정렬 기준을 외부에서 따로 정의해서 전달하는 방식  
> \- 키 클래스 내부를 수정하지 않아도, 원하는 기준(내림차순, 길이순 등)으로 정렬 가능

\- 구조

-   루트 노드는 항상 검정색
-   빨간색 노드의 자식은 반드시 검정색
-   모든 리프 노드(NIL)는 검정색으로 간주
-   루트에서 모든 리프까지의 경로에는 같은 수의 검정 노드가 있어야 한다

> **❓ 리프노트 (NIL)**  
> \- 더 이상 자식 노드가 없는, 트리의 가장 끝에 위치한 노드

 👉🏻 이러한 구조 덕분에 삽입, 삭제가 일어날 때도 자동으로 트리를 재조정하며 항상 균형잡힌 상태 유지 -> 검색 성능 보장

\- O(log n)

#### **3\. 사용 방법**

\- 키를 기준으로 값을 저장, 조회, 수정, 삭제하는 방식

**(1) 기본 문법**

```
Map<키타입, 값타임> 변수명 = new 구현체<>();
```

-   **요소 추가 또는 수정 - put(K key, V value)**
    -   새로운 키-값 쌍 저장
    -   해당 키가 이미 존재한다면, 기존 값이 새 값으로 덮어쓰기 됨
-   **값 조회 - get(Object key)**
    -   지정한 키에 연결된 값 반환
-   **키/값 존재 여부 확인 - containsKey(), containsValue()**
    -   containsKey(): 특정 키가 존재하는지를 확인
    -   containsValue(): 지정한 값이 저장되어 있는지를 검사
-   **요소 삭제 - remove(Object key)**
    -   지정한 키에 해당하는 데이터를 삭제
    -   키가 존재하지 않으면 아무일도 일어나지 않음
-   **크기 확인 및 전체 삭제 - size(), clear(), isEmpty()**
    -   size(): 저장된 요소의 개수 반환
    -   clear(): Map을 완전히 비움
    -   isEmpty(): 요소가 하나도 없는지를 확인
-   **전체 순회 - KeySet(), enrtySet()**
    -   KeySet(): 키만 순회, 각 키로 값을 조회해야 함
    -   enrtySet(): 키와 값을 동시에 다룰 수 있어 더 효율적
