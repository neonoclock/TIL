## **🧠 회고**

오늘은 스레드 풀, Synchronized, Lock, volatile, Atomic Type, ReentrantLock에 대해 학습했다.

이해가 되면서도 막상 내 언어로 말한다는 것이 어려웠다... 아직 누군가가 이게 뭐야?라고 물어보면 선뜻 답하지는 못할 듯 ㅠㅠ (더 열심히 하자)

그리고 저녁먹고 혈당스파이크와서(...) 잠깐 잔다는게 2시간이 지나있었다... (수요일이라 쌓인 피로가 누적된 것도 한 몫 할 듯..)

규칙적인 생활을 하고 저녁먹고 러닝이라도 나가야 할 필요성을 느꼈다... 운동을 합시다 (제발)

[https://techblog.woowahan.com/17416/](https://techblog.woowahan.com/17416/)

## **🪽 오늘의 다짐**

1.  새벽 1시 30분 이전에 자기
2.  식곤증 이겨내기
3.  암기가 아닌 깊은 이해로

---

## **📝 Today I Learned**

### **1️⃣  Thread Pool**

#### **1\. 정의**

\- 작업을 처리하기 위한 스레드를 매번 새로 생성하지 않고, 미리 만들어 둔 스레드 집합을 재사용하여 작업을 처리하는 구조

\- 스레드를 필요할 때마다 생성하고 제거하는 방식이 아니라, 미리 지정된 수의 스레드를 풀 안에 유지하면서, 요청된 작업을 이들 스레드가 차례로 받아 실행하도록 설계된 실행 환경

\- 작업대기열 (BlockingQueue)과 함께 동작

\- 작업이 들어오면 대기열에 저장

   👉🏻 유휴 상태의 스레드가 해당 작업을 꺼내 실행

   👉🏻 작업이 끝난 스레드는 제거되지 않고 다시 풀로 돌아가 다음 작업 기다림

> **❓ 유휴 상태**  
> \- 컴퓨터나 프로그램이 실행 중이지만 작업이나 데이터를 적극적으로 처리하지 않는 상태  
> \- 사용자나 다른 프로그램의 입력을 기다리는 중이거나 현재 수행할 작업이 없기 때문

#### **2 . 사용 이유**

\- 스레드를 매번 생성하지 않고 재사용함으로써 시스템 자원을 효율적으로 관리하고 동시 처리량을 안정적으로 제어하기 위함

|   | **Thread 직접 생성** | **스레드 풀 사용** |
| --- | --- | --- |
| **자원 관리** | \- 스레드가 무제한 생성   \- 생성, 제거 비용 반복 발생 | 스레드 수를 제한하여 자원을 예측 가능하게 사용 |
| **시스템 부하** | 과도한 문맥 전환으로 CPU 부하 증가, 성능 저하 | 병렬 처리량을 제어해 서버 보호 |
| **작업 대기 처리** | 작업마다 스레드 생성하기에 시스템 자원 고갈 위험 | BlockingQueue로 작업을 순차 대기 및 처리 |
| **운영 추적** | 흐름 추적, 로깅, 종료 처리가 어렵고 불안정 | 스레드 이름, 작업 흐름 등을 체계적으로 관리 |
| **메모리 안정성** | OOM(Out Of Memory) 발생 가능성 증가 | 제한된 풀 내에서 스레드 재사용 |

\- 스레드 수 제한

   👉🏻 동시에 실행되는 작업량 조절

   👉🏻시스템 안정성 높임

\- 작업이 일시적으로 몰릴 경우에도, 내부 큐를 통해 작업이 순차적으로 처리

  👉🏻시스템이 갑자기 멈추는 상황 방시

\- 스레드 풀을 통해 생성된 스레드는 이름 지정, 흐름 추적, 예외 처리 등을 체계적으로 관리

   👉🏻운영 환경에서의 모니터링과 문제 분석 훨씬 쉬워짐

\- 실무

| **스레드 수와 자원 사용량 제어** | 스레드 수를 제한하여 CPU, 메모리 등 시스템 자원을 예측 가능하게 관리 가능 |
| --- | --- |
| **요청 폭주 방어** | 풀 크기와 작업 큐를 통해 갑작스러운 요청 증가 상황에서도 처리량을 조절하고 시스템 보호 가능 |
| **정책 기반 실행** | 거부 정책, 대기 정책 등을 통해 작업 처리 방식을 유연하게 설계 가능 |
| **프레임워크와 통합성** | ExecutorService, @Async, @Scheduled 등 대부분의 비동기 기능은 스레드 풀 기반으로 동작 |
| **운영 효율성 향상** | 스레드 이름, 로그, 예외 흐름을 일관된 구조로 관리하여 장애 추적과 운영 유지보수 용이 |

#### **3\. 동작 방식**

\- 작업이 제출되면 큐에 저장하고, 유휴 스레드가 이를 꺼내 실행한 뒤 제거하지 않고 재사용

**(1) 애플리케이션이 작업을 제출함**

**(2) 작업이 Queue에 저장됨**

\- 작업 대기열 (Task Queue)에 먼저 저장

> **❓ ThreadPoolExecutor**  
> \- 스레드 풀을 직접 생성하고 제어할 수 있도록 설계된 클래스  
> \- ExecutorService의 대표 구현체  
> \- 스레드 수, 작업 큐, 거부 정책 등 세부 설정 직접 지정 가능

\- 현재 실행 중인 스레드 수가 corePoolSize보다 작다면 새로운 스레드를 생성하여 해당 작업 즉시 실행  
\- 이미 corePoolSize만큼의 스레드가 바쁘게 동작 중이라면, 추가로 들어온 작업은 큐에 저장

> **❓ corePoolSize**  
> \- ThreadPoolExecutor에서 항상 유지되는 최소한의 스레드 개수  
> \- 작업이 없어도 이 수만큼의 스레드는 생성된 상태로 풀에 남아 있음  
> \- 새로운 작업이 들어오면 먼저 이 core의 스레드들이 사용됨  
> \- corePoolSize보다 적은 스레드가 실행중이라면, 새 작업은 큐에 들어가기 전에 스레드가 먼저 만들어져 실행됨

\- 큐가 가득 찬 상태에서 새로운 작업이 도착한 경우

   👉🏻Executor는 가능한 경우에 한해 maximumPoolSize까지 스레드를 추가로 생성하여 해당 작업 처리

\- 더 이상 스레드를 생성할 수 없고, 큐도 가득찬 경우

  👉🏻 미리 설정해둔 거부 정책에 따라 해당 작업이 거부되거나, 다른 방식으로 처리됨

> **❓ MaximumPoolSize**  
> \- ThreadPoolExecutor에서 생성 가능한 스레드 수의 상한선  
> \- corePoolSize와 작업 큐가 모두 가득 찬 경우, 그 이후에 들어온 작업을 처리하기 위해 최대 이 수치까지 스레드 추가 생성 가능  
> \- 이를 초과하면 거부 정책에 따라 작업 처리

**(3) 유휴 스레드가 작업을 꺼내 실행**

\- 풀에 있는 스레드는 하나라도 유휴 상태가 되면 큐에서 작업을 꺼내 실행

\- 스레드는 작업을 실행한 후 즉시 제거되지 않고 풀로 반환되어 다음 작업 기다림

\- 다만, maximumPoolSize로 인해 추가 생성된 스레드는 일정 시간 동안 유휴 상태가 유지되면 자동으로 제거될 수 있음 (keepAliveTIme)

> **❓keepAliveTime**  
> \- ThreadPoolExecutor에서 corePoolSize를 초과하여 생성된 스레드가 유휴 상태일 때, 얼마나 오래 유지할지를 설정하는 시간값  
> \- 이 시간이 지나도록 해당 스레드가 작업을 받지 않으면 자동으로 제거되어 자원 반환

**(4) 작업이 완료되면 결과 또는 상태가 애플리케이션으로 반환됨**

\- execute()로 제출한 작업은 반환값이 없고, 단순히 작업만 끝남

\- submit()로 제출한 작업은 Future 객체를 통해 결과 조회나 예외 확인 가능

**(5) 스레드는 제거되지 않고 재사용됨**

\- 스레드는 작업을 마친 후에도 제거되지 않고 ThreadPool에 유지되며, 다음 작업 기다림

---

### **2️⃣ Synchronized**

#### **1\. 정의**

\- 여러 스레드가 동시에 공유 자원에 접근하지 못하도록 일시적으로 해당 자원에 대한 접근을 하나로 제한하는 동기화 키워드

\- 여러 스레드가 동시에 같은 메모리 공간(공유 자원)에 접근

   👉🏻 데이터 충돌, 예기치 않은 결과 발생

   👉🏻 Synchronized: 한 번에 하나의 스레드만 해당 자원에 접근할 수 있도록 제한

\- 스레드 간 충돌 없이 안전한 상태로 공유 데이터를 읽고 쓸 수 있도록 보장

\- 해당 코드 블럭 또는 메서드에 대해 하나의 스레드만 접근할 수 있는 임계영역 정의

> **❓ 임계 영역**  
> \- 공유 자원에 접근하는 프로그램 코드의 일부분  
> \- 공유 자원: 여러 사용자나 프로세스가 동시에 접근하거나 사용하는 시스템 내의 자원  
> \- 여러 스레드가 동시에 실행해서는 안되는 코드 영역  
> \- 이 영역은 하나의 스레드만 접근할 수 있도록 제한  
>    👉🏻 공유 자원에 대한 충돌이나 데이터 오류 방지

\- 스레드가 임계 영역에 진입

  👉🏻 자동으로 락 획득

   👉🏻 해당 코드 실행이 끝나면 락 반납

  👉🏻 다른 스레드가 대기 후 진입

> **❓ 락 (Lock)**  
> \- 동시에 여러 스레드가 하나의 공유 자원에 접근하지 못하도록 막는 장치  
> \- 스레드가 임계 영역에 진입할 때 락을 획득  
>    👉🏻 작업이 끝날 때까지 다른 스레드는 그 영역에 들어가지 못하게 대기

#### **2\. 사용 이유**

\- 멀티스레드 환경에서 공유 자원의 충돌을 방지하고, 실행 흐름의 안정성과 데이터의 일관성을 보장하기 위함

\- 임계 영역에 대해 한 번에 하나의 스레드만 접근할 수 있도록 제한

   👉🏻 논리적 충돌이나 예측 불가능한 실행결과 사전 방지 가능

\- 스레드 간 충돌 예방, 데이터 상태를 안정적 유지, 실행 순서 명확히 제어 가능

   👉🏻정확성이 중요한 비즈니스 로직, 공유 객체를 다루는 상황에서 매우 유용하게 작동

\- 실무

| **공유 자원 보호** | 캐시, 카운터, 파일, 컬렉션 등 여러 스레드가 동시에 접근할 수 있는 객체에 대해, 한 번에 하나의 스레드만 접근 할 수 있도록 제한 -> 충돌 방지 |
| --- | --- |
| **무증상 오류 예방** | \- 스레드 간 충돌로 인해 값이 덮어씌워지거나 꼬이는 문제가 발생해도 예외가 발생하지 않는 경우 많음     👉🏻 감지되지 않는 논리 오류를 사전에 차단 |
| **DB 접근 전 선제적 제어** | 예약 슬롯 배정, 중복 결제 차단, 사용자 단일 요청 처리 등은 DB 트랜잭션 이전에 애플리케이션 코드 레벨에서 동시 접근을 제한해야함 -> 선제적 제어 가능 |
| **정산, 배치 작업 보호** | 계좌 정산, 포인트 처리, 로그 집계 등은 순서와 정확성이 중요하기 때문에, 여러 스레드가 동시에 접근하지 않도록 임계 구역을 보호하여 이중 처리나 누락 방지 |
| **싱글톤 객체 보호** | 스프링처럼 싱글 인스턴스를 공유하는 구조에서는 여러 요청이 동시에 하나의 객체에 접근 가능   👉🏻 경쟁 조건을 막고, 객체 상태 안전하게 유지 가능 |

> **❓ 경쟁 조건**  
> 여러 개의 스레드(또는 프로세스)가 동시에 같은 자원(객체, 변수, 메모리 등)에 접근해서 값을 읽거나 쓰려고 할 때 발생하는 문제

#### **3.  사용 방법**

\- 메서드나 코드 블록에 적용하여, 공유 자원에 동시에 접근하지 못하도록 하나의 스레드만 집입할 수 있게 제한하는 방식으로 사용

**(1) 기본 형식**

\- 동기화 대상이 되는 객체(락의 기준) : this(인스턴스), 클래스 객체, 또는 명시적으로 지정한 객체 

```
// 메서드 전체에 동기화 적용
public synchronized void method() {...}

// 블록 단위로 동기화 적용
synchronized (lockObject) {
	// 임계 영역
}
```

\- 메서드에 synchronized

  👉🏻 해당 메서드 전체가 임계 영역으로 간주

  👉🏻 락은 인스턴스(this) 또는 클래스(Class 객체)를 기준으로 자동 적용

\- 블록 단위의 synchronized

  👉🏻 지정한 객체를 기준으로 락 설정

  👉🏻 여러 개의 임계 영역을 구분하거나, 특정 범위에만 동기화를 적용하고 싶을 때 사용

**(2) 인스턴스 메서드에 적용**

\- 해당 메서드 전체가 임계 영역이 됨

\- 락의 기준은 현재 객체(this)

> **❓ 락의 기준은 현재 객체(this)**  
> \- 해당 메서드나 블록이 현재 인스턴스(객체)를 기준으로 동기화 제어(락)을 건다는 의미  
> \- synchronized 인스턴스 메서드는 메서드를 호출한 객체(this)를 기준으로 한 번에 하나의 스레드만 진입할 수 있게 락을 검  
> \- 같은 인스턴스를 사용하는 모든 스레드는 한 번에 하나만 동기화 구간에 들어올 수 있음

| **synchronized method** | this 객체 전체에 락을 검 |
| --- | --- |
| **synchronized (this)** | 특정 블록에 대해서만 this 객체를 기준으로 락을 검 |
| **synchronized (lock)** | 명시적으로 만든 객체를 기준으로 락을 검 (락 분리 가능) |

**(3) static 메서드에 적용**

\- 정적 메서드에 synchronized를 선언하면, 락의 기준은 클래스 자체(Class 객체)

\- 모든 인스턴스를 통틀어 클래스 단위로 한 번에 하나의 스레드만 실행 가능

\- 적합한 경우

-   전역 설정을 변경할 때
-   클래스 차원에서 하나의 리소스를 공유할 때
-   여러 인스턴스가 동시에 접근할 수 있는 로깅 시스템 등에서 동기화가 필요할 때

**(4) 코드 블록 일부를 동기화 하는 방법 - synchronized(this)**

\- 메서드 전체가 아니라 일부 코드 블록만 임계 영역으로 설정

\- 락의 기준은 여전히 인스턴스 (this)

\- 공유 자원에 접근하는 부분만 최소화된 범위로 동기화할 수 있어 성능 최적화에 유리

> 💡 일반적으로 동기화 범위를 작고 명확한 임계영역으로 한정하는 것이 성능상 더 유리  
> 불필요하게 메서드 전체에 락을 거는 대신, 꼭 필요한 블록에만 synchronized를 사용 -> 병목 줄이는데 효과적

> **❓ 병목**  
> 여러 쓰레드나 요청이 동시에 일을 하려는데, 공유 자원에 차례대로만 접근할 수 있는 상황 때문에 전체 성능이 느려지는 현상

**(5) 명시적 객체에 락을 거는 방법 - synchronized(lock)**

\- this 대신 명시적인 객체를 기준으로 락 설정

\- 적합한 경우

-   복수의 임계 영역을 하나의 논리적 그룹으로 묶고자 할 때
-   this 객체에 락을 걸 경우 외부 클래스나 다른 동기화 구간에 충돌할 가능성이 있을 때
-   동기화 범위를 명확히 분리하고자 할 때

> 💡 여러 개의 락 객체를 동시에 사용하는 경우, 스레드가 서로 다른 순서로 락을 획득하려고 함  
>     👉🏻 데드락 발생  
> 락 획득 순서를 일관되게 유지하거나, 동시 락 획득을 피하도록 설계해야함

> **❓ 데드락**  
> 두 개 이상의 쓰레드(또는 프로세스)가 서로 자원을 점유한 채 상대방 자원을 기다리면서 무한히 멈춰버리는 상황

### **4\. 정리**

| **형태** | **대상** | **락 기준** |
| --- | --- | --- |
| **sychronized 인스턴스 메서드** | 메서드 전체 | this 객체 |
| **sychronized static 메서드** | 메서드 전체 | Class 객체 |
| **sychronized (this)**  | 블록 일부 | this 객체 |
| **sychronized (객체)**  | 블록 일부 | 지정된 객체 |

\- 여러 스레드가 공유하는 자원이 없는 경우라면 굳이 동기화 사용할 필요 없음

\- 스레드 간 상태를 공유하지 않는 구조 자체로 리팩토링하는 것이 단순한 해결책

---

### **3️⃣  Lock**

#### **1.  정의**

\- 멀티스레드 환경에서의 안전한 자원 접근을 보장하기 위해 사용하는 동기화 제어 인터페이스

\- 공유 자원에 대해 스레드가 명시적으로 락을 획득하고 해제하는 방식으로 동기화 수행

\- 기본 동기화 수단인 sychronized은 코드 블록이나 메서드 단위에 락을 자동으로 적용하고 해제

   👉🏻 Lock은 락의 적용 시점과 해제 시점, 락의 대상 객체까지도 개발자가 직접 제어할 수 있는 구조 가짐

\- 동기화 범위를 세밀하게 조절 가능

\- 락을 기다릴지 말지 결정하거나 (interruptible), 일정 시간 대기 후 포기하는 방식으로도 처리 가능

\- 단순한 상호 배제를 넘어, 공정성 설정, 조건 변수 활용, 비차단 락 시도 등 복잡한 멀티스레드 시나리오를 지원할 수 있는 구조적 유연성 제공

> **❓ 비차단 락**  
> \- 스레드가 락을 즉시 획득하지 못하면 기다리지 않고 바로 다음 로직으로 넘어가는 방식의 락 처리 기법  
> \- Lock 인터페이스의 tryLock()메서드를 사용해 구현가능  
> \- 락을 사용할 수 있는지 확인한 뒤, 가능하면 얻고 아니면 포기  
> \- 스레드가 락을 잡기 위해 무한히 대기하는 것을 방지  
> \- 필요할 경우 대기 시간 없이 다른 작업을 처리하거나 재시도할 수 있게 해줌

#### **2\. 사용 이유**

\- 멀티스레드 환경에서도 자원 접근을 정밀하게 제어하고, 안정성과 예측 가능성을 확보할 수 있기 때문

\- 멀티스레드 환경에서 자원 충돌을 방지하기 위해서는 스레드 간 동기화가 필수적

   👉🏻 Lock은 이 동기화를 단순한 보호 수준이 아닌, 유연하고 정밀한 제어를 가능하게 해주는 고급 동기화 도구

-   락을 언제 걸고 언제 풀지 개발자가 직접 결정
-   락 획득을 기다릴지 포기할지, 일정 시간만 기다릴지 등 선택 가능
-   여러 조건을 분리해서 기다릴 수 있음
-   공정하게 락을 분배하거나 특정 스레드만 우선 처리하도록 설정 가능

\- 기존 동기화 방식의 한계를 보완, 복잡한 동시성 제어를 안정적으로 구성할 수 있게 해주는 도구

#### **3\. 사용 방법**

\- lock.lock()으로 락을 획득

  👉🏻 작업을 수행하고 반드시 finally 블록에서 lock.unlock()으로 해제

**(1) 기본 형식**

\- java.util.concurrent.locks 패키지에 포함된 인터페이스

\- ReentrantLock 구현체를 통해 다음과 같은 방식으로 사용

> **❓ReentrantLock 구현체**  
> \- 한 스레드가 이미 획득한 락을 다시 획득할 수 있도록 허용하는 재진입 가능(reentrant) 락  
> \- 같은 스레드가 여러번 lock()을 호출하면 횟수만큼 락이 중첩되어 적용  
>   👉🏻 unlock()도 그에 맞춰 같은 횟수만큼 호출해야 완전히 해제  
>   👉🏻 재귀 호출이나 내부에서 다시 락이 필요한 경우에도 문제없이 사용 가능

```
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

Lock lock = new ReentrantLock();

lock.lock();
try {
	// 임계 영역
} finally {
	lock.unlock(); // 반드시 해제해야 함
}
```

\- lock()을 호출하여 락을 획득

\- unlock()을 호출하여 반드시 락 해제

\- 락 해체는 예외가 발생해도 반드시 실행되어야 하기 때문에 finally 블록 안에서 수행하는 것이 관례

> **❓ unlock()을 호출하지 않으면**  
> \- 해당 락이 영구적으로 점유되어 다른 스레드가 접근할 수 없는 교착 상태(데드락)에 빠짐  
> \- 항상 try-finally 블록을 사용해 락 해제 보장

**(2) 비차단 락 - tryLock()** 

\- 지정한 시간 동안만 락 획득을 시도

\- 획득에 실패하면 기다리지 않고 다른 로직으로 이동

\- 응답 지연이 허용되지 않는 고속도로 진입, 결제 시스템, 게임 서버 등에서 사용

\- 응답성이 중요한 시스템에서 락으로 인해 무기한 대기하는 문제 피할 수 있는 방식

**(3) 공정성 설정 - 락 요청 순서 보장**

\- ReentrantLock(true)와 같이 생성자에 true를 전달

  👉🏻 락을 먼저 요청한 스레드가 먼저 락을 획득

\- 특정 스레드가 계속해서 락을 획득하지 못하는 기아 상태 방지

> **❓ 기아 상태**  
> \- 멀티스레드 환경에서 어떤 스레드가 자원(락 등)을 계속해서 획득하지 못한 채 무한히 대기하게 되는 상황  
> \- 다른 스레드들이 우선순위가 높거나 락을 계속 점유  
>   👉🏻 특정 스레드가 계속해서 기회를 얻지 못하는 불공정한 실행 상태 발생  
> \- ReentrantLock은 공정성 옵션을 통해 락 요청 순서 보장

**(4) 조건 변수 사용 - 특정 조건 만족 시까지 대기**

\- Condition 객체 사용

\- wait(), notify()보다 더 세밀하고 명확하게 조건별 대기와 알림 분리 가능

#### **4\. ThreadLocal**

\- 스레드마다 고유하게 독립된 변수를 저장할 수 있도록 해주는 클래스

\- 동일한 ThreadLocal 인스턴스를 여러 스레드에서 참조하더라도, 각 스레드마다 서로 다른 값을 저장하고 읽어올 수 있게 해주는 구조

\- 변수 하나를 만들면, 그 변수에 대해 스레드별로 서로 다른 공간을 자동으로 분리해서 관리

\- 자바에서 하나의 프로그램이 여러 개의 스레드를 동시 실행

  👉🏻공유되는 변수에 여러 스레드가 접근하며 동시성 문제 (경합, 교착)가 발생가능

  👉🏻 ThreadLocal: 스레드마다 독립된 값을 갖기 때문에 동기화 없이도 스레드 안전하게 데이터 저장하고 사용 가능

> **❓스레드 안전**  
> \- 여러 스레드가 동시에 같은 자원(변수, 객체)에 접근해도, 데이터가 꼬이거나 잘못된 결과가 발생하지 않도록 안전하게 처리되는 상태  
> \- 여러 스레드가 동시에 실행될 때도 프로그램의 동작과 결과가 항상 일관되고 예측 가능하게 유지되는 것

예시: 자동차 정비소에서 각 차량이 자기만의 정비 일지를 따로 가지고 있는 것

---

### **4️⃣  volatile**

#### **1\. 정의**

\- 변수의 값을 모든 스레드가 항상 메인 메모리에서 직접 읽고 쓰도록 보장하는 키워드

\- 일반적으로 자바 프로그램은 성능을 높이기 위해, 변수 값을 CPU 내부 캐시에 복사해두고 각 스레드가 해당 값을 빠르게 읽어옴

  👉🏻 각 스레드가 서로 다른 복사본을 가지고 작업하는 문제 유발

  👉🏻가시성 문제

  👉🏻 volatile 키워드 사용하면 구조적 해결 가능

\- volatile 키위드가 붙은 변수는 항상 메인 메모리에서 직접 읽고 쓰도록 강제

\- 어떤 스레드가 값을 변경하면 즉시 메인 메모리에 반영

\- 다른 스레드들도 변경된 최신 값을 즉시 읽게 됨

#### **2\. 사용 이유**

\- 스레드 간의 변수 변경 내용을 즉시 공유하고, 값의 최신 상태를 예측 가능하게 유지하기 위함

-   변수의 값이 변경될 때, 그 변경 내용은 즉시 메인 메모리에 반영되며, 다른 모든 스레드는 항상 메인 메모리로부터 최신 값을 읽음
-   스레드 간의 상태 변경 실시간 반영
-   값을 기준으로 조건을 분기하거나 종료 여부를 판단하는 실행 흐름도 예측 가능하게 유지 가능
-    락을 사용하지 않고도 변수의 값 자체는 일관성을 보장받을 수 있으므로 코드 간단해짐, 성능에도 부담 적은 구조

\- 복잡한 동기화가 필요없는 단순한 상태 전파나, 제어 흐름 제어에 매우 효과적인 수단

> **❓ 가시성 문제**  
> \- 멀티스레드 환경에서는 하나의 변수 값을 여러 스레드가 동시에 접근하는 상황이 매우 자주 발생  
>    👉🏻 자바는 기본적으로 성능을 높이기 위해, 공유 변수의 ㄱㅂㅅ을 각 스레드가 자신만의 CPU 캐시에 복사해두고 사용  
>   👉🏻 읽기 속도를 높이는 데에는 효과적  
>   👉🏻 BUT 한 스레드에서 변수 값을 변경하더라도 다른 스레드는 여전히 이전 값을 사용하게 되는 문제 발생  
>   👉🏻 스레드마다 서로 다른 값을 보고 판단  
>   👉🏻 실행 흐름이 꼬이거나 루프가 종료되지 않는 등 의도치 않은 동작 발생  
>   👉🏻이 문제가 예외나 오류로 드러나지 않음  
>    👉🏻 테스트 환경에서는 잘 동작하더라도 실제 운영환경에서 무증상 장애로 이어짐

\- 가시성 문제를 구조적으로 방지하기 위해 사용

-   이 키워드가 붙은 변수는 모든 읽기와 쓰기를 반드시 메인 메모리에서 수행하도록 강제
-   스레드가 해당 변수에 접근할 때 CPU 캐시에 있는 복사본을 사용하는 것이 아니라, 항상 메인 메모리에 접근하여 값을 읽고 씀
-   한 스레드에서 값을 변경하면 그 변경 내용이 즉시 메모리에 반영
-   다른 스레드도 같은 메모리 위치에서 값을 읽기 때문에 모든 스레드가 항상 동일하고 최신의 값을 공유

\- 스레드 간 값 불일치 문제를 원천적으로 차단 가능

\- 값이 바뀌었다는 사실을 모든 스레드가 정확하게 감지할 수 있기 때문에 상태 전파, 루프 종료, 초기화 플래그 처리 등과 같은 간단하지만 민감한 동기화에 효과적으로 대응 가능

\- 실무

| **플래그 변수(루프 중단, 초기화 완료 등)** | 상태 변경이 발생했음을 모든 스레드가 즉시 감지할 수 있도록 하기 위해 |
| --- | --- |
| **락 없이 값만 읽고 쓸 때** | synchronized보다 가볍고 간단한 방식으로 가시성만 보장할 수 있기 때문 |
| **값 변경은 단순하지만, 전파가 중요할 때** | 연산 자체는 단순하지만, 즉각적인 반영이 중요한 경우 (캐시 무효화, 재시작 여부) |
| **프레임워크 내부에서 경량 동기화용** | Spring, Netty, Scheduler 등 내부에서 상태 감시용으로 적극 활용됨 |

> **❓ 플래그 변수**  
> 프로그램의 특정 상태를 나타내는 불리언 값으로, 실행 흐름 제어나 조건 분기에 사용

#### **3\. 사용 방법**

\- 변수 선언 시 volatile 키워드를 함께 사용하며, 해당 변수에 대한 읽기/쓰기를 메인 메모리 기준으로 강제

```
private volatile 타입 변수명;
```

|   | **volatile 사용 안함** | **volatile 사용 함** |
| --- | --- | --- |
| **값 변경 전파** | CPU 캐시에 남아 최신 값 반영 안 됨 | 메인 메모리로 바로 반영됨 |
| **실행 결과** | 루프가 끝나지 않음 (무한 실행 | 루프 정상 종료 |
| **가시성 보장** | 불가 | 가능 |

#### **4\. 실제 사용 사례**

\- 하나의 스레드가 값을 변경하고, 다른 스레드가 그 값을 빠르게 감지해야 하는 "플래그 변수"를 다룰 때 적합

**(1) 사용하기 좋은 실제 사례**

\- 스레드 종료 신호 전달

-   예: while (runnning) {...} 루프 종료 조건으로 사용되는 running 변수
-   volatile boolean running = true;
-   메인 스레드가 running = false; 로 변경
    -   작업 스레드가 즉시 감지해야 할 떄

\- 캐시된 값이 아닌 최신 상태가 반드시 필요한 상태 값 공유

-   예: 설정값 변경, 상태 플래그 (shutdown, paused, started 등)

\- 읽기, 쓰기 모두 단순하고 원자성이 보장되는 타입

-   boolean, int, long (64비트는 주의), referebce 등 간단한 타입만

**(2) 사용하지 말아야 할 경우**

\- 복잡한 연산

   👉🏻 원자성 보장 안됨

\- 여러 변수 간 불변 관계가 있는 경우

\- synchronized 블록 또는 AtomicXXX, Lock이 더 적절한 경우

> **❓ 원자성**  
> \- 연산이 중단 불가능한 단일 단위로 수행되는 성질  
> \- count++ 같은 연산은 원자적이지 않아 경쟁 조건이 발생  
>   👉🏻 synchronized나 Atomic 클래스 사용

---

### **5️⃣  Atomic Type**

#### **1.  정의**

\- 멀티 스레드 환경에서 경쟁 조건 없이 값의 읽기/쓰기/수정이 가능하도록 설계된 타입

> **❓ 왜 경쟁 조건 없이 안전한가**  
> \- Atomic 타입은 내부적으로 CAS (Compare-And-Swap) 연산을 사용  
>   👉🏻 스레드 간 경쟁 조건 없이 안전하게 동작

> **❓ CAS (Compare-And-Swap)**  
> \- 현재 값이 예상 값과 같을 때만 새 값으로 변경하는 원자적 연산  
> \- 변수가 기대한 값과 현재 값이 같은지 비교한 뒤, 같으면 새 값으로 바꾸는 원자적 연산  
> \- 락을 걸지 않고도 동시에 여러 스레드가 안전하게 값을 수정할 수 있게 해줌  
> \- CPU의 하드웨어 명령 수준에서 처리  
> \- 동기화 없이도 정확하게 작동  
> 👉🏻 여러 스레드가 동시에 값을 읽고 쓰더라도 충돌 없이 안전하게 변경 가능

#### **2\. 사용 이유**

\- 멀티스레드 환경에서 동기화 없이도 안전하게 값을 조작하기 위함

\- 멀티스레드 환경에서 변수에 대한 안전한 연산을 락 없이 처리 가능

\- synchronized, Lock 사용하면 성능 저하나 데드락 가능성 존재

  👉🏻 Atomic Type은 내부적으로 CAS 알고리즘을 통해 원자성 보장

\- 동기화 비용 없이도 스레드 간 충돌 없이 안전하게 값을 증가, 감소, 설정 가능

\- 주로 카운터, 플래그, 상태 토글 같은 단일 변수 조작 작업에서 높은 성능과 안정성 동시 확보 가능

\- 경쟁 조건을 피하면서도 가볍고 효율적인 스레드 안전 연산이 필요한 경우 적합

#### **3\. 사용 방법**

\- 주로 incrementAndGet()과 같은 메서드를 통해 연산 수행

\- 멀티스레드 환경에서 공유 자원의 값을 안전하게 수정하려면 경쟁 조건을 방지해야 함

   👉🏻 AtomicInteger은 이러한 목적을 위해 제공되는 원자성을 보장하는 클래스

   👉🏻 내부적으로 CAS 방식으로 동작

   👉🏻 Synchronized 키워드 없이도 성능과 안정성 모두 확보

#### **4\. 다른 기술과 비교**

\- Synchronized와 Lock은 멀티 스레드 환경에서 공유 자원에 대한 동시 접근을 제어하여 일관성을 보장하는 동기화 도구

|   | **Atomic Type** | **Synchronized / Lock** |
| --- | --- | --- |
| **성능** | 빠름 (락 없이 처리) | 느림 (락 획득/해제에 따른 성능 손실 발생) |
| **사용 대상** | 단일 변수 또는 단순 상태 | 복잡한 객체 상태, 여러 변수 |
| **표현 방식** | \- AtomicInteger   \- compareAndSet() | \- synchronized 키워드   \- ReentrantLock |
| **적용 속도** | 카운터, 플래그, 조건부 상태 변경 등 | 임계 구간 전체 보호, 복합 로직 |
| **특징** | Non-blocking 방식(비차단), CAS 기반 | Blocking 방식 (차단), 코드 흐름 직관적 |

---

### **6️⃣  ReentrantLock**

#### **1\. 정의**

\- 동일한 스레드가 여러 번 안전하게 진입할 수 있는 락

\- 같은 스레드가 이미 획득할 수 있도록 허용하는 락 구현체

\- 하나의 스레드가 메서드 A에서 락을 획득한 상태에서, 내부적으로 메서드 B를 호출했고, 메서드 B도 같은 락을 요구하더라도 해당 스레드는 락 다시 획득 가능

\- 이 특성이 없다면 같은 스레드가 자기 자신에게 막혀 데드락 발생

#### **2\. 사용 이유**

\- 동일한 스레드가 여러 번 안전하게 락을 획득할 수 있도록 보장

\- 명시적이고 정교한 동기화 제어를 위함

\- synchronized 키워드보다 더 정밀한 락 제어 필요한 경우 사용

   👉🏻 중첩된 락 획득이 필요한 상황, tryLock(), lockInterruptibly() 같은 유연한 락 전략이 필요할 때 유용

\- 동일한 스레드가 이미 획득한 락을 다시 요청할 경우 예외 없이 재진입 허용

\- 명시적으로 lock(), unlock() 제어 가능

  👉🏻 락 해제 시점을 유연하게 관리 가능

\- 복잡한 동기화 시나리오가 요구되는 고성능 멀티스레드 환경에서 자주 사용됨

#### **3\. 사용 방법**

\- lock()으로 락을 획득하고, unlock()으로 반드시 해제하는 방식

-   ReentrantLock() 객체를 생성한 뒤, lock() 메서드로 임계 구역 진입 시도
-   락을 획득한 스레드만 임계 영역 코드 실행 가능
-   작업이 끝난 후에는 반드시 unlock() 호출
-   try-finally 구문을 활용해 예외 발생 시에도 락 해제를 보장
-   tryLock()은 대기 없이 락을 시도
-   lockinterruptibly()는 인터럽트 대응이 필요한 경우 사용
-   락은 공유 자원에 대한 상호 배제를 명시적으로 제어하기 위해 코드 흐름에 따라 유연하게 사용

**(1) tryLock() - 비차단 락 (즉시 시도 후 실패 가능)**

\- 락을 얻지 못한 객체는 기다리지 않고 포기

\- 응답 지연을 허용하지 않는 상황 (실시간 처리 등)에 매우 유용

**(2) lockInterruptibly() - 인터럽트 대응 락**

\- 락을 기다리는 도중 interrupt()가 호출되면 예외를 던지고 빠져나옴

\- 긴 대기시간이 발생할 수 있는 락 상황에서 중단이 필요한 경우 활용

#### **4\. 다른 기술과의 비교**

**(1) synchronized**

\- 단순한 구조에서 편리하게 사용

**(2) ReentrantLock**

\- 복잡한 동기화 조건, 정밀한 락 제어, 스레드 인터럽트 대응, 락 시도/포기 흐름 분기 등의 상황에서 유연하고 명시적으로 동작하도록 설계된 동기화 도구

|   | **synchronized** | **ReentrantLock** |
| --- | --- | --- |
| **락 획득 방법** | 자동 (블록 진입 시 획득) | 명시적 (lock(), unlock() 사용) |
| **락 해제 방법** | 자동 (블록 종료 시 해제) | 명시적 (unlock() 호출 필요) |
| **락 획득 대기 중 인터럽트 처리** | 불가능 (인터럽트 무시) | 가능 (lockInterreptuptibly() 사용 가능) |
| **락 획득 시도 및 실패 처리** | 불가능 | 가능 (newCondition()으로 세분화 가능) |
| **조건 변수 (Condition) 사용** | 불가능 (wait/notify만 사용 가능) | 가능 (newCondition()으로 세분화 가능) |
| **공정성 (FIFO 보장) 설정** | 불가능 | 가능 (new ReentrantLock(true)) |
| **재진입 가능 여부** | 가능 | 가능 |

#### **5\. 왜 ReentrantLock이 더 정밀한가?**

**(1) 명시적 제어 가능**

\- synchronized는 진입과 동시에 락 획득, 블록을 빠져나올 때 자동으로 해제

\- ReentrantLock은 락 획득과 해제를 코드로 직접 제어 가능, 더 복잡한 조건에서의 락 처리나 분기 처리 가능

**(2) 락 획득 실패 처리**

\- synchronized는 락을 획득할 때까지 무조건 대기

\- ReentrantLock은 tryLock()을 통해 락을 획득하지 못한 경우 대기하지 않고 우회 처리 가능

**(3) 인터럽트 가능 제어** 

\- synchronized는 락 대기 중 인터럽트 무시

\- ReentrantLock은 lockInterreuptibly()는 락 대기 중에도 스레드 인터럽트 처리를 할 수 있는 유일한 락 방식

**(4) 다중 조건 변수 지원**

\- synchronized는 wait(), notify(), notifyAll()만 제공되며 구분 없이 브로드캐스트 됨

\- ReentrantLock은 Condition 객체를 통해 여러 조건을 개별적으로 제어
