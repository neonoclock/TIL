## **🧠 회고**

오늘은 파일 입출력, 스트림, 직렬화, Reflection, 람다, Optional에 대하여 학습하였다.

개념은 조금 이해 가는데 완전히 이해가 가는 것이 아니라... 코드를 작성해보고 실습 과제도 진행해보아야겠다.

우선 스레드를 정복하는 것이 중요하니..!! 스레드를 완벽하게 숙지한 후 이 부분을 다시 봐야겠다. 파이팅...

내일 딥다이브 준비도 파이팅

## **🪽 오늘의 다짐**

1.  새벽 1시 30분 이전에 자기
2.  식곤증 이겨내기
3.  저녁먹고 30분 산책

---

## **📝 Today I Learned**

### **1️⃣  File I/O**

#### **1\. 정의**

\- 파일을 대상으로 데이터를 읽고 쓰는 입력(Input)과 출력(Output) 처리 방식

\- 데이터가 프로그램 외부에도 저장되거나, 외부 데이터가 프로그램 내부로 들어와야 할 경우 파일 시스템과의 연결 지점

\- java.io 패키지의 Stream(스트림), Reader/Writer계열 클래스

  👉🏻 텍스트 파일, 이진 파일 등 다양한 파일 포맷 읽고 쓸 수 있음

> **❓ Stream**  
> \- InputStream (입력 스트림) OutputStream (출력 스트림)을 통해 파일, 네트워크, 메모리 등에서 데이터를 1바이트 단위로 읽고 쓰기 가능  
> \- 순차적이고 방향 있음  
> \- 파일 내용을 앞에서부터 끝까지 읽는 데 적합

> **❓ Reader/Writer**  
> \- 문자 기반 입출력을 처리하는 클래스 계열  
> \- 한글이나 유니코드처럼 문자 인코딩이 중요한 처리에 적합

#### **2\. 사용 이유**

\- 대부분의 자바 프로그램에서 파일 기반의 설정, 로그, 업로드, 배치 처리 등 외부와의 데이터 교환이 필수이기 때문

\- 자바 프로그램은 기본적으로 메모리 내에서만 데이터를 처리

  👉🏻 프로그램이 종료되면 그 동안의 모든 데이터 사라짐

-   로그를 기록해두지 않으면, 장애 원인 분석 불가
-   설정을 하드코딩하면 환경이 바뀔 때마다 코드 수정
-   사용자 업로드 파일을 저장하지 않으면, 기능 자체 성립 불가
-   대용량 데이터를 다룰 때, DB를 거치지 않고 파일 기반으로 처리해야 할 경우도 많음

#### **3\. 사용 방법**

\- 파일을 읽거나 쓰기 위해 Stram 또는 Reader/Writer 계열 클래스를 사용하여, 데이터 흐름을 순차적으로 처리

**(1) 기본 형식**

\- 파일 입출력은 try-catch문으로 예외 처리 가능

\- 파일을 열고 사용한 뒤 자동으로 자원을 해제하려면 try-with-resources 구문 사용하는 것이 권장

\- close() 호출을 생략해도 자원이 자동으로 정리 -> 코드 간결, 안정성 높이짐

```
try (FileReader reader = new FileReader("input.txt")) {
	// 파일 읽기 작업
} catch (IOException e) {
	// 예외 처리
}
```

\- FileReader, FileWriter: 문자 기반 입출력용 클래스

\- InputStream, OutputStream: 바이트 기반 이진 파일 처리에 사용

\- try-with-resources: 예외가 발생해도 파일 리소스를 자동으로 정리할 수 있음

**(2) 텍스트 파일 쓰기 - FileWriter**

\- 텍스트 파일에 문자열을 기록하는 가장 기본적인 방식

**(2) 텍스트 파일 읽기 - BufferedReader**

\- 텍스트 파일의 내용을 한 줄씩 순차적으로 읽어오는 구조

\- 파일로부터 데이터를 읽을 때, 내부에 일정 크기의 버퍼 메모리를 두고 여러 분자를 한 번에 읽어들임

  👉🏻 필요한 만큼만 꺼내씀

\- 파일을 매번 1글자씩 직접 읽는 것보다 디스크 접근 횟수 줄임

  👉🏻 전체적인 처리 속도 향상

\- FileReader를 감싸서 사용됨

  👉🏻 단일 파일 읽기 뿐만 아니라 로그 분석, 설정 파일 파싱, 정렬된 텍스트 데이터 처리

> **❓ 버퍼**  
> \- 데이터를 잠시 저장해두는 임시 메모리 공간  
> \- 입출력 작업에서 데이터를 한 번에 많이 읽거나 쓸 수 있도록 모아두었다가 일정 크기만큼 모이면 한꺼번에 처리함으로써 성능 높임  
> \- 입출력 지연이나 성능 저하 방지

**(3)이진 파일 복사 - FileInputStream, FileInputStream**

\- FileInputStream: 파일로부터 1바이트 단위로 데이터를 읽는 클래스

\- FileInputStream : 바이트 데이터를 그대로 다른 파일로 출력하는 클래스

\- 사용자가 업로드한 파일을 서버 디렉토리에 복사하거나, 시스템이 특정 바이너리 데이터를 자동 백업하거나, 파일 포맷을 가공없이 전달할 때 사용

> **❓ 바이너리 데이터**  
> \- 사람이 읽을 수 있는 문자 형태가 아니라, 0과 1로 이루어진 이진 형식 그대로 저장된 데이터  
> \- 이미지, 동영상, 실행 파일, 압축 파일 등  
> \- 텍스트처럼 특정 인코딩으로 변환하지 않고, 컴퓨터가 이해하는 원시 비트, 바이트 단위로 나눔

**(3) 쓰기 성능 최적화 - BufferWriter**

\- 문자열을 버퍼에 모아두었다가 한 번에 파일로 출력

\- write()로 문자열 쓰고, newLine()으로 줄 나눔

\- 내부에 버퍼 메모리를 두고, 문자열 데이터를 먼저 메모리에 저장한 뒤 일정 크기만큼 모아졌을 때 한 번에 디스크에 기록

\- 디스크 접근 횟수를 줄여 전반적인 출력 성능 뛰어남

\- 로그 파일 기록, CSV 파일 라인 단위 생성, 리포트, 다량의 텍스트를 반복 출력할 때 사용

**(4) 정리**

| **처리대상** | **클래스** | **입출력 단위** | **특징** |
| --- | --- | --- | --- |
| **텍스트 파일 쓰기** | FileWriter, BufferedWriter | 문자 | 줄 단위 처리 가능, 성능 향상 |
| **텍스트 파일 읽기** | FileReader, BufferedReader | 문자 | 한 줄씩 읽기, 가독성 좋음 |
| **바이너리 파일 복사** | FileInputStream, FileOutputStream | 바이트 | 이미지, 영상 등 처리 가능 |

#### **3\. NIO (New Input Output)**

**\- 기존 I/O 구조**

-   소켓마다 별도의 스레드가 할당
-   데이터를 읽거나 쓸 때까지 스레드가 대기 상태에 머무름
-   read(), write() 호출이 완료될 때까지 스레드가 반환되지 않음
-   수천 개의 동시 연결 처리에 매우 비효율적

**\- NIO 구조**

-   모든 소켓 채녈이 버퍼를 통해 데이터 주고받음
-   읽기와 쓰기는 Non-blocking 방식으로 동작
-   각 채널의 이벤트(읽기 가능/쓰기 가능 등)는 Selector가 감지

👉🏻 하나의 스레드로 수많은 채널을 동시에 감시 가능

👉🏻 스레드 낭비 없이 효율적인 동시 처리 가능

👉🏻 실시간 데이터 처리나 네트워크 서버 구축에 매우 적합

> ❓Non-blocking 방식  
> \- 입출력 작업을 요청했을 때, 데이터가 준비될 때까지 쓰레드가 멈추지 않고 즉시 반환하는 방식  
> \- 하나의 쓰레드가 동시에 여러 I/O 작업을 관리할 수 있어, 대규모 네트워크 서버나 실시간 애플리케이션에 적합

**(1) 핵심 구성 요소**

**\- Buffer**

-   데이터를 직접 저장하고, 읽기/쓰기 위치를 관리하는 구조
-   ByteBuffer, CharBuffer 등 다양한 타입 존재

**\- Channel**

-   데이터의 양방향 흐름 지원
-   FileChannel. SocketChannel, DatagramChannel 등이 있음

**\- Selector**

-   여러 채널의 이벤트를 감지하고, 하나의 스레드로 동시에 여러 채널 처리 가능
-   select() 호출로 이벤트 발생 감지

---

### **2️⃣ Stream**

#### **1\. 정의** 

\- 데이터를 순차적으로 처리하기 위한 일방향 흐름의 데이터 통로

\- 프로그램이 외부와 데이터를 주고받을 떄의 흐름

\- 한 번에 하나의 데이터 다룸

\- 연결된 데이터 소스와 프로그램 사이의 전달 경로로서 작동

**(1) 입력 스트림 (InputStream)**

\- 외부 데이터 소스(파일, 네트워크, 키보드 등)로부터 데이터를 읽어와 프로그램 내부로 전달하는 통로

\- 데이터를 단방향으로, 순차적으로 읽기만 가능

\- 읽은 데이터를 가공하거나 다른 곳으로 넘기는 작업은 이후 단계

**(2) 출력 스트림 (OutputStream)**

\- 프로그램 내부에서 생성된 데이터를 외부 대상 (파일, 화면, 네트워크 등)으로 내보내는 통로

\- 단방향

\- 데이터를 바이트 단위로 외부로 흘려보내는 역할

#### **2\. 동작 방식**

입력 -> 처리-> 출력

**(1) 입력** 

\- InputStream, Reader 계열

\- 외부의 데이터 소스로부터 데이터를 한 바이트 또는 한 문자씩 순차적으로 읽어옴

  👉🏻 InputStream.read(), Reader.read() 메서드 사용

**(2) 처리** 

\- 메모리 내 변수 혹은 버퍼

\- 읽어온 데이터를 일시적으로 메모리에 저장하거나, 중간 가공 수행

\- 로직에 따라 값 비교, 변환, 필터링 등 다양한 작업 가능

**(3) 출력**

\- OutputStream, Writer 계열

\- 출력대상: 파일, 콘솔, 네트워크

  👉🏻 OutputStream.write(). Writer.write() 등의 메서드 사용


#### **3.  사용 이유**

\- 외부 데이터와의 입출력을 구조적으로 추상화

   👉🏻대용량 처리, 실시간 응답, 코드 재사용 등 다양한 I/O 요구를 효과적으로 해결하기 위함

| **대용량 데이터를 조각 단위로 처리** | \- 대용량 데이터를 전체 메모리에 적재하지 않고, 한 줄 또는 한 바이트씩 순차적으로 처리      👉🏻 메모리 효율성, 안정성 크게 향상 |
| --- | --- |
| **다양한 입출력 대상에 동일한 방식으로 접근 가능** | \- 다양한 입출력 대상을 같은 방식으로 처리할 수 있도록 추상화되어 있음      👉🏻 코드 재사용성과 유지보수 뛰어남 |
| **실시간으로 입력을 받아 즉시 처리** | \- 입력이 도착하는 즉시 데이터 처리 가능     👉🏻 실시간 응답이 필요한 환경에 적합 |
| **중간 처리 기능을 자유롭게 조합** | \- 필터링, 변환, 버퍼링 같은 기능을 조합해 처리 흐름 설계 가능      👉🏻 유연성 뛰어남 |
| **자바의 표준 입출력 API가 모두 Stream 기반** | \- 자바의 대부분의 외부 입출력 기능 Stream 구조를 기반으로 설계      👉🏻 이를 이해하지 못하면 파일, 네트워크, 직렬화 등 실무 기능 제대로 구현 어려움 |

#### **4\. 사용 방법**

\- 입력과 출력을 각각의 스트림 객체로 생성

   👉🏻 read()와 write() 메서드를 사용해 데이터 순차적 처리

**(1) 기본 형식**

**\- 바이트 스트림**: InputStream, OutputStream계열로 이미지, 영상, PDF 등 이진 데이터를 처리할 때 사용

```
try (InputStream in = new FileInputStream("Input.txt");
	 OutputStream out = new FileOutputStream("Output.txt")) {
	//입력 스트림에서 읽고 출력 스트림으로 씀     
} catch (IOException e) {
	e.printStackTrace();
}
```

**\- 문자 스트림**: Reader, Writer 계열로 텍스트 데이터를 처리할 때 사용

```
try (BufferedReader reader = new.BufferReader(new FileReader("input.txt"));
     BufferedWriter writer = new.BufferWriter(new FileWriter("output.txt"))) {
	// 한 줄씩 읽고 씀     
} catch (IOException e) {
	e.printStackTrace();
}
```

\- 사용 시에는 try-with-resources 구문을 통해 안전하게 열고 닫는 것이 일반적

\- 스트림은 한 방향으로만 동작

   👉🏻 InputStream은 오직 읽기, OutputStream은 오직 쓰기만 가능

   👉🏻 입력과 출력을 동시에 처리하려면 두 개의 스트림을 각각 별도로 구성

**(2) 텍스트 파일 읽기 (BufferedReader 사용)**

\- 로그 파일이나 설정 파일 등 줄 단위 처리가 필요한 경우

\- 간단한 텍스트 분석 또는 데이터 필터링을 수행할 때

\- 많은 줄 수의 파일을 빠르게 읽어야 할 때

\- 문자 인코딩이 중요한 환경

   👉🏻 InputStreamReader, BufferedReader를 함께 사용하여 인코딩을 명확히 지정

**(3) 텍스트 파일 쓰기 (BufferedWriter 사용)**

\- 로그 파일 작성, 설정 저장, 단순한 텍스트 출력

\- 출력량이 많거나 빈번한 쓰기 작업이 예상되는 경우

**(4) 이진 파일 복사 (InputStream / OutputStream 사용)**

\- 이미지 백업, 첨부 파일 저장, PDF 복제 등 파일 내용을 변경하지 않고 그대로 복사해야 할 때 자주 사용

---

### **3️⃣  직렬화 (Serialization)**

#### **1\. 정의**

\- 자바 객체를 바이트 형태로 변환해 외부로 전달하거나 저장할 수 있도록 해주는 입출력 처리 기술

\- 데이터 구조나 객체의 상태를 저장 또는 전송이 가능한 형식인 바이트 스트림, 텍스트 등으로 변환하는 것

\- 자바 객체는 일반적으로 JVM 내부 메모리에 존재하며, 그 구조는 외부에서 바로 이해하거나 처리할 수 없음

  👉🏻 객체를 파일, 네트워크, 데이터베이스 등 외부 시스템으로 보내려면, 객체의 상태를 일련의 바이트로 변환해야 함

  👉🏻 이 과정이 직렬화

  👉🏻 직렬화된 객체는 다시 역직렬화 과정을  통해 원래의 자바 객체로 복원 가능

#### **2\. 동작 방식**

**(1) 직렬화 대상 객체 선정**

\- 직렬화하려는 객체는 반드시 Serialization 인터페이스를 구현해야 함 (마커 인터페이스)

> **❓ 마커 인터페이스**  
> \- 아무 메서드도 가지지 않고, 구현 여부 자체만으로 특별한 의미를 부여하는 인터페이스  
> \- Serializable: 객체를 직렬화 할 수 있음을 명시  
> \- Cloneable: 객체를 복제할 수 있음을 명시  
> \- Remote: 원격 호출 대상임을 명시

**(2) 직렬화 준비**

\- 직렬화를 수행하기 위해 자바는 내부적으로 ObjectOutputStream 같은 출력 스트림 사용

\- ObjectOutputStream: 바이트 스트림 계열, 객체를 바이트 단위로 변환하고 출력할 수 있는 기능 제공

**(3) 객체 상태를 바이트로 변환**

\- 직렬화 과정에서는 객체의 클래스 메타정보, 필드명과 필드 값, 객체 참조 정보 등을 바이트 순서대로 정리

\- transient 키워드가 붙은 필드는 직렬화 대상에서 제외

\- static 필드도 클래스 자체에 속한 정적 데이터이므로 직렬화되지 않음

> **❓ transient 키워드**  
> \- 직렬화 대상에서 제외할 필드에 사용되는 예약어  
> \- Serializable 처리 시 바이트 스트림에 포함되지 않아, 복원 시 기본값으로 초기화

**(4) 출력 대상 (목적지)로 바이트 전송**

\- 변환된 바이트 정보는 파일, 네트워크 소켓, 메모리 등 원하는 출력 매체로 전송

\- 이 과정을 통해 객체의 상태가 JVM 외부 환경에서도 읽을 수 있는  형태로 저장됨

**(5) 역직렬화와 연결됨**

\- 직렬화는 항상 역직렬화와 세트로 동작

\- 저장된 바이트는 나중에 다시 읽혀져 원래의 객체로 복원

\- 역직렬화 시에도 Serializable을 구현하고 있어야 하며, 저장된 클래스 구조와 버전이 일치해야 정상 복원

#### **3\. 사용 이유**

\- 객체의 상태를 안전하게 저장하거나 외부 시스템으로 전송할 수 있게 해, 시스템 간 데이터 공유와 보존을 가능하게 하기 위함

| **파일 저장** | 애플리케이션에서 처리 중인 객체를 그대로 디스크에 저장하거나 다시 로드하려면 직렬화를 통해 바이트 형태로 기록하고 복원해야 함 |
| --- | --- |
| **네트워크 전송** | 소켓 통신, 메시지 큐를 통해 객체를 전송할 때 직렬화된 바이트 스트림을 사용해야 함 |
| **세션 관리 (서블릿, 스프링)** | 세션을 분산 서버에 공유하거나, 세션 정보를 Redis 등에 저장할 때 객체가 직렬화 가능해야 함 |
| **캐시 저장** | Redis와 같은 캐시 시스템에 객체를 저장할 경우, 내부적으로 직렬화 필요 |
| **RMI, 마이크로서비스 통신** | 원격 객체 호출이나 마이크로서비스 간 데이터 전송 시 직렬화된 객체 교환 |
| **로그 및 상태 덤프 저장** | 장애 발생 시 객체 상태를 파일로 기록해 두고, 나중에 분석하거나 테스트에서 복원하는 데 사용 |
| **테스트 자동화 및 스냅샷** | 테스트 중 객체의 스냅샷을 저장하고, 이후 동일 조건을 재현하는 데 직렬화 사용됨 |

> **❓ 메시지 큐**  
> \- 프로그램끼리 데이터를 주고받을 때 중간에서 메시지를 임시로 저장하고 전달해주는 시스템  
> \- 느린 작업을 분리하거나, 시스템 간 비동기 통신이 필요할 때 필수적

> **❓ 원격 객체 호출 (RMI)**  
> \- 다른 서버에 있는 자바 객체의 메서드를 마치 로컬 객체처럼 호출할 수 있게 해주는 기술  
> \- 자바 애플리케이션끼리 네트워크를 통해 객체를 주고받고 직접 메서드를 실행할 수 있게 하며, 내부적으로 직렬화를 사용해 데이터를 전송  
> \- 분산 시스템에서 서버 간 기능 호출이 필요할 때 유용한 자바 고유 기술

#### **4\. 사용 방법**

\- ObjectOutputStream.writeObject() 로 객체를 바이트로 저장

\- ObjectOutputStream.readObject() 로 다시 객체로 복원

\- 기본 형식

-   직렬화

```
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("파일명"));
out.writeObject(객체); //객체를 바이트로 직렬화
```

-   역 직렬화

```
ObjectIntputStream in new = ObjectIntputStream(new FileInputStream("파일명"));
클래스명 객체 = (클래스명) in.readObject(); //바이트를 객체로 역직렬화
```

**(1) 객체가 Serializable 인터페이스를 구현**

\- 직렬화 대상 클래스는 반드시 java.io.Serializable 인터페이스를 구현해야 함

\- 이 인터페이스는 마커 인터페이스 

  👉🏻구현만 해주면 JVM이 직렬화 가능한 객체로 인식

\- 이 인터페이스를 구현하지 않으면 직렬화 시 NotSerializableException 발생

> **❓ NotSerializableException**  
> \- 직렬화 대상 클래스가 Serializable 인터페이스를 구현하지 않았을 때 발생하는 예외  
> \- 자바에서 객체를 바이트로 변환하려고 할 때 , 해당 객체가 직렬화 가능하지 않으면 이 예외 발생  
> \- 해결하려면 클래스에 implements Serializable을 명시해야 함

**(2) ObjectOutputStream으로 직렬화 수행**

\- 직렬화를 위해 ObjectOutputStream 클래스 사용

\- 이 클래스는 객체를 바이트 단위로 변환하여 파일, 네트워크, 메모리 등에 출력 가능

\- writePbject() 메서드는 객체를 바이트 스트림으로 변환해 출력

\- 출력 대상은 파일, 소켓, 메모리 등 어떤 출력 스트림도 가능

\- try-with-resorces를 사용하면 자동으로 스트림 닫힘

**(3) ObjectInputStream으로 역직렬화 수행**

\- readObject()는 바이트 스트림을 다시 자바 객체로 복원

\- 반드시 원래 클래스와 같은 클래스 구조가 필요하며, Serializable을 구현하고 있어야 함

\- 역직렬화 시에는 ClassNotfoundException을 처리해야 함

> ❓ClassNotfoundException  
> \- 역직렬화를 통해 클래스를 로드하려 할 때, JVM이 해당 클래스를 찾지 못하면 발생하는 예외  
> \- 역직렬화 시점에, 저장된 클래스 정보는 존재하지만 실행 중인 애플리케이션에 그 클래스가 없는 경우 발생  
> \- 바이트 스트림으로부터 객체를 복원하려는데, 복원에 필요한 클래스 정의를 못 찾았을 때 발생

#### **\+ transient 키워드**

\- 객체 직렬화 시 제외할 필드에 사용하는 예약어

\- 변환 대상에서 제외되어 파일에 기록되지 않음

\- 역직렬화시에도 복원되지 않음

```
private transient String password;
```

\- 직렬화 시 해당값은 저장되지 않고, 역직렬화 이후에는 (null, 기본형이라면 0, false 등으로 초기화)

\- 사용 이유

| 보안 데이터 보호 | \- 외부에 노출되어선 안 되는 민감한 정보는 저장되지 않아야 함     👉🏻 transient를 사용하면 직렬화 저장 시 해당 정보가 자동으로 제거되어 보안 강화 |
| --- | --- |
| 일시적/계산용 필드 제외 | \- 저장할 필요가 없는 정보는 직렬화 대상에서 제외하는 것이 효율적 |
| 외부 자원 참조 차단 | \- 파일 핸들, 데이터베이스 연결 객체, 소켓 등은 직렬화할 수 없는 외부 리소스      👉🏻 이런 객체를 포함한 필드에는 반드시 transient를 붙여 직렬화 오류를 방지해야 함 |

#### **\+ serialVersionUID 명시 권장**

\- 직렬화된 객체의 클래스 버전을 식별하기 위함 고유 ID

\- 정수형(Long) 타입

\- 선언만 하고 사용하는 코드는 없음

  👉🏻 JVM이 직렬화/역직렬화 과정에서 내부적으로 참조하는 값이기 때문

\- 사용 이유

-   직렬화된 객체를 역직렬화할 때, 클래스가 원본과 동일한 구조인지 검증하기 위해
-   클래스에 serialVersionUID를 명시하지 않으면, 컴파일러 자동 생성
-   이 값은 필드, 메서드, 접근제어자 등의 구조 변화에 따라 달라지므로, 조금만 수정해도 값이 달라지고 역직렬화 실패
-   serialVersionUID가 다르면 JVM은 역직렬화 거부 -> InvalidClassException 예외 발생 시킴

> **❓ InvalidClassException**  
> \- 직렬화된 데이터를 역직렬화하려할 때, 클래스의 serialVersionUID가 저장 당시와 다를 경우 발생하는 예외  
> \- 클래스 구조가 변경되었는데도 동일한 객체를 복원하려고 할 때, 버전 불일치로 인해 역직렬화 거부

\- serialVersionUID는 객체를 파일, DB, 캐시 등에 저장하거나, 네트워크를 통해 전송하는 경우에는 항상 명시

\- 특히 직렬화된 객체가 장기간 저장되거나, 다양한 서버 간에 교환되는 경우

   👉🏻 클래스 구조가 바뀌더라도 serialVersionUID가 동일하면 역직렬화 성공

\- 명시하지 않으면 향후 클래스 변경 시 의도치 않은 비호환성 오류 발생

---

### **4️⃣ Reflection**

#### **1\. 정의**

\- 클래스, 메서드, 필드 등의 정보를 실행 중에 동적으로 조회하고 조작할 수 있게 해주는 기능

\- 컴파일 시점에 알 수 없는 클래스조차도 실행시점에 동적으로 처리 가능

\- 구조적 정보, 객체를 생성하거나, 메서드를 호출하거나, 필드 값을 수정하는 일까지도 동적 수행 가능

| Class | 클래스 자체에 대한 정보 (이름, 부모 클래스, 인터페이스 등) |
| --- | --- |
| Method | 클래스에 선언된 메서드의 이름, 반환 타입, 매개변수 정보 |
| Field | 멤버 변수의 이름, 타입, 접근 제어자 등 |
| Constructor | 생성자의 매개변수, 접근 수준 등의 메타 데이터 |

> **❓ 정적타입 언어**  
> \- 변수의 타입이 컴파일 시점에 결정됨  
> \- 타입을 명시적으로 선언  
> \- 컴파일러가 코드를 분석하면서 타입 오류 미리 확인 가능  
>   👉🏻 실행 전에 문제가 감지되어 안정성과 성능 높음  
> \- 코드를 실행하기 전인 컴파일 단계에서 타입이 고정됨  
>   👉🏻 유연성은 떨어지지만 예측 가능한 동작 보장

> **❓ 동적 타입 언어**  
> \- 변수의 타입이 실행 시점에 결정  
> \- 타입을 사전에 선언하지 않아도 됨  
> \- 실제로 값이 할당되기 전까지는 타입이 결정되지 않음  
>   👉🏻 빠른 개발과 높은 유연성 제공  
>   👉🏻 타입 오류가 프로그램 실행 중에 발생할 수 있음  
>   👉🏻 런타임 오류의 위험

#### **2\. 사용 이유**

\- 정해지지 않은 구조나 외부 입력에도 유연하게 대응할 수 있는 확장성과 자동화를 위함

\- 문자열 형태의 클래스 이름만 있어도 클래스를 동적으로 로딩하고, 생성자를 찾아 객체를 생성하며, 필드에 값을 설정하고, 메서드 실행 가능

\- 즉, 구조가 미리 정해지지 않은 상황에서도 유연하게 클래스를 탐색하고 조작할 수 있는 방법 제공

| **실행 중 클래스나 메서드를 동적으로 결정** | \- 클래스 이름을 문자열로 받아 해당 클래스를 로딩하고, 객체를 생성하거나 메서드 호출 가능   \- 어떤 클래스를 사용할지 외부 설정 파일이나 사용자 입력을 통해 동적으로 결정해야 함   \- 컴파일 시점에는 해당 클래스를 알 수 없는 경우에 필요 |
| --- | --- |
| **프레임워크 내부 구현에 필수** | \- 런타임에 클래스 구조나 어노테이션을 분석하고 조작할 수 있기 때문에, 스프링의 의존성 주입, AOP, JP의 필드 매핑과 같은 프레임워크 핵심 기능을 구현하는 데 필수 |
| **접근 제한된 멤버에 강제로 접근** | \- setAccessible(true)를 통해 private 필드나 메서드에도 접근 가능   \- 전달된 객체의 정체를 알 수 없을 때 유용   \- 동적 설정, 로그 출력, 자동 호출, 플러그인 관리 등 다양한 상황에서 활용 |
| **객체 상태를 분석하거나 자동 동작 구성** | \- 클래스 이름, 필드 목록, 메서드, 어노테이션 정보 등을 런타임에 조사 가능   \- 전달된 객체의 정체를 알 수 없을 때 유용   \- 동적 설정, 로그 출력, 자동 호출, 플러그인 관리 등 다양한 상황에서 활용됨 |
| **확장성과 유연성이 중요한 아키텍처 설계** | \- 클래스 이름만으로 객체를 생성하고 메서드 실행 가능     👉🏻 코드 수정 없이도 새로운 기능이나 플러그인 동적 추가 가능   \- 플러그인 시스템, 모듈형 아키텍처, 사용자 정의 구성 요소가 필요한 확장성 중심의 설계에 매우 적합 |

#### **3.  사용 방법**

\- 클래스, 생성자, 메서드, 필드 정보를 실행 중에 동적으로 조회하고 조작하는 순차적 절차를 통해 사용

**(1) 클래스 로딩**

\- 클래스의 메타정보 (Class 객체)를 얻음

\- 클래스 이름을 문자열로 받아 Class.forName()을 통해 동적 로딩 가능

**(2) 생성자 호출**

\- 클래스를 로딩한 뒤, 객체를 생성하려면 생성자(Constructor)를 얻고 실행해야 함

\- 클래스를 직접 new로 생성하지 않고도 객체를 동적으로 생성 가능

**(3) 메서드 호출**

\- 생성된 객체에 대해 특정 메서드를 실행하고 싶다면, 메서드를 조회하고 invoke 사용

**(4) 필드 조작**

\- private 필드에도 접근이 가능하며, 직접 값을 읽거나 쓸 수 있음

---

### **5️⃣ 람다 (Lambda)**

#### **1\. 정의**

\- 코드 블록을 값처럼 다룰 수 있도록 해주는 익명 함수 표현 방식

\- 이름이 없는 일회성 메서드 정의를 표현하는 구문

\- 메서드를 마치 값처럼 변수에 저장하거나 인자로 전달할 수 있게 해줌

\- 함수형 인터페이스 (단 하나의 추상 메서드만 가진 인터페이스)를 구현할 때 사용

\- 코드가 짧고 명확해지며, 컬렉션의 반복 처리, 비동기 실행, 스트림 연산 등 다양한 상황에서 함수형 프로그래밍 스타일을 자바에서 구현 가능

> **❓ 함수형 인터페이스**  
> \- 추상 메서드가 하나만 정의된 인터페이스  
> \- 자바에서 람다식의 대상 타입이 되는 구조  
> \- "이 동작 하나를 실행하세요"라는 의미를 갖는 하나의 동작 단위

#### **2\. 사용 이유**

\- 코드의 가독성과 유지 보수성을 높이고, 데이터 처리 흐름을 직관적으로 표현할 수 있도록하기 위해

| **코드를 간결하고 명확하게 표현 가능** | \- 익명 클래스를 대체하면서도 훨씬 짧고 간결한 문법으로 동일한 기능 구현 가능 |
| --- | --- |
| **Stream API와 자연스럽게 연동되어 데이터 처리 흐름 개선 가능** | \- 컬렉션을 필터링하거나, 변환하거나, 그룹화하는 처리를 람다식과 함께 사용하면 선언적이고 직관적인 코드 구성 가능 |
| **콜백 함수나 이벤트 핸들러를 명확하게 정의 가능** | \- 자바에서 콜백 구현할 대 람다를 사용하면 의도가 명확히 보임   (이 타이밍에 이 동작을 하라) |
| **테스트 코드와 Mock 구성 시 유연한 조건 설정 가능** | \- 테스트 코드에는 조건 기반 검증이 많아지는데, 람다를 사용하면 조건 필터나 Mock의 동작을 한 줄로 정의할 수 있어 구조가 훨씬 깔끔해지고 유지보수성이 좋아짐 |
| **정렬, 필터링, 조건 비교 등을 매우 짧은 코드로 처리 가능** | Comparator 구현이나 조건 기반 처리도 람다를 쓰면 불필요한 클래스를 줄이고, 핵심 로직만 간단히 표현할 수 있어 생산성과 가독성이 동시에 올라감 |

#### **3\. 사용 방법**

\- (매개변수) -> {실행문}

#### **\+ 메서드 레퍼런스 (Method Reference)**

\- 이미 정의된 메서드를 람다식보다 더 간결하게 호출하는 문법

\- 람다식에서 실제로 하는 일이 특정 메서드 호출 뿐이라면, 메서드 이름만 직접 참조하여 표현 가능

\- 코드가 단순하고 명확한 경우에 효과적

\- 조건 분기나 로직이 필요한 경우에는 람다식이나 별도의 메서드를 사용하는 것이 더 적합

---

### **6️⃣  Optional**

#### **1\. 정의**

\- null이 될 수 있는 값을 명시적으로 감싸는 래퍼 클래스

\- 일반적으로 객체가 존재하지 않을 수 있는 상황에서 null을 그대로 반환하게 되면 이것을 처리하지 못한 코드에서 NullPointerException 발생

  👉🏻 Optional: 값이 있을 수도 있고 없을 수도 있는 경우를 안전하게 표현할 수 있도록 설계됨

> **❓ 래퍼 클래스**  
> \- 자바에 존재하는 여러 기본 자료타입을 객체로 다루기 위해 사용하는 클래스  
> \- 기본타입에서 래퍼 클래스로 변경하는 과정 -> 박싱  
> \- 래퍼 클래스 객체를 기본 타입으로 전환하는 것 -> 언박싱

#### **2\. 사용 이유**

\- 코드의 명확성과 안정성을 높여주며, 값이 없을 수 없는 상황을 구조적으로 표현할 수 있기 때문

\- 자바에서는 null이 매우 흔하게 사용

   👉🏻NullPointerException(NPE) 문제 자주 발생

> **❓ NullPointerException**  
> \- null 값을 가진 객체를 사용하려고할 때 발생하는 예외  
> \- 실행 시점에 발생하기 때문에 디버깅이 어렵고, 서비스 장애로 이어짐

| **NullPointerException 예방** | \- 값이 없을 수도 있다는 점을 코드 레벨에서 명시적 표현     👉🏻 null 체크를 강제     👉🏻 실수로 인해 생기는 NPE 줄임 |
| --- | --- |
| **설계 의도를 명확히 드러냄** | \- 메서드 시그니처에서 Optional<Something>을 반환      👉🏻 이 값은 존재하지 않을 수도 있다는 의도 명확히 전달 가능 |
| **후속 처리 흐름을 안전하게 연결** | \- map(), filter(), orElse(), ifPresent() 등의 메서드      👉🏻 null 여부 명시적으로 다룸     👉🏻 조건 분기 없이 안전하게 로직 이어갈 수 있음 |
| **예외 처리 및 기본값 제공이 깔끔** | \- orElse(), orElseGet(), orElseThrow() 등      👉🏻 기본값 지정, 지연 생성, 예외 발생 등을 일관된 방식으로 처리     👉🏻 코드 예측 가능성과 가독성 높아짐 |
| **Stream 및 람다식과 자연스럽게 연동** | \- 람다식 및 Stream API와 구조적으로 잘 맞기 때문에, 선언적 프로그래밍과 함께 사용할 때 코드의 간결성과 일관성이 높아짐 |

> **❓ 선언적 프로그래밍**  
> \- 무엇을 할 것인가 (What)을 중심으로 코드를 작성하는 방식  
> \- 개발자가 로직의 절차(How)를 명령어로 직접 작성하는 대신, 원하는 결과를 기술하고 그 처리는 시스템이 알아서 수행

#### **3\. 사용 방법**

\- Optional.ofNullable(값) 형태로 생성

  👉🏻 orElse(), map(), ifPresent() 등을 통해 값의 유무에 따라 안전하게 처리

**(1) Optional 객체 생성**

```
Optional<타입> 변수명 = Optional.ofNullable(값);
```

```
Optional<String> carModel = Optional.of("Avante"); //값이 반드시 있어야 함
Optional<String> carColor = Optional.ofNullable(color); //값이 없을 수도 있음 (null 사용)
Optional<String> emptyPlate = Optional.empty(); //명시적으로 빈 상태 표현
```

\- **Optional.of(value)**

-   절대 null이 아닌 값을 감쌀 때 사용
-   null을 인자로 넣으면 NullPointerException 발생
-   내부에서 null이 아님이 보장된 값일 때 사용

\- **Optional.ofNullable(value)**

-   null일 수도 있는 값을 안전하게 감쌀 때 사용
-   값이 있으면 Optional.of(value)와 동일하게 동작
-   값이 없으면 Optional.empty()로 처리
-   외부 입력, API 응답, DB 조회값 등 null 가능성이 있을 때

\- **Optional.empty()**

-   비어 있는 Optional 객체를 명시적으로 만들 때 사용
-   아예 값이 없음을 명시적으로 표현하고 싶을 때

**(2) 값 확인 및 반환**

\- Optional이 감싸고 있는 값이 있는지 확인하거나, 기본값을 대체하거나, 예외 던지기 가능

**(3) 값 처리 및 연산**

\- Optional 내부의 값을 조건에 따라 필터링하거나 변환할 수 있다

\- filter(), map(), flatMap() 등 사용
