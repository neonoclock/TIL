## **🧠 회고**

작은 도서관을 만드는 것과 같다... 모르면 언제든 찾아볼 수 있게끔 잘 정리된 글을 쓰자.. 큰 틀에서의 흐름을 잘 잡자.

그리고 몸관리도 잘해야할 것 같다... 환절기+몸상태 최악... 이다 보니 열도 나도 감기도 나서 집중을 거의 하지 못했다... 

몸 관리도 하나의 역량임을 알고 컨디션 조절을 잘해야겠다.

## **🪽 오늘의 다짐**

1.  컨디션 관리 잘하기
2.  미루지 않기

---

## **📝 Today I Learned**

### **1️⃣ Internet**

#### **1\. 정의**

\- 전 세계의 컴퓨터 네트워크들이 상호 연결되어 정보를 공유하는 거대한 네트워크 시스템

\- 전 세계 컴퓨터 네트워크들이 서로 연결되어 데이터를 주고받을 수 있게 해주는 거대한 네트워크

\- 하드웨어와 소프트웨어 인프라의 집합체

\- TCP/IP라는 표준 프로토콜을 사용하여 다양한 컴퓨터 네트워크들이 서로 통신할 수 있게 함

\- 이메일, 파일 전송, 원격 접속, 온라인 게임, 소셜 미디어 등 다양한 서비스와 응용 프로그램 지원

> **❓ TCP/IP**  
> 인터넷에서 데이터를 전송하기 위해 사용되는 기본 통신 프로토콜 세트

> **❓ 인프라**  
> 인터넷이 제대로 작동하기 위해 필요한 모든 기반 요소(하드웨어 + 소프트웨어)

> **❓ 프로토콜**  
> 통신을 하기 위한 규칙

#### **2\. 사용 이유**

\- 정보 검색, 소통, 엔터테인먼트, 온라인 거래 등 다양한 정보에 접근하기 위함

#### **3\. 동작 방식**

**1\. 인트라넷 내부 요청**

\- 사용자가 조직 내부 네트워크(인트라넷)에서 인터넷에 접속하려고 할 때, 요청은 먼저 인트라넷의 내부 네트워크 장비를 거침

> **❓인트라넷**   
> \- 조직 내부의 컴퓨터 및 기타 디바이스들을 연결하는 사설 네트워크  
> \- 대학, 기관, 회사에서 정보를 공유하고 협업을 촉진하기 위해 사용

**2\. 게이트웨이를 통한 이동**

\- 이후 요청은 인트라넷과 인터넷을 연결하는 게이트웨이를 통과

> **❓ 게이트웨이**  
> \- 서로 다른 네트워크 또는 시스템 간의 연결점 또는 진입점 역할을 하는 장치나 소프트웨어  
> \- 서로 다른 프로토콜 또는 네트워크 환경 간의 데이터 전송을 가능하게 하기 위하여 사용  
> \- 인트라넷에서 나가는 트래픽을 인터넷으로 라우팅하고, 필요한 보안 검사 및 프로토콜 변환 수행

> **❓ 트래픽**  
> \- 서버의 데이터 전송량

> **❓ 라우팅**  
> 네트워크에서 데이터를 목적지까지 전달하기 위해 최적의 경로를 선택하는 과정

> **❓ 라우터**  
> \- 컴퓨터 네트워크 간에 데이터 패킷을 전송하는 네트워크 장치  
> \- 라우팅을 수행하는 네트워크 장비  
> \- 서로 다른 네트워크를 연결하고 데이터가 가야 할 길을 결정

**3\. 외부 네트워크 접속**

\- 게이트웨이를 거친 요청은 다양한 외부 네트워크와 라우터를 거쳐 최종적으로 목적지 웹 서버에 도달

**4\. 응답의 반환**

\- 웹 서버는 요청된 웹 페이지나 데이터를 사용자에게 되돌려 보냄

\- 이 응답 역시 게이트 웨이를 통해 사용자의 인트라넷으로 돌아옴

---

### **2️⃣ 클라이언트, 서버**

#### **1\. 정의**

**(1) 클라이언트**

\- 서버라는 다른 컴퓨터 시스템 상의 원격 서비스에 요청할 수 있는 응용 프로그램이나 서비스

**(2) 서버**

\- 정보나 서비스를 제공하는 컴퓨터 시스템

\- 클라이언트의 요청에 응답해주는 컴퓨터 프로그램 또는 장치

#### **2\. 사용 이유**

**(1) 클라이언트 사용 이유**

\- 서버로부터 데이터 또는 서비스를 요청하고 서버로부터의 응답을 받아오기 위해

**(2) 서버 사용 이유**

\- 데이터와 리소스를 중앙에서 관리

\- 클라이언트의 요청에 대한 결과를 제공하기 위해

#### **3\. 사용 방법**

**(1) 클라이언트**

\- 웹 브라우저 또는 앱을 통해 서버에 접속하고 요청을 보내서 사용

**(2) 서버**

\- 서버 소프트웨어를 설치

\- 클라이언트의 요청을 받아 처리하고 결과 반환

---

### **3️⃣ 클라이언트-서버 응용 버전**

#### **1\. 웹 구조**

**(1) 도메인 이름 입력**

\- 사용자가 웹 브라우저에 HTTPS 프로토콜을 사용하여 도메인 이름을 입력

**(2) DNS 조회**

\- 사용자의 장치는 DNS 리졸버를 통해 입력된 도메인의 IP 주소를 조회

**(3) Forward Proxy 통과 (선택적)**

\- 설정에 따라, 사용자의 요청은 Forward Proxy 서버를 거쳐 웹 서버에 전달

**(4) 홈페이지의 서버와 3-way handshake**

\- DNS 조회를 통해 얻은 IP 주소를 바탕으로, 사용자의 웹 브라우저(클라이언트)와 웹 서버 간의 TCP 연결을 시작하기 위해 3-way handshake가 수행

**(5) 서버와의 TLS 핸드셰이크 시작**

\- 사용자의 웹 브라우저는 서버와 안전한 연결을 시작하기 위한 TLS 핸드셰이크 과정을 시작

> **❓ TLS**  
> 인터넷에서 데이터를 안전하게 전송하기 위한 보안 프로토콜

> **❓ TLS 핸드셰이크**  
> 클라이언트(브라우저 등)와 서버가 보안 연결(암호화 통신)을 시작하기 전에 서로를 확인하고, 사용할 암호화 방식과 키를 협의하는 과정

**(6) 서버의 공개키 및 인증서 요청**

\- 웹 브라우저는 서버로부터 SSL/TLS 인증서와 공개키를 요청

> **❓ 공개키**  
> 비대칭 암호화에서 사용되는 키로, 누구나 열람할 수 있으며 데이터를 암호화하는 데 사용

> **❓ 비대칭 암호화**  
> 공개키(Public Key)와 개인키(Private Key)라는 서로 다른 두 개의 키를 사용하는 암호화 방식

**(7) CA 인증서 검증**

\- 웹 브라우저는 받은 인증서의 유효성을 확인하기 위해, 인증서에 서명한 CA의 공개키로 인증서를 검증

**(8) 암호화된 세션 생성**

\- 인증서가 유효하면, 웹 브라우저와 서버는 공유된 비밀키를 생성하여 통신을 암호화

**(9) 안전한 HTTPS 통신**

\- 암호화된 연결이 성공적으로 설정되면, 사용자와 웹 서버 간의 데이터 교환은 안전하게 이루어짐

#### **2\. 알아야하는 이유**

(1) 아키텍처 이해: 웹의 기본 구조와 각 요소가 어떻게 웹 경험을 형성하는지 이해할 수 있다

(2) 성능 최적화: 캐싱, 로드 밸런싱 등의 기술을 통해 웹사이트의 로딩 속도와 성능을 향상시킬 수 있다

(3) 보안 강화: 보안 프로토콜과 인증 기관의 역할을 이해함으로써 보다 안전한 웹사이트 개발 가능

(4) 문제 해결: 웹사이트 접속 문제나 성능 저하 등의 이슈가 발생했을 떄, 문제의 원인을 빠르게 파악하고 해결 가능

#### **3\. CDN**

**(1) 정의**

\- 전 세계에 분산된 서버 네트워크를 통해 웹 콘텐츠를 사용자에게 빠르게 제공하는 시스템

\- 사용자에게 가장 가까운 서버에서 콘텐츠를 제공 

  👉🏻 웹 사이트의 로딩 시간을 줄임

  👉🏻 대역폭 사용 최적화

   👉🏻 전반적인 사용자 경험 향상

**(2) 알아야 하는 이유**

\- 성능 향상

-   사용자에게 더 빠른 콘텐츠 로딩 시간을 제공하여 사이트의 전반적인 성능 개선

\- 가용성 증대

-   데이터를 여러 지리적 위치에 분산하여 저장함으로써 하나의 서버가 다운되어도 콘텐츠 제공에 영향주지 않음
-   웹사이트의 가용성과 신뢰성 높임

\- 보안 강화

-   DDoS 공격과 같은 보안 위협으로부터 웹사이트 보호

\- 비용 절감

-   원 서버의 대역폭 사용을 줄여줌으로써 웹 호스팅 비용 절감

\- 콘텐츠 관리 용이

-   웹사이트에 대용량 멀티미디어 파일이 많은 경우, CDN을 사용하여 이러한 파일을 관리하고 제공

**(3) 동작 방식**

a. 요청 경로 최적화

-   사용자가 웹사이트에 접속하려고 할 때, 요청은 사용자와 가장 가까운 CDN 서버로 라우팅
-   DNS 해석을 통해 이루어지며, 사용자에게 가장 낮은 지연 시간을 제공하는 서버가 선택됨

b. 콘텐츠 캐싱

-   선택된 CDN 서버는 웹사이트의 정적 콘텐츠를 캐싱
-   만약 캐시에 해당 콘텐츠가 이미 있으면 바로 사용자에게 제공

c. 콘텐츠 전송

-   만약 CDN 서버에 요청한 콘텐츠가 없다면, CDN서버는 원본 서버로부터 콘텐츠를 가져와 사용자에게 전달한 뒤, 이후의 요청을 위해 해당 콘텐츠를 캐시

d. 콘텐츠 업데이트 및 관리

-   웹사이트의 콘텐츠가 변경되면, CDN은 새로운 콘텐츠를 캐시하고 오래된 콘텐츠를 제거하여 항상 최신 상태 유지

### **4\. 모놀리식 vs MSA**

**(1) 모놀리식 아키텍처**

\- 하나의 서버가 모든 서비스를 관장하는 구조

\- 시스템이 단일 서버에서 통합적으로 동작

\- 장점: 관리가 용이함

\- 단점: 특정 서비스에 문제가 발생하면 전체 서버에 영향을 미쳐 시스템 전체가 사용 불가능

> **❓ 단일 장애점**  
> 하나의 문제로 인해 모든 서비스가 중단될 수 있음

**(2) MSA**

\- 각 서비스가 독립된 서버에서 운영되는 방식

\- 한 서비스에서 문제가 발생해도 다른 서비스에는 영향을 미치지 않음

\- 장점: 장애에 강하고 각 서비스의 독립적 확장이 가능해 관리와 유연성 면에서 유리

\- 단점: 각 서비스의 API와 버전 관리가 복잡해지며, 이를 위해 API 게이트웨이가 필요

> **❓API 게이트웨이**  
> 모든 서비스의 API 호출을 중앙화하고, Swagger와 같은 도구를 통해 각 서버의 API 버전과 Consumer-Producer 관계를 관리

---

### **4️⃣ 프론트엔드, 백엔드**

#### **1\. 정의**

(1) 프론트엔드: 웹/앱 개발 결과물에서 사용자에게 보여지는 부분

(2) 백엔드: 프론트엔드에 서비스를 제공하는 노드 또는 소프트웨어 프로그램

#### **2\. 사용 이유**

(1) 프론트엔드: 사용자 입장에서 소프트웨어를 시각적으로 사용할 수 있게 하기 위해서

(2) 백엔드: 클라이언트의 요청에 대한 결과를 관리/전달하기 위해서

---

### **5️⃣  네트워크 모델 - 네트워크 프로토콜**

#### **1\. 정의**

\- 네트워크 상에서 데이터를 주고받는 규칙과 절차를 정의하는 세계

\- 다양한 통신 장치들이 서로 원할하게 데이터를 송수신할 수 있도록 표준화된 규약

> **❓ 프로토콜**  
> 컴퓨터나 장치들이 서로 통신하기 위한 동일한 규칙

#### **2\. 사용 이유**

\- 네트워크 장치 간의 데이터 전송을 원할하고 안전하게 하기 위해

\- 데이터를 안전하고 신뢰성 있게 전송하기 위해

\- 각 프로토콜은 특정 기능을 수행

\- 네트워크 상의 모든 장치가 동일한 프로토콜을 따름으로써 통신이 원할하게 이루어짐

#### **3\. 사용 방법**

\- 네트워크 프로토콜에 따라 데이터가 송수신되고 처리됨

\- 네트워크 프로토콜은 각 계층에서 데이터를 처리하고 전송하는 데 사용

**(1) 주요 네트워크 프로토콜**

| **TCP**   **(Transmission Control Protocol)** | \- 신뢰성 있는 데이터 전송을 보장하는 프로토콜   \- 데이터 패킷의 전송, 오류 검출 및 복구, 흐름 제어 담당   \- 연결 기반 통신 제공   \- 데이터가 순서대로 전달됨 |
| --- | --- |
| **UDP**   **(User Datagram Protocol)** | \- 비연결형 프로토콜   \- 데이터 전송 시 신뢰성을 보장하지 않지만, 빠른 전송 속도 제공   \- 실시간 스트리밍, 온라인게임과 같은 속도가 중요한 곳에 사용 |
| **ICMP**   **(Internet Control Message Protocol)** | \- 네트워크 진단 및 오류 메시지를 전송하는 데 사용   \- Ping 명령어와 같이 네트워크 상태를 확인하거나, 오류 발생 시 알림을 보내는데 주로 사용 |
| **ARP**   **(Address Resolution Protocol)** | \- IP 주소를 기반으로 물리적 주소(MAC 주소)를 찾는 프로토콜   \- 네트워크 내에서 IP 주소를 가진 장치의 MAC 주소를 알아내기 위해 사용 |

**(2) 응용 계층 프로토콜**

| **HTTP**   **(Hypertext Transfer Protocol)** | \- 웹 브라우저와 서버 간의 데이터를 주고받는 데 사용되는 프로토콜   \- 주로 웹 페이지의 텍스트, 이미지, 비디오 등을 전송하는 데 사용 |
| --- | --- |
| **HTTPS**   **(Hypertext Transfer Protocol Secure)** | \- HTTP에 보안 기능 (SSL/TLS)을 추가한 프로토콜   \- 데이터가 암호화되어 정송됨   \- 웹통신의 기밀성과 무결성 보장 |
| **FTP**   **(File Transfer Protocol)** | \- 서버와 클라이언트 간 파일을 전송하는 데 사용되는 프로토콜   \- 파일의 업로드 및 다운로드 기능 제공   \- 주로 파일 서버에서 사용됨 |
| **SSH**   **(Secure Shell)** | \- 네트워크 상에서 안전한 원격 접속을 제공하는 프로토콜   \- 암호화를 통해 기밀성 보장   \- 원격 서버에 안전하게 로그인 가능 |
| **SMTP**   **(Simple Mail Transfer Protocol)** | \- 이메일 전송을 위한 표준 프로토콜   \- 이메일 서버 간의 메시지를 전달하는 역할   \- 클라이언트가 서버로 메일을 전송할 때도 사용됨 |
| **SNMP**   **(Simple Network Management Protocol)** | \- 네트워크 장치 (라우터, 스위치, 서버 등)를 모니터링 하고 관리하기 위한 프로토콜   \- 주로 네트워크 상태를 감시하거나 관리하는 데 사용됨 |

#### **4\. OSI 7계층**

네트워크 통신 과정을 7단계로 나눈 국제 표준 모델

| **물리 계층** | \- 전기 신호, 광 신호 등 물리적 전송 매체 담당   \- 케이블, 허브, 전송 신호 등 |
| --- | --- |
| **데이터 링크 계층** | \- MAC 주소 기반 통신, 오류 검출/재전송   \- 프레임 단위 전송   \- 이더넷, PPP |
| **네트워크 계층** | \- IP 주소 기반 라우팅   \- 패킷 단위 전송   \- 라우터, IP, ICMP |
| **전송 계층** | \- 종단 간 신뢰성 보장, 포트 번호 사용   \- TCP/UDP |
| **세션 계층** | \- 통신 세션을 관리 (연결 수립, 유지, 종료)   \- API 통신 세션 |
| **표현 계층** | \- 데이터 형식 변환, 압축, 암호화   \- JPEG, MPEG, SSL/TLS |
| **응답 계층** | \- 사용자와 가장 가까운 계층, 실제 서비스 제공   \- HTTP, FTP, SMTP, DNS |

---

### **6️⃣ HTTP**

#### **1\. 정의**

\- html, css, js, jpeg과 같은 파일이나 텍스트 등 일반적인 텍스트를 뛰어넘는 구조화된 텍스트를 전송하기 위해 사용되는 통신 규약

#### **2\. 사용 이유**

\- 웹 서버와 클라이언트가 하이퍼텍스트 문서를 주고받을 수 있도록 정의된 규칙에 따라 문서를 전송하기 위해

> **❓ 하이퍼텍스트**  
> 문서 안의 특정 단어, 구절, 이미지 등을 다른 문서나 정보로 연결해주는 텍스트

#### **3\. 사용 방법**

\- 클라이언트가 'URL'을 통해 특정 웹 주소로 요청을 보냄

---

### **7️⃣  HTTP - Message**

#### **1\. 정의**

\- 클라이언트와 서버 간에 파일 등을 주고 받는 통신의 기본 단위

#### **2\. 사용 이유**

\- 클라이언트와 서버 간 데이터를 교환하기 위함

#### **3\. 사용 방법**

\- HTTP 요청 또는 요청에 대한 HTTP 응답을 하게 되면 자연스럽게 사용

#### **4\. 구조**

(1) 시작줄 (Start Line)

\- 요청이나 응답의 상태를 나타내는 첫 번째 줄

(2) 헤더 (HTTP Headers)

\- 메시지 바디를 요약하는 헤더들의 집합

(3) 빈 줄 (Empty Line)

\- 헤더와 본문을 구분하기 위해 존재하는 빈 줄

\- 이전까지의 모든 헤더가 전송되었음을 알리고 본문 부분이 시작된다는 것을 의미

(4) 본문 (Body)

\- 데이터나 문서 등 실제 내용이 포함되며 HTML 문서, JSON 데이터 등이 본문에 담길 수 있음

### **5\. HTTP 요청 (Request)**



(1) 요청 헤더들

\- 클라이언트가 서버에게 요청을 보낼 때 함께 전송되는 헤더

\- 요청의 성격과 목적을 설명하고 부가적인 정보 제공

(2) 응답 헤더들

\- 서버가 클라이언트에게 응답을 보낼 때 포함하는 헤더

\- 상태 코드, 서버 정보, 클라이언트가 어떻게 응답을 처리해야 할지에 대한 정보 제공

(3) 일반적인 헤더들

\- 요청과 응답 모두에서 사용되는 일반적인 헤더

\- 메시지 전체에 대한 정보를 제공하며 캐시, 연결 유지 등과 관련된 설정 포함

(4) 대표 헤더들

\- 요청과 응답 메시지의 본문 데이터와 관련된 헤더

\- 데이터의 형식, 언어, 압축 등을 나타내어 클라이언트가 데이터를 올바르게 해석하고 처리할 수 있도록 도와줌

| Host | 요청하려는 서버 호스트 이름과 포트 번호 |
| --- | --- |
| User-Agent | 클라이언트 프로그램 정보 (브라우저 등) |
| Accept | 클라이언트가 처리 가능한 미디어 타입 종류 |
| Accept-Language | 클라이언트가 처리 가능한 언어 종류 |
| Accept-Encoding | 클라이언트가 서버로부터 응답을 받을 때 지원하는 데이터 압축 방식 |
| Connection | 클라이언트와 서버 간의 TCP 연결을 관리하는 방법을 지정 |
| Content-Type | 본문의 데이터 유형을 지정 |
| Content-Length | 본문 길이를 바이트 단위로 나타냄 |
| Upgrade-Insecure-Request | 브라우저에게 현재 보안되지 않은 HTTP 연결을 보안된 HTTPS 연결로 업그레이드하도록 요청하는 지시 |

### **6\. HTTP 응답 (Tesponse)**


(1) Server

-   서버 소프트웨어와 버전 정보 제공

(2) Content-Type

-   응답 본문의 데이터 유형과 문자 인코딩 방식 지정

(3)Age

-   캐싱된 응답의 수명을 초 단위로 나타냄

(4) X-Cache-Info

-   캐싱 프록시 서버가 요청에 대해 어떤 동작을 수행했는지를 나타냄

---

### **8️⃣  HTTP - Request Method**

#### **1\. 정의**

\- 웹 서버에 어떤 작업을 수행하길 원하는지 알리는 방법을 정의하는 명령 규칙

#### **2\. 사용 이유**

\- 웹 서버에게 구체적인 작업(자료 요청, 제출, 삭제 등)을 명확하게 지시하기 위

#### **3\. 사용 방법**

\- 웹 요청을 보낼 때, URL과 함께 GET, POST, PUT, PATCH, DELETE 메소드를 명시하여 서버에게 특정 작업을 요청

**(1) GET 메소드**

| 정의 | 서버로부터 데이터 조회를 요청할 때 사용하는 메소드 |
| --- | --- |
| 사용 이유 | 서버에게 데이터 조회를 요청하기 위함 |
| 사용 방법 | \- 요청 파라미터를 쿼리 스트링(Query String)의 형태로 URL에 포함시켜 전송   \- 서버는 GET 요청을 받으면 해당 URL에 대한 처리를 수행하고, 클라이언트에게 요청한 데이터를 응답으로 보냄 |
| 특징 | \- 클라이언트가 어떤 리소스(데이터)를 요청하는 것이기 때문에, 데이터의 생성, 수정, 삭제와 같은 변경 작업에서 사용되지 않음 |

> ❓ 쿼리 스트링(Query String)  
> \- 클라이언트에서 웹 페이지에 대한 추가 정보를 전달하기 위해 사용되는 문자열  
> \- 검색, 필터링, 정렬 등의 추가적 정보를 클라이언트에서 서버에 제공하기 위해 사용

**(2) POST 메서드**

| 정의 | 서버로 데이터를 전송하여 리소스를 생성하거나 업데이트할 때 사용하는 메소드 |
| --- | --- |
| 사용 이유 | 서버로 데이터를 전송하고, 리소스를 생성하거나 업데이트 하기 위해 |
| 사용 방법 | \- 요청 바디(Request Body)에 데이터를 첨부하여 전송   \- 서버는 POST 요청을 받으면 요청 바디의 데이터를 확인하고(파싱), 해당 데이터에 따른 처리를 수행한 후 응답을 클라이언트에게 보냄 |
| 특징 | 클라이언트가 서버에게 어떤 동작을 요청하는 것이기에 서버의 상태나 데이터 변경 가능 |

**(3) PUT 메서드**

| 정의 | 서버로 데이터를 전송하여 리소스를 전체 업데이트할 때 사용하는 메소드 |
| --- | --- |
| 사용 이유 | 서버로 데이터를 전송해 리소스 전체를 업데이트 하기 위해 |
| 사용 방법 | \- 요청 바디에 데이터를 첨부하여 전송   \- 서버는 PUT 요청을 받으면 요청 바디의 데이터를 파싱하고, 해당 데이터를 기반으로 리소스를 업데이트 |
| 특징 | 클라이언트가 서버에게 어떤 리소스(데이터)를 업데이트하도록 요청하는 것이므로, 리소스 전체를 업데이트할 때 사용 |

**(4) PATCH 메서드**

| 정의 | 서버의 리소스를 부분적으로 수정 또는 업데이트할 때 사용하는 메소드 |
| --- | --- |
| 사용 이유 | 서버의 리소스를 부분적으로 수정 또는 업데이트 하기 위해 |
| 사용 방법 | \- 요청 바디에 변경하고자 하는 데이터를 첨부하여 전송   \- 서버는 PATCH 요청을 받으면 요청 바디의 데이터를 파싱하고, 해당 리소스의 일부분을 수정 또는 업데이트 |
| 특징 | 클라이언트가 서버에게 리소스의 특정 부분만 변경하도록 요청하는 것이므로, 전체 리소스 대신 일부분만 수정할 때 사용됨 |

**(5) DELETE 메서드**

| 정의 | 서버로부터 리소스를 삭제할 때 사용하는 메소드 |
| --- | --- |
| 사용 이유 | 서버로부터 리소스를 삭제하기 위해서 |
| 사용 방법 | \- URL에 삭제하고자 하는 리소스의 식별자를 포함하여 전송   \- 서버는 DELETE 요청을 받으면 해당 리소스를 식별하고 삭제 |
| 특징 | 클라이언트가 서버에게 어떤 리소스(데이터)를 삭제하도록 요청하는 것이므로, 데이터의 삭제 작업에 사용 |

> **❓ 멱등성**  
> 연산이나 요청을 여러 번 반복해도 결과가 변하지 않는 성질  
>   
> GET: 같은 자원 요청 → 몇 번 해도 결과 같음 (멱등)  
> PUT: 특정 자원을 값으로 갱신 → 여러 번 해도 같은 상태 유지 (멱등)  
> DELETE: 같은 자원 삭제 요청 → 이미 지워져 있어도 결과는 “없음”  (멱등)  
> POST: 새로운 리소스 생성 → 여러 번 하면 데이터 중복 (멱등X)

---

### **9️⃣ HTTP - Status Code**

#### **1\. 정의**

\- 일반 문서를 뛰어넘는 구조화된 텍스트를 전송하기 위해 사용되는 통신 규약의 진행 상황을 표시하는 코드

#### **2\. 사용 이유**

\- 클라이언트가 웹 서버에 요청을 했을 때 통신 결과를 웹 서버가 클라이언트에게 명확하게 전달하기 위해

\- 클라이언트는 서버로부터 받은 상태 코드를 확인하여 요청 처리 상태를 파악하고, 이를 상황에 맞게 처리 가능

\- 상태 코드를 통해 사용자에게 적절한 안내나 오류 처리 제공 가능

#### **3\. 사용 방법**

\- 요청 처리 결과를 나타내는 HTTP 상태 코드를 응답 메시지의 헤더에 포함시켜 클라이언트에게 전송

\- 1xx: 정보 메시지

\- 2xx: 성공

\- 3xx: 리다이렉션

\- 4xx: 클라이언트 올

\- 5xx: 서버 오류

| **200** | 요청이 성공적으로 처리 되었음 |
| --- | --- |
| **201** | 요청이 성공적으로 처리 되었고, 그 결과로 새로운 리소스가 생성되었음 |
| **202** | 요청을 수신했지만, 그에 대한 처리를 할 수 없음   (다른 프로세스에서 처리 중이거나 서버가 요청을 처리하고 있는 경우) |
| **204** | 헤더는 유효하나, 요청에 대해 보내줄 수 있는 내용이 없음 |
|   |   |
| **400** | 잘못된 문법으로 인해 서버가 요청을 이해할 수 없음 |
| **401** | 인증되지 않은 접근 |
| **403** | 인가되지 않은 접근 |
| **404** | 요청받은 리소스를 찾을 수 없음 |
| **429** | 지정된 시간 안에 너무 많은 요청을 보냈음 |
|   |   |
| **500** | 서버가 처리 방법을 알 수 없음 |
| **501** | 요청 방법이 서버에서 지원되지 않아 처리할 수 없음 |
| **503** | 서버가 요청을 처리할 준비가 되지 않았음 (일시적 사용 불가능) |

> **❓인증, 인가**  
> \- 인증: 사용자의 신원을 확인하는 과정  
> \- 인가: 해당 사용자가 무엇을 할 수 있는지 권한을 부여하는 과정

---

### **1️⃣0️⃣ HTTP - URL**

#### **1\. 정의**

\- 리소스의 위치와 종류를 나타내는 주소

#### **2\. 사용 이유**

\- 웹 상의 리소스를 식별하고 접근하기 위해

#### **3\. 사용 방법**

\- URL을 입력하거나 링크를 클릭하여 사용


(1) 스키마

\- URL의 첫 번째 부분

(2) Domain, Prot

\- 도메인: 요청하는 웹 서버

\- 포트: 웹 서버의 리소스에 접근하는데 사용되는 게이트

(3) 리소스 경로

\- 웹 서버에 있는 리소스의 경로

(4) 매개변수(파라미터)

\- ? 뒤에 작성하고 &를 사용해 매개변수 구분

---

### **1️⃣1️⃣ Query String과 Path Variable**

#### **1\. 정의**

**(1) Query String**

\- 클라이언트에서 웹 페이지에 대한 추가 정보를 서버에 전달하기 위해 사용되는 문자열

**(2) Path Variable**

\- 경로 부분에 포함되어 있는, 특정 자원을 식별하는 변수 

#### **2\. 사용 이유**

(1) Query String

\- 검색, 필터링, 정렬, 페이지네이션 등의 추가적인 정보를 클라이언트에서 서버에 제공하기 위함

(2) Path Variable

\- 클라이언트에서 특정 리소스에 접근하기 위함

#### **3\. 사용 방법**

(1) Query String

\- URL 끝에 ? 기호를 붙이고, 그 뒤에 'key=value' 형태로 데이터 전달

\- 여러개의 파라미터가 있는 경우 &로 구분


(2) Path Variable

\- 리소스, 식별자 등을 URL 경로에 포함시켜 표현

---

### **1️⃣2️⃣ API (Application Programming Interface)**

#### **1\. 정의**

\- 응용 프로그램 인터페이스

\- 응용 프로그램 사이의 통신에 사용되는 언어나 메시지 형식

\- (내가 만드는) 애플리케이션과 (이미 만들어진) 애플리케이션이 서로 통신할 수 있도록 정의한 명세서

#### **2\. 사용 이유**

\- 서로 다른 시스템이나 애플리케이션 간에 데이터를 교환하고 기능을 공유하기 위함

#### **3\. 사용 방법**

\- 개발자가 API 문서를 참고하여 미리 정의된 명령어나 프로토콜을 활용해 특정 기능을 실행하거나 데이터 교환 가능

---

### **1️⃣3️⃣ REST API**

#### **1\. 정의**

> **❓ REST**  
> \- Representation State Transfer  
> \- 자원을 이름으로 식별하고, 해당 자원의 상태(정보)를 구조화된 형식으로 표현하여, 서버와 클라이언트 간에 정보를 교환하는 방식

\- REST 아키텍처 스타일을 따르는 응용 프로그램 인터페이스

#### **2\. REST 아키텍처 스타일**

(1) Uniform Interface

\- 모든 API가 일관된 방식으로 통신하도록 해서 사용하는데 있어 단순성과 상호 운용성을 보장해야 함

(2) Client-Server

\- 클라이언트와 서버가 독립적으로 구분되어 있고, 각각의 개발 확장이 편리하며, 사용자 인터페이스와 데이터 저장소가 분리 되어야  함 

(3) Stateless

\- 서버는 클라이언트의 상태 정보를 저장하지 않아야 함

\- 각각의 요청이 독립적이며 필요한 모든 정보를 포함해야 함

(4) Cacheable

\- 응답은 캐싱이 가능하도록 명시 되어야 함

(5) Layered System

\- 클라이언트는 서버가 단일 서버인지 다충 계층을 통해 데이터를 전달하는 중계서버를 거치는 지 알 수 없어야 함

(6) Self-Descriptivemess

\- 메세지 자체가 충분한 정보를 담고 있어, 클라이언트가 어떻게 처리해야할 지를 알 수 있어야 함

#### **2\. 사용 이유**

\- 개발자 간의 일관된 통신 규칙을 마련해 업무 효율을 높이고, 단순한 URL 구조를 통해 요청의 목적을 쉽게 이해할 수 있게 하기 위함

| 일관된 통신 규칙 제공 | \- HTTP 표준을 기반으로 통신 규칙을 제공하여 개발자 간의 협업을 원할하게 함   \- 코드의 가독성과 유지보수가 용이 |
| --- | --- |
| 단순한 URL 구조 | \- 자원을 명확히 표현하는 단순한 URL 구조를 통해 요청의 목적을 쉽게 파악할 수 있어, API 사용과 이해가 더욱 직관적 |
| 유연성과 확장성 | \- 클라이언트와 서버가 독립적으로 작동하므로, 서로 영향을 주지 않고 개별적으로 기능을 개발하거나 변경할 수 있어 시스템 설계가 더 유연 |
| HTTP 메서드 활용 | \- GET, POST, PUT, DELETE 등 HTTP 메서드를 사용하여 작업의 의도를 명확히 표현하므로, 데이터 처리 과정이 명확 |
| 다양한 플랫폼 지원 | \- REST API는 플랫폼에 종속되지 않아 웹, 모바일, 데스크톱 등 다양한 환경에서 활용할 수 있어 사용 범위가 넓고 접근성이 뛰어남 |

#### **3\. 사용 방법**

**(1) URL은 정보의 자원을 표현해야 함**

\- 리소스명은 동사가 아닌 명사를 사용

**(2) 자원의 행위는 HTTP 메소드(GET, POST, DELETE, PUT, PATCH)로 함**

**(3) 슬래시(/)는 계층 관계를 나타낼 때 사용**

**(4) 소문자를 사용**

**(5) 밑줄(\_)은 사용하지 않고 하이픈(-) 사용**

**(6) 확장자(.txt, .png 등)를 사용하지 않음**

**(7) URL의 마지막에 슬래시(/)를 포함하지 않음**
