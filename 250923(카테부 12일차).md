## **🧠 회고**

오늘 진짜 컨디션 최악... 몸 관리를 진짜 신경써야겠다는 생각을 했다. 

## **🪽 오늘의 다짐**

1.  컨디션 관리 잘하기
2.  1일 1코테 하기

---

## **📝 Today I Learned**

### **1\. Proxy Server**

#### **1\. 정의**

\- 클라이언트와 인터넷 사이의 중개 서버

> Proxy: 대리인

**(1) Proxy Server**

\- 클라이언트 측에서 인터넷 접근을 중계하는 역할

\- 클라이언트의 IP 주소를 은닉

\- 네트워크 접근을 제어

\- 자주 요청되는 리소스를 캐시하여 성능 향상

👉🏻 클라이언트를 위한 대리인

**(2) Reverse Proxy**

\- 웹 서버 측에서 요청을 처리하는 역할

\- 로드 밸런싱, 요청 필터링, 서버 은닉 등을 통해 성능을 향상 시키고 보안 강화

\- DDoS 공격 방지

\- 웹 애플리케이션 방화벽(WAF)을 통한 추가적인 보안 조치 제공

👉🏻 서버를 위한 대리인

#### **2\. 알아야하는 이유**

(1) 인프라 및 네트워크 구성의 이해

\- 네트워크 구조와 데이터 통신 방식 이해

   👉🏻 네트워크를 효율적으로 관리하고 최적화하는 데 도움 됨

(2) 성능 최적화 가능

\- 자주 사용하는 웹사이트의 데이터를 미리 저장해 두어 인터넷 속도 빠르게 가능

   👉🏻 보안 측면에서 중요한 역할

(3) 보안 강화

\- 실제 IP 주소를 숨김

\- 악성 사이트 차단

\- 특정 웹사이트에 대한 접근 차단 및 제한 가능

   👉🏻 네트워크 관리 용이

(4) 개발 및 디버깅 용이성

\- 트래픽을 모니터링하고 분석할 수 있어 문제를 쉽게 찾아 해결 가능

#### **3\. 동작 방식**

\- 사용자와 인터넷 사이에서 중개자 역할

\- 사용자의 요청을 대신하여 인터넷 리소스에 접근하고 결과를 사용자에게 반환

**(1) 클라이언트 요청**

\- 사용자가 웹 브라우저에서 특정 웹사이트에 접속하려고 하면, 이 요청은 먼저 프록시 서버로 전달 됨

\- 클라이언트는 실제 서버의 IP 주소 대신 프록시 서버의 IP 주소로 요청 보냄

**(2) 프록시 서버 처리**

\- 프록시 서버는 클라이언트로부터 받은 요청 확인

\- 요청된 데이터가 프록시 서버의 캐시에 저장되어 있는 경우

    👉🏻 인터넷을 통해 데이터를 가져올 필요 없이 캐시에서 직접 데이터 반환

**(3) 인터넷으로 요청 전달** 

\- 요청된 데이터가 프록시 서버의 캐시에 없는 경우

  👉🏻 클라이언트의 요청을 실제 웹 서버로 전달

\- 프록시 서버는 클라이언트의 IP 주소를 숨기고 자신의 IP 주소로 요청을 보냄

**(4) 서버 응답 수신**

\- 실제 웹 서버는 요청을 처리하고, 응답 데이터를 프록시 서버로 보냄

\- 프록시 서버는 이 응답 데이터를 수신

**(5) 클라이언트로 응답 전달**

\- 프록시 서버는 수신한 응답 데이터를 클라이언트로 반환

\- 자주 요청되는 데이터는 프록시 서버의 캐시에 저장

   👉🏻 다음 요청 시 더 빠르게 응답 가능

**(6) 캐싱 및 필터링**

\- 프록시 서버는 자주 요청되는 데이터를 캐시에 저장하여 성능 최적화

\- 특정 웹사이트에 대한 접근 차단

\- 악성 트래픽을 필터링하여 보안 강화

\=> 프록시 서버는 클라이언트와 실제 서버 사이에서 중개 역할을 함

\=> 클라이언트의 요청을 받아 캐시를 확인하고, 필요시 실제 서버에 요청을 전달하며, 응답을 받아 클라이언트로 전달함

\=> 이 과정에서 성능 향상, 보안 강화, 트래픽 모니터링 등의 다양한 기능 수행

#### **4\. Forward Proxy와  Reverse Proxy 비교**

**(1) 기본**

|   | **Forward Proxy** | **Reverse Proxy** |
| --- | --- | --- |
| **유형** | 클라이언트 성능 및 보안 강화 | \- 웹 서버 성능 향상   \- 부하 완화 및 보안 |
| **주요 역할** | 클라이언트 요청 중계 | 서버 요청 및 응답 중계 |
| **요청 보내는/ 받는 측** | 클라이언트 (웹 브라우저) | 웹 서버 |
| **주요 가능** | \- 클라이언트 은닉   \- 접근 제어   \- 캐싱 | \- 요청 반환 (Header 세팅 등)   \- 요청 전달 (URL Mapping, 로드 밸런싱)   \- 서버 은닉   \- 서버 접근 제어 (요청 필터) |
| **보안 및 성능** | \- 클라이언트 IP 변환   \- 특정 IP/웹 페이지 접근 금지 | \- 서버 부하 완화 (로드 밸런싱)   \- DDoS 방지 (Rate Limiting, WAF) |
| **특별 사항** | 개인이 소비하는 입장에서의 요청 캐싱 | \- 웹 서버의 수 동적 조절 (고가용성)   \- 트래픽 제어 및 악성 IP 차단 |

**(2) 기능**

|   | **Forward Proxy** | **Reverse Proxy** |
| --- | --- | --- |
| **클라이언트 은닉** | 원 요청자의 IP를 숨기고 프록시 서버의 IP 주소로 변경하여 인터넷 접속   👉🏻 사용자의 실제 위치와 신원 보호 | 서버의 실제 IP 주소와 위치를 숨김   👉🏻 외부로부터의 직접적인 접근 차단 및 보안 강화 |
| **접근 제어** | 특정 웹 사이트나 서비스에 대한 접근 제어   👉🏻 조직의 인터넷 사용 정책 강제   👉🏻 부적절한 콘텐츠에 대한 접근 차단 | 웹 애플리케이션에 대한 요청 검사하고 필터링   👉🏻 DDoS 공격과 같은 악성 트래픽 접근 제한, 서버 보호 |
| **캐싱** | 자주 요청되는 웹 페이지나 리소스를 프록스 서버에 임시 저장   👉🏻 동일한 요청이 있을 때 빠르게 제공하여 성능 향상 | 웹 서버에 제공하는 정적 콘텐츠 캐싱   👉🏻 로드 밸런싱과 함께 웹 서비스의 응답 속도 개선 |

**(3) 보안 및 성능**

|   | **Forward Proxy** | **Reverse Proxy** |
| --- | --- | --- |
| **IP 변환** | 사용자의 실제 IP를 숨기고 프록시 서버를 통해 인터넷 접속   👉🏻 개인정보 보호, 익명성 제공 |   |
| **특정 IP/웹 페이지 접근 금지** | 부적절하거나 위험한 웹 사이트에 대한 접근 차단   👉🏻 네트워크 보안과 사용자 보호 강화 |   |

**(3) 특별한 사항**

|   | **Forward Proxy** | **Reverse Proxy** |
| --- | --- | --- |
| **개인이 소비하는 입장에서의 요청 캐싱** | 개인 사용자의 인터넷 사용 경험을 최적화 하기 위해, 자주 접근하는 웹 리소스를 로컬에서 빠르게 로드할 수 있도록 함 |   |
| **로드 밸런싱 (요청 분산)** |   | 여러대의 웹 서버에 걸쳐 트래픽을 균등하게 분산   👉🏻 서버 부하 줄임   👉🏻 전체적인 웹 애플리케이션의 가용성과 성능 향상 |
| **서버 부하 완화** |   | \- 로드 밸런싱을 통해 웹 서버의 부하를 효과적으로 관리   \- 트래픽이 급증하는 상황에서도 비즈니스 안정성 유지 |

#### **5\. WAF (Web Application Firewall)**

**(1) 정의**

\- 웹 애플리 케이션을 보호하기 위해 설계된 보안 시스템

**(2) 사용 이유**

\- 웹 사이트나 애플리케이션을 SQL 인젝션, 크로스 사이트 스크립팅(XSS), 기타 취약점 공격으로부터 보호하기 위해

> ❓크로스 사이트 스크립팅(XSS)  
> \- 웹 애플리케이션 보안 취약점, 악의적 스크립트를 웹 페이지에 삽입하여 사용자 정보 탈취  
> \- Reflected XSS, Stored XSS, DOM-based XSS

**(3) 사용방법**

\- WAF를 웹 애플리케이션 앞단에 배치

👉🏻 Honeypot 시스템 또는 기타 보안 소스에서 수집된 악성 IP 리스트 활용하여 이러한 주소로부터 오는 요청 자동 차단

(알려진 위협 소스로부터의 공격을 효과적으로 방어)

> ❓ Honeypot  
> \- 비정상적인 접근을 탐지하기 위해 의도적으로 설치해 둔 유인 시스템

👉🏻 관리자가 직접 정의한 Custom IP 를 수동 차단

(악성 크롤링 봇, 스팸 발송 IP 등 특정 위협 요소로 판단되는 IP 주소를 수동으로 차단리스트에 추가)

(보안 정책을 보다 유연하게 관리 및 특정 위협에 대응 가능)

**(4) 일반 방화벽과 비교**

\- 보호 대상

-   WAF: 웹 애플리케이션을 대상으로 하는 특정 공격 유형 방어하는데 집중
-   일반 방화벽: 네트워크 전체의 보안을 목표로 하며 더 광범위한 트래픽 관리 기능 제공됨

\- 작동 수준

-   WAF: 애플리케이션 계층 (주로 7계층)에서 작동하여 웹 애플리케이션의 보안 강화
-   일반 방화벽: 네트워크 계층 (주로 3~4계층)에서 작동하여 네트워크의 트래픽 제어

\- 필터링 방식

-   WAF: 웹 애플리케이션의 로직과 사용자의 입력 데이터를 분석하여 악의적인 웹 요청 차단
-   일반 방화벽: IP 주소, 포트, 프로토콜 등을 기준으로 트래픽을 필터링 함

#### **6\. Cross-site request forgery(XSRF, CSPF)**

**(1) 정의**

\- 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위를 웹 애플리케이션에서 실행하도록 만드는 공격 기법

**(2) 사용 이유**

\- 사용자의 세션을 이용하여 인증된 사용자의 권한으로 악의적인 변경 요청을 발생시키기 위함

**(3) 사용 방법**

\- 공격자는 이메일, 채팅, 웹 페이지 등을 통해 사용자가 클릭하도록 유도한 링크 또는 스크립트를 사용하여 공격 실행

-   **XSRF = CSRF**
    -   Cross-Site Request Forgery (요청 위조)
    -   로그인된 사용자의 권한을 악용해 서버에 몰래 요청을 보냄
-   **CSPF**
    -   Cross-Site Printing Forgery (프린터 위조)
    -   CSRF 원리를 응용해서 네트워크 프린터 같은 장비에 몰래 출력 명령을 내림

#### **7\. VPN과 프록시 서버의 차이점**

**(1) VPN**

\- 목적

-   공용 네트워크를 통해 사설 네트워크를 안전하게 연결
-   인터넷 사용 시 보안을 강화하고 지역 제한을 우회하기 위함

\- 설명

-   사용자의 모든 인터넷 트래픽을 암호화하여 터널을 통해 전달
-   사용자는 마치 다른 네트워크에 직접 연결된 것 처럼 동작
-   IP 주소도 VPN 서버의 것으로 변경

\- 동작방식

-   VPN 클라이언트 소프트웨어를 통해 VPN 서버와 암호화된 연결을 수립하고, 모든 트래픽을 이 연결을 통해 전달

**(2) 프록시 서버**

\- 목적

-   클라이언트와 목적지 서버 사이에서 중재자로 동작하며 특정 트래픽을 대리 처리
-   캐싱, 필터링, 익명성 제공 등의 기능 수행

\- 설명

-   특정 애플리케이션이나 프로토콜의 트래픽만 중계
-   사용자의 IP 주소를 숨기거나 접근 속도를 향상시키는 데 사용

\- 동작방식

-   클라이언트가 프록시 서버에 요청을 보내면, 프록시 서버가 이를 받아 실제 목적지 서버에 요청하고, 그 응답을 클라이언트에게 전달

**(3) 주요 차이점**

\- 트래픽 처리 범위

-   VPN: 시스템 전체의 네트워크 트래픽을 암호화하고 중계
-   프록시: 특정 애플리케이션이나 프로토콜의 트래픽만 중계

\- 보안 및 암호화

-   VPN: 모든 트래픽을 암호화하여 보안 강화
-   프록시: 일반적으로 트래픽을 암호화하지 않으며, 보안 강화가 목적이 아닐 수 있음

\- 사용 목적

-   VPN: 보안 접속, 원격 근무, 지역 제한 콘텐츠 접근 등에 사용
-   프록시: 캐싱을 통한 속도 향상, 웹 필터링, 익명성 제공 등에 사용

---

### **2️⃣ TCP / UDP**

#### **1\. 정의**

**(1) TCP**

\- 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜

\- 인터넷 상에서 데이터를 안정적으로, 순서대로, 에러 없이 교환할 수 있는 통신 프로토콜

\- 데이터가 목적지에 정확하게 도달했는지 확인 후, 손실된 부분이 있다면 다시 전송 요청

\- 3-way handshake 과정을 통해 이루어짐

\- TCP가 신뢰성 있는 통신을 보장하는 데 핵심적인 역할 함

**(2) UDP**

\- 빠르고 간단한 통신을 위해 연결 설정 없이 데이터를 전송하는 네트워크 프로토콜

\- TCP와 다르게 연결을 설정하지 않고 데이터 전송

\- 데이터 전송 과정을 신속하게 하지만, TCP 보단 신뢰성이 낮음

\- 데이터가 도착했는지 확인하지 않고, 순서를 보장하지도 않음

\- 실시간 애플리케이션 (비디오 스트리밍, 온라인 게임)에서 자주 사용

\- 높은 네트워크 효율성이 요구될 때 유리

#### **2\. 알아야 하는 이유**

(1) TCP

\- 안정적이고 신뢰할 수 있는 데이터 통신을 보장하기 위함

(2) UDP

\- 지연 시간이 짧고, 빠르게 데이터를 전송해야하는 상황에 사용하기 위함

#### **3\. TCP 동작 방식**

**(1) 연결 설정 (3-way handshake)**

\- 데이터 전송을 시작하기 전에 TCP는 송신자와 수신자 간에 연결을 설정

\- 3-way handshake 진행되어 서로의 준비 상태 확인

-   SYN: 클라이언트가 서버로 연결 요청을 보내고 (SYN 패킷) , 자신의 초기 시퀀스 번호를 알림
-   SYN-ACK: 서버가 이 요청을 수락하고, 클라이언트의 시퀀스 번호에 1을 더한 값과 자신의 초기 시퀀스 번호를 포함한 패킷(SYN-ACK 패킷)을 보냄
-   ACK: 클라이언트가 서버의 시퀀스 번호에 1을 더한 값을 확인 응답으로 보내며 연결이 성립

**(2) 데이터 전송**

\- 연결이 성립되면, 데이터를 세그먼트 형태로 나누어 순차적 전송

\- 각 세그먼트에는 시퀀스 번호가 부여되어 수신자가 데이터를 올바른 순서대로 재조합

**(3) 신뢰성 있는 전송**

\- TCP는 데이터가 정확하게 전달되었는지 확인하기 위해 확인 응답 (ACK)을 사용

\- 수신자는 데이터를 받을 때마다 ACK를 보내 송신자에게 도착 알림

\- 만약 ACK가 일정 시간 내에 도착하지 않으면 해당 데이터를 재전송

**(4) 흐름 제어 및 혼잡 제어**

\- 네트워크의 혼잡 상황이나 수신자의 처리 능력을 고려하여 데이터 전송 속도 조절

\- 데이터 손실 최소화 및 전송 효율 최대화

**(5) 연결 종료**

\- 데이터 전송이 완료된 후에는 양쪽 모두가 연결을 종료할 준비가 되었음을 확인하고 4단계의 핸드셰이크를 통해 연결 종료

#### **4\. UDP 동작 방식**

**(1) 데이터그램 전송**

\- UDP는 데이터를 '데이터그램'이라고 하는 독립적인 패킷 형태로 전송

\- 각 데이터그램은 목적지 주소와 포트 정보를 포함하고 있어 네트워크를 통해 독립적으로 전송됨

**(2) 비신뢰성 및 비연결성**

\- 전송된 데이터그램의 도착을 보장하지 않으며, 도착 순서 또한 보장하지 않음

\- 데이터가 손실되거나 순서가 바뀌어도 복구하지 않음

**(3) 빠른 전송**

\- 이런 간소화된 접근 방식은 프로토콜 오버헤드를 줄여 네트워크 지연을 최소화하고 전송 속도를 빠르게 함

#### **5\. TCP vs UDP**

|   | **TCP** | **UDP** |
| --- | --- | --- |
| **신뢰성** | 메시지 수신 확인 | 수신자가 메시지를 수신했는지 확인할 수 없음 |
| **순서 정렬** | 메시지가 보내진 순서를 보장하기 위해 재조립 | 메시지 도착 순서를 예측할 수 없음 |
| **부하** | 속도: 일반적으로 빠름   오버헤드: 적음 |   |

---

### **3️⃣  3-way Handshake**

#### **1\. 정의**

\- 네트워크 연결 절차

\- TCP/IP 네트워크 프로토콜에서 연결을 초기화하는 과정

\- 클라이언트, 서버 모두 전송할 준비가 되었다는 것을 보장하기 위한 것

#### **2\. 알아야 하는 이유**

\- 브라우저와 서버가 어떻게 통신하는지에 대해 이해하여 통신상 발생할 수 있는 문제를 해결하기 위함

#### **3\. 동작 방식**

**(1) SYN (Synchronize) 단계**

\- 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 전송함

\- 이 패킷에는 클라이언트가 세션을 시작할 준비가 되었다는 신호와 함께, 클라이언트의 초기 시퀀스 번호가 포함됨

**(2) SYN-ACK (Synchronize-Acknowledgment) 단계**

\- 서버는 클라이언트의 SYN 요청을 받고, 클라이언트에게 SYN-ACK 패킷을 보냄

\- 이 패킷은 서버가 클라이언트의 요청을 수락했으며, 서버도 연결 준비가 되었다는 것을 의미

\- 서버의 초기 시퀀스 번호도 포함되어 있음

**(3) ACK (Acknowledgement) 단계**

\- 클라이언트는 서버로부터 SYN-ACK 패킷을 받고, 서버에게 ACK 패킷을 전송

\- 클라이언트가 서버의 시퀀스 번호를 받았으며, 이제 클라이언트와 서버 간의 연결이 정상적으로 쉽되었다는 것을 확인시킴

**(4) 연결 수립 후 데이터 전송**

\- 3-way Handshake가 성공적으로 완료되면, 클라이언트와 서버 간에 안정적인 TCP 연결이 수립됨

\- 이제 데이터를 안전하게 주고받을 준비 완료!

> **❓ SYN (Synchronize)**  
> \- TCP/IP 네트워크에서 연결을 초기화할 떄 사용되는 동기화(synchronize) 신호

> **❓ ACK (Acknowledgment)**  
> \- 승인을 서명하거나, 응답을 보내기 위해, 통신 프로토콜의 일부로서 통신 프로세서나 컴퓨터 사이를 지나가는 신호

> **❓ ESABLISHED**  
> \- TCP/IP 네트워크 연결에서 양쪽 시스템이 서로의 연결 요청을 확인하고, 데이터 전송 준비가 완료된 상태

> **❓ SYN\_RCVD (SYN\_RECEIVED)**  
> \- TCP/IP 네트워크 연결 과정에서 초기 연결 요청(SYN)을 받고 응답(SYN-ACK)을 보낸 상태  
> \- 연결 수립 과정의 일부를 나타내는 상태
