🧠 회고
컨디션이 언제쯤 나아질까?.. 그래도 복습은 꼬박꼬박하고 있긴한데 몸이 마음대로 따라주지 않으니까 너무 슬프다 머리도 멍하고...

하지만 이겨내야겠지! 힘들수록 파이팅... 그리고 오늘은 좋은 일이 있어서 기분이 좋았다 이 기세로 더욱 열심히!



🪽 오늘의 다짐
컨디션 관리 잘하기
미루지 않기
📝 Today I Learned
1. HTTP Cache
1. 정의
- HTTP: 웹 서버와 클라이언트 간에 데이터를 전송하기 위해 사용되는 프로토콜

- Cache: 데이터 또는 명령어를 미리 복사해 두고, 빠르게 접근할 수 있도록 하는 임시 저장소

- 웹 페이지, 이미지, 기타 미디어 파일 등 웹 리소스들을 사용자의 브라우저나 서버에 임시로 저장해두는 기술



2. 알아야 하는 이유
(1) 성능 최적화

- 로딩 시간 단축: 적절한 캐싱 전략으로 웹 페이지 로딩 시간 단축, 서버 부하 감소



(2) 비용 절감

- 네트워크 대역폭 사용 감소: 캐시를 통해 데이터 재사용, 대용량 파일 서비스에서 비용 절감



(3) 사용자 경험 향상

- 빠른 인터랙티비티 제공: 사용자가 콘텐츠에 빠르게 접근, 오프라인 경험 제공



(4) 개발 및 유지보수 효율성

- 개발 프로세스 개선: 캐싱 전량 및 적용으로 성능 문제 예방, 확장성 및 유지보수 용이성





3. 동작 방식
(1) 요청 캐시 검사

- 클라이언트가 서버에 리소스를 요청할 떄, 브라우저는 먼저 캐시에 해당 리소스가 있는지 확인



(2) 만료 검사

- 캐시된 리소스가 만료되었는지 확인

- 만료되지 않았다면, 캐시된 리소스 사용



(3) 조건부 요청

- 캐시된 리소스가 만료되었거나 유효하지 않으면, 서버에 조건부 요청을 보내어 리소스가 변경되었는지 확인



(4) 새 리소스 저장

- 서버가 최신 리소스를 제공하면, 이를 캐시에 저장하고 클라이언트에 응답



(5) 캐시 제어

- 서버와 클라이언트는 HTTP 헤더를 통해 캐시 동작 제어

- Cache-Control, Expires, ETag



4. Cache-Control 헤더
(1) Cache-Control: no-store

- 캐시 불가

- 웹 서버가 특정 자원에 대해 캐싱을 금지하고 싶을 때 사용



(2) Cache-Control: max-age=3600

- 캐시 만료 시간 설정

- 웹 서버가 자원을 3600초(1시간)동안 캐시하도록 지시할 때 사용



(3) Cache-Control: must-revalidate

- 재검증 필요

- 웹 서버가 캐시된 자원이 만료되었을 때, 서버에 재검증 하도록 지시

- 캐시된 복사본을 사용하기 전에 서버에게 확인을 요청

- 서버와의 연결 문제나 기타 이유로 재검증 요청 실패

   👉🏻 504 Gateway Timeout 에러 반환

❓504 Gateway Timeout 에러
- 웹 서버가 다른 서버나 게이트웨이에서 응답을 기다리는 동안 정해진 시간을 초과했을 때 발생하는 HTTP 상태 코드
❓Gateway
- 컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 컴퓨터나 소프트웨어


(4) Cache-Control: public

- 공개 캐시 가능

- 자원이 공개 캐시(프록시 서버)에 의해 저장될 수 있음을 나타냄



(5) Cache-Control: private 

- 프라이빗 캐시만 가능

- 자원이 사용자의 브라우저와 같은 프라이빗 캐시에만 저장될 수 있음을 나타냄



(6) Cache-Control: no-cache

- 사전 검증

- 웹 서버가 자원이 아직 유효한지 확인하기 위해 클라이언트의 사전 검증을 요청할 때 사용

- 모든 캐시를 쓰기 전에 서버에 이 캐시를 써도 되냐고 물어보라는 뜻

  👉🏻 캐시된 데이터를 활용하면서 동시에 데이터의 최신성과 정확성을 보장하기 위함



❓ 캐시를 사용하지 않는 경우
- 사용자의 상호작용에 따라 실시간으로 변화해야 하는 데이터를 처리할 때
- 인스타그램 새로운 팔로우 요청, 메시지


❓ 캐시된 데이터의 재검증
- 웹 서버에서 데이터의 최신 상태를 확인하는 과정
❓ 캐시된 데이터의 재검증 주기
- 데ㅣ터의 변경 빈도와 중요도에 따라 결정
❓캐시된 데이터의 재검증 기준
- 수정 일자나 데이터의 해시 값
❓ 412 Precondition Faild 상태 코드
- If-Unmodified-Since 헤더를 사용할 때 적용
- 클라이언트가 서버에 데이터를 수정하거나 업데이트할 때, 그 데이터가 클라이언트가 마지막으로 확인했던 시점 이후에 수정되지 않았다는 것을 조건으로 요구할 때 사용
- 만약 그 데이터가 변경되었다면 412 Precondition Faild 응답을 반환하여 요청 거부
- 데이터 일관성을 유지하고, 클라이언트와 서버 간의 충돌을 방지하기 위해 사용






5. SWR (Stale-While-Revalidate) 전략
(1) 정의

- 캐시가 만료된 후에도 즉시 그 데이터를 사용자에게 제공하면서 동시에 서버에게 해당 데이터의 최신 버전을 요청하는 방식

- 캐시된 데이터를 'stale'(오래된) 상태로 제공

  👉🏻 사용자에게는 서비스 중단이나 지연 없이 빠르게 컨텐츠를 보여줌

  👉🏻  백그라운드에서 'revalidate'(재검증)과정을 수행하여 데이터를 최신상태로 갱신

- 사용자 경험의 중단 없이 웹 애플리케이션의 응답성을 유지하며, 데이터의 정확성과 신선도 보장

- 사용자는 만료된 데이터를 받아볼 수 있지만, 거의 동시에 애플리케이션이 데이터의 최신 버전을 서버로부터 가져와 업데이트



(2) 알아야 하는 이유

- 즉시성과 최신성의 균형

사용자는 데이터의 신선도가 다소 떨어질 수 있음에도 불구하고 즉시 접근 가능
사용자의 경험을 저해하지 않으면서 데이터를 최신 상태로 유지 가능
- 향상된 사용자 경험

즉각적인 데이터 접근은 웹페이지의 반응성 크게 향상
사용자가 대기 시간 없이 콘텐츠를 즉시 볼 수 있도록 함
- 백그라운드 데이터 갱신

사용자의 활동을 방해하지 않으면서 서버가 데이터를 조용히 업데이트할 수 있어, 데이터 관리의 효율성 증가


(3) 동작 방식

- 웹 사이트에서의 콘텐츠 표시

웹사이트가 뉴스 기사나 블로그 포스트 같이 정기적으로 업데이트되는 콘텐츠를 다룰 때, 사용자가 페이지를 방문할 때 마다 가장 최근에 캐시된 버전을 즉시 보여주고, 페이지의 배경에서 새로운 데이터를 서버로부터 불러와 갱신
- 실제 동작 방식

초기 콘텐츠 로딩
사용자가 페이지에 접속하면, 즉시 캐시된 콘텐츠가 표시됨
이 시점에서의 콘텐츠는 이전에 서버로부터 받아 캐시된 데이터
백그라운드에서의 데이터 갱신
페이지가 로드된 후, 웹 애플리케이션이 백그라운드에서 서버로부터 최신 데이터 요청
사용자의 인터랙션을 방해하지 않음
데이터 업데이트 표시
새로운 데이터가 서버로부터 수신되면, 웹 페이지는 자동으로 이를 반영하여 콘텐츠를 업데이트










2️⃣ Cookie, Storage (feat. Session)
1. Cookie의 정의
- 인터넷 사용자가 웹 사이트를 방문할 경우 사이트가 사용하고 있는 서버를 통해 인터넷 사용자의 컴퓨터에 설치되는 작은 기록 정보 파일

- HTTP의 Stateless 특성: HTTP 프로토콜이 각 요청을 독립적으로 처리하며, 이전의 요청 상태를 기억하지 않음

   👉🏻 웹 서버는 매 요청을 새로운 요청으로 간주하고, 이전 요청과 연결된 상태 정보를 유지하지 않음

- HTTP가 Stateful (연속성)을 가지려면

   👉🏻 웹 서버가 요청을 보낸 웹 브라우저를 식별할 수 있어야 됨

   👉🏻 웹 브라우저가 다음 요청을 보낼 때 이 쿠키 정보를 함께 전송하여 서버가 이전 사용자와 현재 사용자를 연결할 수 있게 도와줌



(1) 퍼스트파티 쿠키

- 사용자가 직접 방문한 웹사이트에서 설정한 쿠키

- 웹사이트의 도메인과 쿠키가 설정된 도메인이 동일한 경우

- 웹사이트 자체의 기능향상을 위해 사용

  👉🏻 사용자 세션 관리, 장바구니 정보 저장, 로그인 상태 유지, 사용자 선호도 설정



(2) 서드파티 쿠키

- 사용자가 방문 중인 웹사이트의 도메인과 다른 도메인에서 설정한 쿠키

- 웹사이트 도메인과 쿠키 도메인이 다를 때 발생

- 광고 네트워크나 소셜 미디어 플랫폼 등 제 3자에 의해 설정

- 여러 웹사이트에서 사용자의 행동을 추적하여 광고 타겟팅, 웹 분석, 소셜 미디어 기능 등을 제공하는데 사용



(3) 차이점

- 퍼스트파티 쿠키: 주로 편리한 사용자 경험을 지원

- 서드파티 쿠키: 개인화된 광고와 웹 분석 등 다양한 제 3자 서비스를 위해 활용





2. Cookie 사용 이유
- 웹 사이트의 방문 정보를 기억해 개인화 된 서비스를 제공하기 위함



3. Cookie 사용 방법
- 사용자의 브라우저에 텍스트 파일 형태로 정보를 저장하고, 필요할 때 이 정보를 다시 읽음

- 쿠키의 동작 방식: 웹 서버의 제어 + 웹 브라우저 내 저장 및 전송

❓웹 서버의 제어
- Set-Cookie 헤더를 통해 어떤 데이터를 쿠키로 쓸 것인지, 유효 시간 및 보안 설정


- 쿠키 사용 기준: Domain + Path

웹 브라우저가 쿠키를 웹 서버에게 전송하는 기준
- 쿠키 유효 시간 (MaxAge or Expires)

Persistent Cookie
유효기간이 명시되어 있는 쿠키
브라우저를 닫아도 삭제되지 않음
Maxage 또는 Expires 옵션을 사용하여 유효시간 설정
Session Cookie
유효시간이 명시되어 있지 않은 쿠키
브라우저가 닫히면 삭제됨
브라우저를 닫을 때 자동으로 삭제되므로, 주로 로그인 유지에 사용


4. 쿠키의 단점
문제	설명	해결 방안
보안 문제	쿠키는 민감 정보 노출의 위험 있음	HttpOnly, Secure, SameSite 속성 설정, 서버 측 암호화 사용, 보안 정보는 세션에 저장하는 것을 권장
브라우저 간 공유 불가 (여러 디바이스X)	쿠키는 저장된 브라우저 내에서만 작동	- 세션 ID를 쿠키로 저장
- 서버에서 사용자 식별 정보 관리
네트워크 부하 증가	모든 요청에 쿠키가 자동으로 첨부되어 네트워크 부하가 증가	웹 스토리지(localStorage, sessionStorage) 사용


- 보안 문제

속성	사용 이유	사용방법
HttpOnly	자바스크립트를 통한 쿠키 접근을 차단하여,
XSS 공격으로부터 쿠키 정보를 보호하기 위함	Set-Cookie: sessionid=xyz; HttpOnly
Secure	쿠키가 HTTPS를 통해서만 전송되도록 하여,
데이터가 암호화된 연결을 통해서만 전송되게 함으로써 보안 강화	Set-Cookie: sessionid=xyz; Secure
SameSite	CSRF 공격을 방지하기 위해,
쿠키가 퍼스트파티에서만 전송되도록 제한하는 용도로 사용	Set-Cookie: sessionid=xyz; SameSite


- SameSite 옵션 상세 설명

옵션	설명	SameSite 작동 방식
Strict	- 퍼스트파티 쿠키 전송만 허용
- 사용자가 직접 방문한 웹사이트에서만 쿠키 전송	쿠키는 동일한 도메인의 요청에서만 전송
Lax	- 사이트 직접 방문 혹은 GET 요청에서 서드파티 쿠키의 전송을 허용
- 주로 링크 클릭 시 쿠키 전송 허용	1. 도메인이 완전 동일할 때
2. 안전한 get 요청일 때
None	- 모든 서드파티 쿠키 허용
- 반드시 Secure 옵션(http)이 설정된 상태에서만 작동	1. 도메인이 같이 안아도 동작, 단 Secure 옵션이 동작해야 함
❓ 안전한 GET 요청
서버에 있는 데이터를 읽기만 하고, 그 외의 변화(추가/삭제/수정)를 일으키지 않는 조회용 요청


❓ XSS 공격
- 악성 스크립트를 웹페이지에 주입해 다른 사용자의 브라우저에서 실행되도록 하는 취약점
- 세션 탈취·피싱·권한 도용 등의 위험을 초래
❓ CSRF (Cross-Site Request Forgery) 공격
- 교차 사이트 요청 위조
- 사용자가 신뢰하는 사이트에 이미 로그인된 상태를 악용해, 공격자가 사용자의 권한으로 그 사이트에 원치 않는 요청 (송금·설정 변경 등)을 보내게 만드는 공격.






5. Storge 정의
- 컴퓨터에서 데이터를 일시적으로, 또는 영구히 보존하는 장치

- 웹 브라우저에 저장되는 데이터 저장소로, 사용자에 의해 변경된 옵션 상태 등 필요에 따라 조회가 필요한 정보 저장

- 쿠키: 웹서버에게 웹 브라우저가 매번 전달해야 하는 정보의 저장소로, 로그이 ㄴ정보 등 매 요청마다 서버에 전달해야 하는 데이터 저장



- 유효기간에 따른 두 가지

(1) 로컬 스토리지

- 웹 브라우저 창을 닫아도 데이터가 영구적으로 저장

- 장기적으로 유지되어야 하는 데이터 저장하는데 적합 (사용자 설정, 테마, 즐겨찾기)

- 저장 용량에 대한 관리 필요

- 과도한 데이터 저장은 성능 저하 유발



(2) 세션 스토리지

- 웹 브라우저 창을 닫으면 데이터 삭제

- 일시적인 상태 정보나 페이지 간의 데이터 전달 등 세션 동안에만 필요한 데이터 저장하는 데 사용

- 사용자 경험을 향상시키기 위해 일시적인 데이터를 관리하는 데 유용




유효시간	설명
로컬 스토리지	웹 브라우저 창이 닫혀도 데이터가 지속적으로 저장됨	사용자가 마지막으로 사용한 로그인 방법 저장
세션 스토리지	웹 브라우저 창이 닫히면 데이터가 자동으로 삭제됨	단발적이지만 중요한 데이터를 임시 저장




- 스토리지와 쿠키의 올바른 활용

스토리지
사용자 환경 설정이나 일시적인 데이터 저장에 적합
클라이언트 측에서만 접근 가능한 데이터 저장소이며, 서버로 자동 전송되지 않기에
쿠키
웹 브라우저가 매번 서버로 전달하는 데이터
세션 유지나 인증 정보 등 서버 측에서 필요한 상태 정보를 저장하는 데 사용




6. 사용 이유
- 데이터를 안전하게 보관하고, 언제든지 쉽게 찾아서 사용할 수 있도록 하기 위함



7. 사용 방법
- 데이터를 스토리지에 저장하고, 필요할 때 검색하여 사용







8. 세션의 정의
- 컴퓨터 프로세스 사이에서, 서로를 인식한 후 데이터 송수신을 마칠 때까지의 기간의 상태 정보

- 웹 서버 측에 별도의 저장소(Database)가 필요

- 쿠키의 역할: 웹 브라우저의 쿠키에는 어떤 세션인지 식별하기 위한 세션 ID 값이 저장되어 있음

- 세션의 역할: 일반적으로 웹 브라우저로부터 세션 ID를 받아 해당 요청 사용자의 정보를 서버 측 저장소에서 조회





9. 세션 사용 이유
- 사용자의 정보를 서버측에서 관리해 보안을 강화하고, 사용자 별 맞춤형 정보를 제공하기 위함



(1) 민감 정보의 안전한 저장

쿠키
쿠키 정보는 웹 브라우저에 저장되므로 민감한 정보가 안전하지 않은 상태로 저장될 수 있음
쿠키는 웹 브라우저 단위의 저장소이기 때문에 웹 브라우저 간의 공유가 불가능하여 지역성 문제 발생
세션
정보를 웹 서버 측에 저장하므로 쿠키에 비해 상대적으로 민감한 부분 안전하게 관리
웹 브라우저 간에 공유가 가능하여 사용자 경험 향상


(2) 네트워크 오버헤드 감소

쿠키
Domain과 Path가 일치하면 해당 웹 서버로 모든 쿠키를 담아 보내기 때문에, 쿠키로 저장하려는 정보량이 많아질수록 요청 크기 커짐
불필요한 네트워크 오버헤드를 발생시켜 요청 사이즈가 커지는 원인
웹 서버에게 전달할 필요가 없는 정보의 경우 웹 스토리지 사용 권장
세션
정보를 웹 서버 측에 저장하므로 클라이언트의 요청 크기에 영향을 주지 않음
매 요청마다 세션 스토리지를 조회해야 하므로, Redis 등의 고속 데이터베이스 사용을 고려해야 함



쿠키	세션
저장 위치	클라이언트 측 (웹 브라우저)	서버 측
보안	덜 안전
(HttpOnly, Secure, SameSite로 보안 강화 가능)	민감한 정보 안전하게 저장
식별 정보	사용자 식별 정보 포함 가능	서버에서 사용자를 식별하기 위한
SESSION_ID 저장
용도	사이트 설정, 인증 상태 유지 등	사용자 정보. 로그인 상태 유지 등
데이터 전송	쿠키 데이터 크기 증가는 요청 크기를 증가시킴	요청 사이즈에 영향을 주지 않음
확장성 및 비용	비교적 저렴하고 쉽게 사용 가능	메모리 기반 저장소 사용 시 비용 및 확장성 이슈
지역성 문제	각 브라우저에 따라 로그인 필요	웹 브라우저 간 정보 공유 가능
Network Overhead	정보량 증가에 따라 요청 사이즈 증가 가능	없음


10. 세션 사용 방법
- 사용자 별 고유 식별자(세션 ID)를 생성해 사용자의 정보를 저장하고, 브라우저는 이 세션 ID를 사용해서 서버와 통신



- 세션 저장 방식 3가지

In Memory
코드로 세션을 저장하는 방식
File Storage
express 코드에서 파일을 생성하고, 생성한 파일에 텍스트를 작성해서 저장하는 방식
Database
데이터베이스의 원하는 컬럼에 세션과 관련된 정보를 저장하는 방식






 	쿠키 (Cookie)	스토리지 (LocalStorage / SessionStorage)	세션 (Server-side Session)
저장 위치	클라이언트(브라우저)	클라이언트(브라우저)	서버
데이터 전송	요청 시 자동으로 서버에 전송됨 (HTTP Header)	서버에 자동 전송 ❌ (JS로 직접 꺼내서 전송해야 함)	서버 내부에만 존재
용량 제한	약 4KB	LocalStorage/SessionStorage: 약 5MB	서버 메모리/DB 크기에 따라 다름
유효 기간	만료일 지정 가능	LocalStorage: 영구 / SessionStorage: 브라우저 탭 닫을 때까지	보통 세션 타임아웃(예: 30분) 설정
보안성	조심하지 않으면 XSS/세션하이재킹 위험	JS에서 접근 가능 → XSS에 취약	서버 관리, 보안성 높음(쿠키에는 세션ID만 저장)
주요 사용처	로그인 정보, 사용자 추적, 설정 값	클라이언트 전용 데이터 캐싱, 임시 저장	로그인 세션 관리, 사용자 상태 저장
제어 주체	서버·클라이언트 모두 설정 가능	클라이언트(JS)	서버
특징	- 요청마다 서버 전송
- HttpOnly/ Secure 옵션으로 보안 강화 가능	- 대용량 저장 가능
- 자동 전송 없음 → 서버 트래픽 줄음	- 서버에서만 관리
- 클라이언트에는 세션 ID만 전달
