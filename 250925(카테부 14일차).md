## **🧠 회고**

스스로 공부하고 어떤 관점에서 문제(개념)을 바라볼 것인지 항상 고민하며 공부해야겠다는 생각을 했다. 주입식교육의 총집체라 그런지 이해하려고하기보단 외우려고 급급하고 그러다보니 마음이 급해지는 것 같다... 모호함을 버리고 명확함을 잡자. 디테일하게!

근데 요즘 왜이렇게 집중을 못하지? 초심을 약간 잃은 것 같아서 정신차리고 다시 해보려고 한다... 우선 집 밖을 나서야겠다. 집에서 공부할때 생활 소음때문에 너무 힘들어서ㅠㅠ 근데 매번 나가서 할 수는 없으니 롭 이어플러그 구매했는데 도움이 되길...... ㅜㅜ

## **🪽 오늘의 다짐**

1.  컨디션 관리 잘하기
2.  미루지 않기
3.  집중하기!!!!!!!

---

## **📝 Today I Learned**

### **1️⃣ HTTPS**

#### **1\. 정의**

\- HTTP의 전송 계층에 인증과 암호화를 적용해 보안을 강화시킨 통신 규약

#### 2\. 사용 이유

\- 데이터를 암호화하여 인터넷을 통한 정보의 안전한 전송을 보장하기 위함

\- 기본적으로 HTTP는 암호화 되지 않은 텍스트를 데이터로 전송하기 때문에, 제 3자가 데이터를 쉽게 엿볼 수 있음

  👉🏻 HTTPS는 웹 브라우저와 서버 간의 모든 통신을 암호화하여 보안을 강화함

#### 3\. 사용 방법

\- 웹 서버에 SSL 또는 TSL 인증서를 설치해 HTTPS 활성화

(1) 공개키 (public key)

\- 비대칭형 암호화 방식에서 문서의 암호화를 위해 사용되는 키

\- 보호 해야하는 데이터를 암호화 하기 위해서

(2) 비공개키 (private key)

\- 비대칭형 암호화 방식에서 문서의 복호화를 위해 사용되는 키

\- 암호화된 데이터를 복호화하기 위해서

(3) 비대칭키

| 정의 | 데이터를 암호화하고 복호화하는 데 서로 다른 두 개의 키 (공개키, 비공개키)를 사용하는 암호화 방식 |
| --- | --- |
| 사용 이유 | \- 안전한 키 교환을 가능하게 함   \- 디지털 서명 및 인증서를 사용하여 통신의 신뢰성을 제공하기 위함 |
| 사용 방법 | \- 공개키: 데이터를 암호화할 때 사용   \- 비공개키: 복호화할 때 사용 |
| vs 대칭키 | \- 대칭키 암호화보다 키 관리가 용이하고 안전한 키 교환 가능   \- 처리 속도가 더 느리므로 주로 작은 데이터 또는 초기 키 교환에 사용 |

(4) 대칭 키

| 정의 | 같은 키를 사용하여 암호화하고 복호화하는 암호화 방식 |
| --- | --- |
| 사용 이유 | 대용량 데이터를 암호화할 때 처리 속도가 빠르기에 사용 |
| 사용 방법 | 통신하는 양 쪽이 같은 비밀키를 공유하고, 이 키를 사용하여 데이터를 암호화 및 복호화 함 |
| vs 비대칭 키 | \- 비대칭키 암호화보다 일반적으로 빠르지만, 키를 안전하게 교환하기 어려움   \- 키 분배 문제로 인해 대용량 데이터 암호화에 적합   \- 키 관리가 중요한 환경에서는 제한적 |

(5) 흐름 예시

| 1 | 서버 인증서 수신 | \- 클라이언트(브라우저)는 다음 포털 서버에 접속하면서 서버 인증서를 받음   \- 이 인증서는 CA가 발급한 것으로, 서버의 공개 키 포함 |
| --- | --- | --- |
| 2 | 인증서 검증 | \- 브라우저는 CA의 공개키로 인증서의 서명을 검증   \- 검증이 성공하면 -> 이 인증서는 신뢰할 수 있고, 서버가 진짜임을 확인   \- 이 과정에서 브라우저는 미리 내장된 전 세계 신뢰 CA들의 공개키를 사용함 |
| 3 | 서버 공개키 확보 | \- 인증서가 유효하다면, 브라우저는 인증서 안에 포함된 서버의 공개키를 신뢰   \- 이 공개키는 누구나 볼 수 있지만, 대응되는 개인키는 오직 서버만이 가지고 있음 |
| 4 | 안전한 데이터 전송 | \- 브라우저는 서버의 공개키로 세션 키나 민감한 데이터를 암호화해 전송   \- 서버만이 가진 개인키로만 복호화할 수 있으므로 안전하게 통신 가능 |

\- 서버와 클라이언트 간의 통신은 인증서를 통해 서버의 신뢰성을 확인하고, 그 안에 포함된 서버의 공개키를 이용해 안전하게 이루어짐

\- 인증서 자체는 브라우저가 CA의 공개키를 사용해 검증하며, 그 과정에서 서버가 진짜임을 확인하는 중요한 역할을 함

(5) SSL

\- 보안 소켓 계층, 데이터를 안전하게 전송하기 위한 인터넷 통신 규약

\- 인터넷 상에서 데이터를 암호화하여 통신의 보안을 강화하기 위해 사용

\- 초기 인터넷 보안 프로토콜

\- 보안성이 상대적으로 낮아 최신 인터넷 환경에서는 사용을 권장하지 않음

(7) TSL

\- 인터넷 상에서 데이터의 도청 또는 변조를 막기 위한 보안 소켓 계층

\- 데이터의 암호화와 무결성을 보장하고 안전한 인터넷 통신을 위함

\- SSL을 대체하기 위해 개발

\- 강화된 암호화 기술과 보안 메커니즘을 제공하여 현재 가장 널리 사용되는 보안 프로토콜

| SSL | \- 초기 인터넷 환경에서 널리 사용했기 때문에 시스템 호환성이 좋음   \- 알고리즘과 프로토콜이 오래됐기 때문에 보안성이 취약함 |
| --- | --- |
| TSL | \- SSL보다 강화된 암호화 알고리즘과 보안을 제공해 데이터 보호에 더 효과적   \- 설정과 관리가 SSL보다 복잡할 수 있음 |

(8) TSL 핸드셰이크

\- 인증서 검증 + 세션키 교환 과정

a. ClientHello (클라이언트 -> 서버)

b. ServerHello (서버->클라이언트)

c. 서버 인증서 검증 (클라이언트 쪽에서 수행)

d. 키 교환 (세션 키 생성)

e. 핸드셰이크 완료

\-> 클라이언트와 서버는 동일한  세션 키를 가지게 됨

\-> 세션 키로 HTTP 요청/응답을 암호화하면서 안전하게 통신 시작!

처음에는 비대칭 키 교환이었다가 열쇠(대칭키)를 주고받을 때만 비대칭 방식을 쓰고, 이후 본격적인 데이터 교환은 대칭 방식으로 처리합니다.

---

### 2️⃣  인증, 인가

#### 1\. 정의

(1) 인증

\- 다중 사용자 시스템이나 네트워크에서, 사용자의 신원을 확인하는 보안 절차

\- 내가 누구인지 식별하는 행위

(2) 인가

\- 사용자와 제작자 사이에 프로그램 사용 권한을 주고받는 계약

\- 접근 권한을 허가받는 행위

#### 2\. 사용 이유

(1) 인증

\- 사용자의 신원을 확인해 시스템 보안을 강화하기 위함

(2) 인가

\- 사용자에게 특정 자원에 대한 접근 권한을 부여하기 위함

(3) 인증, 인가 3가지 방식

\- HTTP로 매번 아이디, 패스워드를 보내는 방식

\- 세션을 이용하는 방식

\- JWT를 이용하는 방식

#### 3\. 사용 방법

(1) 인증

\- 로그인 정보, 토큰, 인증서와 같은 방법을 사용해 사용자 식별

(2) 인가

\- 사용자의 권한을 설정하고, 권한 마다의 기능이나 데이터 접근 절차를 설계

---

### 3️⃣  HTTPS 자격증명 헤더

#### 1\. 정의

\- 클라이언트와 서버 간의 인증과정에서 사용자의 자격을 확인하기 위해 사용되는 헤더

\- 보안이 필요한 웹 리소스에 접근할 때 사용자가 해당 리소스에 접근할 권한이 있는지를 검증하기 위해 사용

| www-Authenticate | \- 서버가 클라이언트에게 인증이 필요함을 알리는 헤더   \- 접근 권한을 요구하는 경우 사용됨 |
| --- | --- |
| Authorization | \- 클라이언트가 서버에 자신을 인증하기 위해 필요한 정보를 제공하는 헤더   \- ID와 비밀번호를 포함할 수 있음   \- 서버의 요구 사항에 맞춰 인증 데이터를 제공 |

#### 2\. 알아야 하는 이유

\- 웹 리소스에 접근할 때 필요한 사용자의 인증 정보를 서버에 전달하기 위함

#### 3\. 동작 방식

\- HTTP Authorization 헤더에 인코딩된 인증 정보를 담아 요청과 함께 서버로 전송

\- 토큰 방식의 인증을 할 때 사용

\- 기본 인증, 다이제스트 인증, Bearer 토큰-JWT 포함, OAuth

#### 4\. 사용 예시

(1) 기본 인증

\- 간단하게 인증해야할 때 사용

-   클라이언트에서 Basic Authentication 전송
    -   사용자 이름과 비밀번호를 콜론(:)으로 구분하여 base64로 인코딩한 값을 Authentication 헤더에 포함하여 서버로 전송
-   서버에서 인증 처리
-   인증 성공 후 자원 접근 허용

(2) 다이제스트 인증

\- 웹 서버가 사용자의 웹 브라우저와 사용자 이름 또는 비밀번호와 같은 자격 증명을 협상하는 데 사용할 수 있는 합의된 방법 중 하나

\- 기본 인증은 사용자의 ID와 비밀번호를 Base64 인코딩하여 전송 -> 중간자 공격에 매우 취약함

   👉🏻 다이제스트 인증: 사용자의 비밀번호를 직접 전송하지 않고 비밀번호의 해시된 버전 사용

   👉🏻 사용자 인증 정보의 보안을 강화하여 더 안전한 웹 통신을 가능하게 함

\- 동작 방식

-   클라이언트 인증 요청
    -   클라이언트가 보호된 리소스에 접근하려고 할 때, 서버는 401 Unauthorized 응답과 함께 WWW-Authenticate 헤더를 보내 클라이언트에게 인증요수
    -   이 헤더에는 nonce 값과 realm 정보가 포함
-   클라이언트 응답 생성
    -   클라이언트는 받은 nonce, realm 정보와 사용자가 제공한 사용자 이름과 비밀번호, 요청 메소드, URI 등을 사용하여 다이제스트 응답 생성
    -   이 응답은 해시 함수를 사용하여 계산되며, 이 계산 결과를 Authorization 헤더에 포함시켜 서버로 전송
-   서버에서 인증 처리
    -   서버는 클라이언트로부터 받은 Authorization 헤더 내의 응답과 서버에서 독립적으로 생성한 해시 값을 비교
    -   일치하면 사용자의 요청이 승인되어 자원에 대한 접근 허용
    -   불일치하면, 서버는 인증 실패를 나타내는 401 Unauthorized 응답을 다시 보냄

> ❓ nonce  
> Number used once  
> \- 한 번만 사용되는 임의의 값으로  
> \- 인증이나 암호화 과정에서 재사용 공격을 방지하고 요청의 유일성을 보장하는 역할을 합니다.  
> \- 요청마다 고유한 난수를 생성해 포함시키고, 서버는 이전에 사용된 nonce를 저장해 중복 여부를 확인함으로써 재전송된 공격 요청을 막습니다.

> ❓realm  
> \- 인증 과정에서 보호된 자원의 영역을 식별하기 위해 사용하는 문자열  
> \- 사용자에게 어떤 구역에 접근 권한을 요구하는지 알려주는 역할

(3) 베어러 토큰

\- 서버로 전송되어 사용자의 신원을 인증하고, 해당 요청에 대한 권한을 확인하는데 사용되는, 보안된 텍스트 문자열 형태의 토큰

\- 토큰을 가진 사람이라면 누구든 별도의 인증 절차 없이 자원에 접근할 수 있는 방식

\- JWT를 포함하여 다양한 형식의 토큰을 전달하는데 사용되므로, JWT 및 기타 인증 토큰에 대한 이해를 도움

\- 동작 방식

-   토큰 획득
-   토큰을 이용한 요청
-   서버에서 인증 처리

---

### 4️⃣ HTTP 자격증명 헤더 -JWT

#### 1\. 정의

\- Json Web Token

\- 애플리케이션 간의 정보 교환을 위해 설계된, 정보를 JSON 형식으로 포함하는 자체 포함형 토큰

> ❓ 자체 포함형  
> \- JWT가 모든 필요한 정보를 자체적으로 담고 있음을 의미  
> \- JWT가 독립적으로 동작할 수 있도록 해주며, 별도의 추가 데이터베이스 조회 없이도 인증이나 사용자의 권한을 확인할 수 있게 함

#### 2\. 사용 이유

\- 사용자의 인증 상태를 유지하면서 서버 간의 부담을 줄이고, 무상태(Stateless) 인증을 가능하게 하기 위해 사용

\- JWT는 클라이언트 측에서 저장되며, 요청마다 포함되어 서버에 전송됨

   👉🏻 서버는 토큰의 유효성을 검증하여 사용자를 인증함

   👉🏻 서버는 사용자의 세션을 유지할 필요 없이 인증 상태 관리 가능

| 무상태 인증 | \- JWT는 토큰 자체에 사용자 인증 정보와 데이터를 포함하고 있어 서버가 세션 상태를 따로 저장하거나 유지할 필요가 없음   \- 이를 통해 서버는 사용자의 세션을 관리하는 부담이 줄어들고, 애플리케이션의 확장성이 향상됨 |
| --- | --- |
| 서버 간의 부담 감소 | \- 클라이언트 측에 JWT를 저장하고 사용하므로, 서버는 인증 상태를 따로 관리 안해도 됨   \- 부하 분산 쉬워짐   \- 서버 간의 상태 동기화가 필요 없어 서버 간의 통신 부담이 줄어듦 |
| 안정적인 확장성 | \- JWT는 HTTP 헤더를 통해 전송되며, 추가적인 저장소나 상태 관리 없이도 쉽게 확장 가능   \- 각 요청이 독립적으로 처리되므로, 서버 인스턴스가 여러 대일 경우에도 원할하게 동작 |
| 보안과 데이터 무결성 보장 | \- 서명을 통해 토큰의 무결성을 보장, 서버는 서명을 검증하여 토큰이 변조되지 않았음을 확인 가능   \- 클라이언트 측에서 저장된 토큰의 유효성과 데이터의 신뢰성 유지 |
| 유연성과 다양한 적용 가능성 | \- 사용자 인증 외에도 데이터 접근 제어, API 인증 등 다양한 목적에 활용   \- 표준화된 포맷으로 다양한 플랫폼과 언어에서 쉽게 구현 가능 |

#### 3\. 사용 방법

(1) 토큰 발급

(2) 토큰 전송

(3) 토큰 검증

(4) 권한에 따른 처리

\- 액세스 토큰만 사용할 때의 고려사항

| 유효 기간 | \- 엑세스 토큰은 일반적으로 짧은 유효 기간 가짐   \- 보안상의 이유로, 토큰이 탈취되더라도 짧은 시간 안에 사용될 수 있는 윈도우를 제한하기 위함   \- 사용자가 자주 로그인 해야 하는 불편함 |
| --- | --- |
| 보안 리스크 | \- 엑세스 토큰이 탈취되면, 유효 기간이 종료될 때까지 서버의 리소스에 접근 가능   \- 이를 방지하기 위해 HTTPS 같은 보안 프로토콜을 사용하여 데이터를 암호화 하는 것이 중요 |

\- 액세스 토큰과 리프레시 토큰을 함께 사용할때의 이점

| 더 나은 사용자 경험 | 자주 로그인할 필요 없이 서비스를 지속적으로 이용 가능 |
| --- | --- |
| 향상된 보안 | \- 리프레시 토큰은 일반적으로 액세스 토큰보다 더 안전하게 저장되며, 오직 액세스 토큰을 재발급 받기 위해 서버에 전송됨   \- 액세스 토큰이 노출되더라도 리프레시 토큰은 안전하게 보관되어 있어 보안 리스크 줄이기 가능 |

#### 4\. JWT 구성 요소

(1) 헤더 (Header)

\- 토큰의 유형(typ)과 사용된 서명 알고리즘(alg) 정의

(2) 페이로드 (Payload)

\- 토큰에 담길 정보, 즉 클레임(claims)을 포함

\- 클레임: 토큰 사용자에 관한 정보나 추가 메타데이터를 담을 수 있음

-   id, username: 사용자의 식별 정보
-   iat: 토큰이 발행된 시간
-   exp: 토큰의 만료 기간

> ❓ iat  
> \- 이 클레임은 JWT가 생성되어 발급된 정확한 시간 나타냄  
> \- 토큰이 언제 발급되었는지 추적하는 데 유용함  
> \-> 토큰이 발급된 후 예상치 못한 시간이 경과했는지 판단가능  
> \-> 토큰의 신선도 평가하는 데 사용 가능  
> \- 토큰이 발급된 시간을 알면, 예상치 못한 지연이나 시간 조작 시도 탐지 가능

> ❓ exp  
> \- JWT의 유효 기간을 정의한다. (토큰이 만료되는 시점을 명시)  
> \- 오래되거나 위험에 노출된 토큰이 계속해서 사용되는 것을 방지  
> \- 만료 시간을 설정함으로써, 토큰의 재사용을 방지하고, 토큰이 탈취되었을 경우 탈취자가 무한정 토큰을 사용하는 것을 제한

(3) 서명 (Signature)

\- 헤더와 페이로드를 합친 뒤, 지정된 알고리즘(HS256)으로 해시하고, 비밀키를 사용하여 서명한 결과

\- 토큰이 변조되지 않았음을 검증하는데 사용

\- 수신자는 같은 키와 알고리즘을 사용하여 헤더와 페이로드를 해시하고, 이를 서명과 비교함으로써 토큰의 유효성을 검증

> **❓HS256**  
> \- 키 기반의 해싱 알고리즘  
> \- 특정 비밀 키와 해시함수를 사용하여 메시지의 인증코드 생성  
> \- 메시지의 인증과 데이터의 무결성을 동시에 보장하는 데 사용됨  
> \- 토큰 또는 메시지에 대해 서명을 생성하고, 해당 서명을 검증할 때 같은 비밀 키를 사용하여 데이터의 변조 여부와 발신자의 신원 확인 가능  
> \- 보안성 높음

#### 4\. JWT 취약점과 해결책

(1) 내용 노출 문제

| 문제 | JWT는 내용이 Base64 인코딩으로 변환되어 전송되기 때문에, 내용이 암호화된 것이 아니라 단순히 인코딩만 된 상태이므로, 토큰을 가로채는 사람이 쉽게 내용을 볼 수 있음 |
| --- | --- |
| 해결책 | \- JWT 안에는 중요한 정보를 포함시키지 않아야 함   \- 인증정보와 같은 민감한 데이터는 토큰에 직접 포함시키지 않고 필요한 최소한의 정보만 포함시키는 것이 좋음 |

(2) 토큰 탈취와 대응

| 문제 | JWT가 탈취되면, 해당 토큰의 유효 기간 동안 사용자를 가장할 수 있다 |
| --- | --- |
| 해결책 | \- HttpOnly 쿠키 사용: 클라이언트 스크립트가 토큰에 접근하지 못하도록 하여 XSS 공격을 방지   \- 토큰 블랙리스트: 탈취된 토큰을 무효화시킬 수 있지만, 이는 서버에 상태를 저장해야 하므로 세션과 유사한 구조가 됨   \- 짧은 유효기간 설정: 액세스 토큰의 유효기간을 짧게 설정하고, 필요시 재발급 받도록 함   \- 리프레시 토느 회전: 리프레시 토큰 또한 탈취될 위험이 있으므로, 사용할 때마다 새로운 리프레시 토큰으로 교체하고, 이전 토큰은 즉시 무효화 |

(3) 동시 접속 제한 문제

\- JWT 자체로는 동시 접속을 제한할 수 없으나, 리프레시 토큰을 통해 사용자의 '세션'을 서버에서 관리하고 이를 통해 동시 접속을 제한할 수 있음

\=> JWT는 강력하고 편리한 인증 방법이지만, 몇가지 문제점이 있습니다. 이를 해결하기 위해서는 쿠키와 세션을 혼합 사용하거나, 리프레시 토큰, 블랙리스트 관리 등 다양한 보안 전략을 결합하여 사용하는 것이 좋습니다. 

---

### 5️⃣ HTTP 자격 증명 헤더 - OAuth

#### 1\. 정의

\- 사용자가 자신의 정보에 대한 접근 권한을 안전하게 타사 애플리케이션에 부여할 수 있게 하는 개방형 표준 프로토콜

\- 인터넷 사용자들이 애플리케이션 간에 인증과 권한 부여를 안전하게 공유할 수 있도록 설계된 오픈 표준 프로토콜

\- 사용자의 비밀번호를 제3자 애플리케이션에 제공하지 않고도, 사용자가 자신의 리소스에 대한 접근 권한을 안전하게 부여할 수 있도록 함

#### 2\. 사용 이유

\- 사용자 비밀번호를 노출하지 않고도, 애플리케이션이 사용자의 데이터에 안전하게 접근 가능

\- 사용자: 특정 데이터에 대한 접근 권한 선택 가능

\- 개발자: 모든 데이터를 자사 서비스에 저장하고 있지 않아도 되니 보안 위험 줄일 수 있음

#### 3\. 동작 방식

| 리소스 소유자 | 보통 서비스를 사용하는 최종 사용자 (사람) | 사용자 |
| --- | --- | --- |
| 클라이언트 | 사용자 대신 사용자의 데이터에 접근을 요청하는 애플리케이션 | 클라이언트 서버, 백엔드 서버 |
| 인증 서버 | 클라이언트가 사용자의 데이터에 접근할 수 있도록 토큰을 발급하는 서버 | 구글, 페이스북 |
| 리소스 서버 | 사용자의 데이터를 보유하고 있는 서버 | 구글, 페이스북 |

(1) 사용자 로그인 요청

\- 사용자가 클라이언트 애플리케이션에서 "Login with OAuth Provider" 버튼 클릭

👉🏻 사용자에게 로그인 버튼을 제공하기 위해

(2) 클라이언트가 인증 요청을 인증 서버로 전송

\- 클라이언트가 인증 서버 로그인 페이지로 리다이렉트

\- client\_id, response\_type, scope, reirext\_uri 포함

👉🏻  인증 서버가 클라이언트를 식별하고 요청의 유효성을 검증하도록 하기 위해

(3) 로그인 페이지 제공

\- 인증 서버가 사용자에게 로그인 페이지를 제공하여 자격 증명 입력을 요청

👉🏻  사용자가 인증 서버에 직접 아이디와 패스워드를 제공하기 위해

(4) 사용자의 ID/PW 입력 및 제출

\- 사용자가 인증 서버 로그인 페이지에서 자격 증명을 입력하고 제출

(5) Authorization Code 발급

\- 인증 성공 후 인증서버가 redirect\_uri에 authorization\_code 포함하여 리다이렉트 

👉🏻  클라이언트에 임시 코드를 발급해 액세스 토큰으로 교환할 수 있게 하기 위해

(6) 클라이언트로의 리다이렉션

\- 사용자 브라우저가 authorization\_code가 포함된 URL을 통해 클라이언트로 리다이렉트

👉🏻  인증 서버가 사용자와 클라이언트 간의 상호작용을 연결하는 역할 수행

(7) Authorization Code와 Access Token 교환

\- 클라이언트가 authorization\_code를 인증 서버에 제출해 액세스 토큰 요청

👉🏻  클라이언트가 사용자의 데이터에 접근할 권한을 얻기 위해서

👉🏻  보안을 위해 서버 간 통신 이용

(8) Access Token (및 필요시 Refresh Token) 발급

\- 인증 서버가 액세스 토큰(및 필요시 리프레시 토큰)을 클라이언트에 발급

👉🏻  데이터 접근 권한을 부여하는 액세스 토큰을 제공하기 위해

(9) 로그인 성공

\- 클라이언트가 액세스 토큰을 사용해 사용자를 로그인 상태로 설정

(10) Access Token으로 리소스 서버에 리소스 요청

\- 클라이언트가 액세스 토큰을 사용하여 리소스 서버에 데이터/서비스 요청

👉🏻  사용자의 데이터에 접근할 수 있도록 하기 위해

(11) 리소스 서버의 토큰 검증

\- 리소스 서버가 액세스 토큰을 검증함

👉🏻  데이터 접근 권한을 확인하기 위해

(12) 리소스 제공

\- 토큰이 유효하면 리소스 서버가 요청된 데이터/서비스를 클라이언트에게 제공

👉🏻  사용자에게 필요한 데이터/서비스를 제공하기 위해

(13) 클라이언트에서 데이터 활용

\- 클라이언트가 리소스 서버에서 받은 데이터를 사용해 사용자에게 필요한 기능 제공

👉🏻  사용자에게 기능을 제공하기 위해
