## **🧠 회고**

주말동안 몸상태가 안좋아서 쉬었는데도 더 안좋은 것 같아서 집중이 힘들었다... 처음 스프링 배운 날이었는데 너무 어렵고 개념만 하다보니 실전 코드 작성은 어떻게 해야할지 감이 잡히지 않아서 더 열심히 해야겠다는 생각이 들었다...ㅜ.ㅜ 그리고 과제도 마무리해야하고..!! 할 일이 너무 많은데 몸이 따라주지 않아서 너무 슬프다... 그래도 이틀만 더 하면 황금 연휴니까! (그래도 공부는 해야지요) 열심히 달려볼 것이다..!! 파이팅

## **🪽 오늘의 다짐**

1.  배운 내용 꼬박꼬박 복습하기
2.  피곤하더라도 할일 끝내고 자기
3.  과제 미리 하기

---

## **📝 Today I Learned**

### **1️⃣ 프레임워크, 라이브러리**

#### **1\. 정의**

**(1) 프레임워크**

\- 기본적인 기능들을 제공해 개발자가 기능을 구현하는데 집중할 수 있도록 도와주는 골조

\- 개발을 위한 구조와 규칙을 제공해 개발 과정을 단순화시켜주는 도구

**(2) 라이브러리**

\- 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임

\- 개발자에게 필요한 기능을 호출해 기능을 사용할 수 있는 코드의 집합

#### **2\. 사용 이유**

\- 프로그래밍 작업을 더 쉽고, 빠르며, 안정적으로 개발하기 위함

👉🏻 프레임워크: 일관성

👉🏻 라이브러리: 전문성 

**(1) 프레임워크**

\- 일련의 자동화된 작업과 일반적인 기능들을 제공함으로써 개발 과정을 더 빠르게 할 수 있도록 해줌

\- 기본적인 구조를 미리 제공하기 때문에, 개발자들은 이 구조 내에서 일관된 방식으로 코드 작성 가능

\- 프로젝트 코드의 통일성 유지

\- 중복되는 작업 줄여주고, 코드 재사용 쉬움

**(2) 라이브러리**

\- 특정 작업을 수행하는 데 필요한 전문 지식 쉽게 활용 가능

\- 다양한 기능을 미리 만들어 둔 코드 모음으로, 이를 활용함으로써 복잡한 작업을 간단하게 처리 가능

\- 개발 과정 간소화

\- 프로젝트 질 향상

\- 특정 분야의 전문 지식을 효과적으로 활용할 수 있도록 해줌

#### **3\. 사용 방법**

\- 프레임워크/라이브러리 사용방법(API 등)을 숙지해 필요한 기능 구현

---

### **2️⃣ 다시 짚어 보는 캡슐화**

#### **1\. 캡슐화**

**(1) 정의**

\- 객체의 데이터와 메서드를 묶고 외부에서 직접 접근을 제한하여 내부 구현을 숨기는 것

**(2)사용 이유**

\- 정보 은닉

\- 데이터 보호

\- 코드 유지보수성 향상

**(3) 사용 방법**

\- JAVA

👉🏻 private, protected, public 접근 제어자를 사용하여 캡슐화 수준을 명시적으로 제어함

👉🏻 주로 private로 필드를 숨기고, public으로 getter/setter 메서드를 제공

\- JavaScript

👉🏻전통적으로 접근 제어자가 없었지만, 함수 스코프, 클로저, \_ 변수명 규칙 등을 사용하여 캡슐화를 구현

👉🏻 모듈 패턴으로 정보 은닉

#### **2\. 상속**

**(1) 정의**

\- 기존 클래스의 속성과 동작을 물려받아 새로운 클래스를 만드는 것

\- 자식 클래스는 부모 클래스의 기능을 그대로 사용하거나 확장, 변경할 수 있음

**(2) 사용 이유**

\- 코드 재사용성 증가

\- 클래스 계층 구조 형성

\- 유지보수성 향상

👉🏻 공통 기능을 부모 클래스에서 관리하고, 변경사항이 발생했을 때 부모 클래스만 수정하면 되므로 유지 보수 편리해짐

**(3) 사용 방법**

\- JAVA

👉🏻 extends 키워드를 사용하여 상속 구현

👉🏻 단일 상속만 지원

\- JavaScript

👉🏻 class... extends... 문법으로 상속 지원

👉🏻 프로토타입 기반 상속을 클래스 문법으로 더 편리하게 사용할 수 있도록 제공

#### **3\. 다형성**

**(1) 정의**

\- 동일한 인터페이스나 부모 타입에 대해 여러 구현 객체가 존재할 때, 하나의 타입으로 다룰 수 있는 능력

\- 같은 이름의 메서드 호출이라도 객체의 실제 타입에 따라 다르게 동작하는 것

**(2) 사용 이유**

\- 코드 유연성 및 확장성 증가

👉🏻 다양한 객체를 동일한 방식으로 처리할 수 있어 코드가 유연해짐

👉🏻 새로운 타입의 객체를 쉽게 추가 가능

\- 결합도 감소

👉🏻 구체적인 객체 타입에 의존하는 코드를 줄여 코드 간의 결합도를 낮추고 독립성 높임

**(3) 사용 방법**

\- JAVA

👉🏻 메서드 오버라이딩: 자식 클래스에서 부모 클래스의 메서드를 재정의하여 다형성을 구현

👉🏻 인터페이스: 인터페이스를 구현한 여러 클래스를 인터페이스 타입으로 참조하여 다형성을 구현

\- JavaScript

👉🏻 동적 타이핑 언어이므로 기본적으로 다형성 가짐

👉🏻 메서드 오버라이딩

#### **4\. 추상화**

**(1) 정의**

\- 불필요한 세부사항을 숨기고 필요한 핵심 개념만 표현하여 복잡성을 관리하는 것

**(2) 사용 이유**

\- 복잡성 감소

👉🏻 복잡한 시스템을 단순화하여 이해하고 사용하기 쉽게 만듦

\- 인터페이스와 구현 분리

👉🏻 객체의 사용 방법(인터페이스)과 실제 동작 방식(구현)을 분리하여 코드 변경 시 영향 범위를 최소화함

\- 코드 변경 용이성

👉🏻 구현 부분을 변경하더라도 인터페이스가 변경되지 않으면 사용자 코드는 영향받지 않음

**(3) 사용 방법**

\- JAVA

👉🏻 추상 클래스: 추상 메서드를 포함하거나 포함하지 않을 수 있는 클래스, 하위 클래스에서 추상 메서드를 반드시 구현해야 함

👉🏻 인터페이스: 메서드 시그니처만 정의하는 완전히 추상적인 타입, 구현 클래스에서 인터페이스의 모든 메서드를 구현해야 함

\- JavaScript

👉🏻 명시적인 추상 클래스나 인터페이스 문법은 없지만, 프로토타입 기반 또는 클래스를 사용하여 추상화 개념 적용 가능

👉🏻 인터페이스 역할을 하는 객체나 클래스를 정의하고, 이를 상속하거나 활용하여 추상화 구현

👉🏻 덕 타이핑을 통해 인터페이스를 흉내냄

---

### **3️⃣ 객체 지향 in Spring**

#### **1\. 캡슐화 in Spring**

**(1) 정의**

\- 스프링 빈으로 객체의 데이터와 로직을 묶고, 외부로부터의 직접적인 접근을 제한하여 내부 구현을 숨기는 것

\- 객체지향의 기본 원칙을 스프링 컨테이너와 빈 관리에 적용

\- 빈이라는 단위로 객체의 데이터와 로직을 캡슐화함

\- 외부에서는 빈의 내부 구현을 직접 알 필요 없이, 스프링 컨테이너가 제공하는 방식으로 빈을 사용하고 관리

**(2) 사용 이유**

\- 빈의 독립성 및 재사용성 증대

👉🏻 각 빈은 독립적인 단위로 캡슐화되어 응집도를 높임

👉🏻 다른 모듈이나 컴포넌트에서 재사용하기 용이하게 만듦

**\- 설정과 사용 분리** 

👉🏻 빈의 생성, 의존 관계 설정 등은 스프링 설정 파일에 정의

👉🏻 실제 코드에서는 설정된 빈을 주입받아 사용만 함

👉🏻 설정과 사용 로직을 분리하여 코드의 명확성을 높임

**\- 유지보수 용이성**

👉🏻 빈의 내부 구현 변경이 다른 빈이나 외부 코드에 미치는 영향을 최소화하여 시스템 유지보수성 향상

**(3) 사용 방법**

**\- 빈 설정 메타 정보 활용**

👉🏻 스프링은 XML 설정, 어노테이션, Java Config 등 다양한 방식으로 빈의 생성, 라이프 사이클, 의존 관계 설정을 관리

👉🏻 이러한 설정 정보는 빈의 내부 구현 숨김

👉🏻 외부에서는 설정된 정보에 따라 빈을 제어함

**\- 의존성 주입**

👉🏻 빈은 필요한 의존 객체를 직접 생성하거나 찾지 않고, 스프링 컨테이너로부터 주입 받음

👉🏻 빈 내부에서 의존 객체 생성 로직을 캡슐화하고, 외부에서 의존 관계를 설정함으로써 빈의 결합도 낮춤

#### **2\. 상속 in Spring**

**(1) 정의**

\- 스프링 빈 설정 상속, 클래스 상속 활용

**(2) 사용 이유**

**\- 빈 설정 재사용**

👉🏻  빈 정의를 상속하여 공통 설정을 재사용함

👉🏻 자식 빈에서 필요한 설정만 추가하거나 변경 가능

👉🏻  설정 파일의 중복을 줄이고 관리 효율성 높임

**\- 클래스 계층 구조 형성**

👉🏻  객체지향 클래스 상속을 통해 클래스 간의 'is-a' 관계 모델링

👉🏻  코드 재사용성을 높임

👉🏻  스프링 빈 클래스에도 객체 지향 상속을 적용하여 기능을 확장하거나 특화 가능

**\- 코드 중복 감소**

👉🏻  상속을 통해 공통 기능을 부모 클래스나 빈 정의에서 관리

👉🏻  자식 클래스나 빈 정의에서는 고유 기능만 구현하여 코드 중복 줄임

**(3) 사용 방법**

**\- 빈 정의 상속**

👉🏻 XML 설정에서 <bean> 태그의 parent 속성을 사용하여 빈 정의 상속 가능

👉🏻 자식 빈은 부모 빈의 설정을 상속받고, 필요한 설정을 오버라이드하거나 추가 가능

👉🏻  주로 공통 빈 설정을 템플릿처럼 사용하고, 자식 빈에서 특정 속성만 변경할 때 유용

**\- 클래스 상속**

👉🏻 스프링 빈 클래스에도 Java의 extends 키워드를 사용하여 클래스 상속 적용 가능

👉🏻  부모 클래스의 속성과 메서드를 자식 클래스에서 상속받아 재사용하거나 확장 가능

👉🏻  스프링에서는 상속보다는 컴포지션을 더 권장하는 경향 있음

#### **3\. 다형성 in Spring**

**(1) 정의**

\- 인터페이스 기반 설계, 빈 주입 및 활용 시 다형성 적용

**(2) 사용 이유**

\- 시스템 유연성 및 확장성 증대

👉🏻  인터페이스 기반으로 컴포넌트를 설계하고, 다형성을 활용하여 다양한 구현체 쉽게 교체하거나 추가 가능

👉🏻  시스템의 유연성과 확장성 높임

**\- 결합도 감소**

👉🏻  인터페이스를 통해 추상화된 컴포넌트 간의 의존 관계를 설정

👉🏻  구체 클래스에 대한 의존성을 줄여 시스템 결합도 낮춤

**\- OCP / DIP 원칙 준수**

👉🏻  다형성은 객체지향 설계 원칙인 개방-폐쇄 원칙(OCP)과 의존 관계 역전 원칙 (DIP)을 준수하는 데 핵심적인 역할을 함

👉🏻  인터페이스를 통해 추상화된 컴포넌트는 확장에 열려있고, 변경에 닫혀 있으며, 고수준 모듈은 추상화에 의존하고 저수준 모듈의 구현에 독립적이 됨

**(3) 사용 방법**

**\- 인터페이스 기반 컴포넌트 설계**

👉🏻  스프링 컴포넌트(빈)들을 인터페이스를 기반으로 설계하고, 구체 구현 클래스는 인터페이스를 구현하도록 함

👉🏻  컴포넌트 간의 결합도를 낮추고 다형성 확보

**\- 의존성 주입 (DI) 활용**

👉🏻  스프링 컨테이너는 빈을 주입할 때 인터페이스 타입으로 주입함

👉🏻  실제 런타임 시점에는 설정된 구체 구현 클래스의 빈이 주입되지만, 사용하는 코드는 인터페이스에만 의존하므로 다형성 적용됨

#### **4\. 추상화 in Spring**

**(1) 정의**

\- 프레임워크 레벨에서의 추상화 제공, 기술 복잡성 숨김

**(2) 사용 이유**

**\- 기술 복잡성 감소**

👉🏻  스프링은 데이터 접근, 트랜잭션 관리, 메시징, 웹 개발 등 다양한 기술 영역에서 추상화된 기능 제공

👉🏻  개발자는 복잡한 기술 구현 details를 직접 다루지 않고, 스프링이 제공하는 추상화된 API를 통해 간편하게 기능 사용 가능

**\- 개발 생산성 향상**

👉🏻  추상화를 통해 개발자는 기술적인 복잡성을 덜고, 비즈니스 로직 구현에 집중 가능

👉🏻  스프링이 제공하는 다양한 추상화된 기능들은 개발 시간을 단축시키고 생산성 향상 시킴

**\- 플랫폼 독립성 확보**

👉🏻  스프링의 추상화 계층은 특정 기술이나 플랫폼에 대한 종속성을 줄여줌

**(3) 사용 방법**

**\- 데이터 접근 추상화**

👉🏻  Spring Data Access 모듈: JDBC, JPA, JTA 등 다양한 데이터 접근 기술에 대한 추상화 계층 제공

👉🏻  JdbcTemplate, JpaRepository 등의 API를 통해 데이터 접근 기술에 독립적인 코드 작성 가능

**\- 트랜잭션 추상화**

👉🏻  Spring Transaction 모듈은 트랜잭션 관리에 대한 추상화 제공

👉🏻  @Transactional 어노테이션 또는 트랜잭션 템플릿을 사용하여 선언적 또는 프로그래밍 방식으로 트랜잭션 관리 가능하며, 기반 기술에 독립적인 트랜잭션 관리 가능

**\- AOP**

👉🏻  횡단 관심사를 모듈화하고 핵심 비즈니스 로직에서 분리하는 추상화 기법

👉🏻  스프링 AOP 모듈을 통해 횡단 관심사를 Aspect로 정의하고, 핵심 로직에 영향을 주지 않고 관심사 적용 가능

**\- Web MVC 추상화**

👉🏻  Spring Web MVC 모듈은 웹 애플리케이션 개발에 필요한 다양한 추상화 기능 제공

👉🏻  DispatcherServlet, Controller, ViewResolver 등의 컴포넌트들을 통해 웹 요청 처리 과정을 추상화하고, 개발자는 비즈니스 로직 구현에 집중 가능

---

### **4️⃣ Spring**

#### **1\. 정의**

\- 자바 플랫폼을 위한 애플리케이션 프레임워크이자 IoC 컨테이너

\- 객체의 생성, 의존성 관리, 생명주기를 담당하여 개발자가 비즈니스 로직에 집중할 수 있도록 도움

> **❓ IoC**  
> \- 제어의 역전

#### **2\. 아키텍처 개요**

\- 스프링 프레임워크는 모듈형 아키텍처를 가지고 있음

\- 필요에 따라 다양한 모듈을 선택적으로 사용 가능

**\- 주요 모듈**

**(1) Core Container**

👉🏻  스프링의 핵심 모듈

👉🏻  IoC 컨테이너를 제공하여 빈의 생명주기 관리

**(2) AOP**

👉🏻  관점 지향 프로그래밍을 지원

👉🏻  횡단 관심사를 모듈화함

**(3) Data Access/Integration**

👉🏻  데이터베이스 연동 및 트랜잭션 관리를 위한 모듈들 제공

**(4) Web**

👉🏻  웹 애플리케이션 개발을 위한 모듈들 제공

**(5) Messaging**

👉🏻  메시징 시스템과의 연동 지원

**(6) Test**

👉🏻  애플리케이션 테스트를 위한 다양한 기능 제공

#### **3\. 스프링은 어떤 프레임워크?**

**\- IoC 컨테이너**

👉🏻 제어의 역전 컨테이너

👉🏻 객체의 생명 주기를 관리

👉🏻 의존성 주입(DI)을 통해 객체간의 결합도 낮춤

**\- 다양한 기능 제공**

👉🏻 웹 개발, 데이터 접근, AOP, 보안, 테스트 등 엔터프라이즈 애플리케이션 개발에 필요한 다양한 기능을 모듈 형태로 제공

**\- 높은 유연성 및 확장성**

👉🏻 다양한 설정 방식(XML, 어노테이션, Java Config)을 지원

👉🏻 필요에 따라 프레임워크 기능을 확장하거나 커스터마이징 가능

**\- 오픈 소스**

👉🏻 활발한 커뮤니티와 지속적인 업데이트를 통해 안정적이고 신뢰성 있는 프레임워크

**\- 경량**

👉🏻 모듈형 아키텍처로 필요한 모듈만 선택하여 사용할 수 있음

👉🏻 전체 프레임워크가 무겁지 않음

#### **4\. 특징**

**(1) IoC 컨테이너**

\- 객체의 생성, 의존성 관리, 생명주기 관리를 컨테이너가 담당

\- 개발자는 비즈니스 로직에 집중 가능

**(2) DI**

\- 의존성 주입

\- 객체 간의 의존 관계를 설정 파일이나 어노테이션을 통해 외부에서 주입함

\- 객체 결합도를 낮추고 재사용성과 테스트 용이성 높임

**(3) AOP**

\- 관점 지향 프로그래밍

\- 횡단 관심사 (로깅, 보안, 트랜잭션)를 핵심 로직에서 분리하여 모듈화하고 재사용성 높임

**(4) POJO**

\- Plain Old Java Object

\- 특정 인터페이스 구현이나 상속 없이, 일반적인 자바 객체(POJO)를 사용하여 개발할 수 있도록 지원

**(5) 트랜잭션 관리**

\- 선언적 트랜잭션 관리 및 프로그래밍적 트랜잭션 관리를 모두 지원

\- 다양한 트랜잭션 관리 옵션 제공

**(6) 유연한 설정 방식**

\- XML, 어노테이션, Java Config 등 다양한 설정 방식을 지원하여 개발 환경에 맞는 설정 선택 가능

**(7) 테스트 용이성**

\- DI, POJO 기반 설계, 테스트 지원 모듈 등을 통해 단위 테스트 및 통합 테스트를 용이하게 수행 가능

#### **5\. 사용 이유**

**(1) 개발 생산성 향상**

\- IoC/DI, AOP, 다양한 모듈 제공 등 개발에 필요한 기반 기능들을 프레임워크 차원에서 제공하여 개발자가 비즈니스 로직에 집중할 수 있게 함

\- 보일러 플레이트 코드를 줄임

\- 설정 및 인프라 관련 업무 부담을 덜어 개발 생산성 크게 향상시킴

**(2) 유지 보수성 증대**

\- 느슨한 결합, 모듈화, 테스트 용이성 등 객체지향 설계원칙을 잘 반영하여 개발된 스프링 기반 애플리케이션은 유지보수성이 뛰어남

\- 코드 변경에 대한 영향 범위 최소화

\- 새로운 기능 추가나 요구사항 변경에 유연하게 대응 가능

**(3) 엔터프라이즈 환경에 최적화**

\- 트랜잭션 관리, 보안, 웹 개발, 데이터 접근 등 엔터프라이즈 환경에서 필요한 다양한 기능들을 안정적으로 제공함

\- 대규모 시스템 개발 및 운영에 필요한 기능과 안정성 확보

**(4) 활발한 커뮤니티 및 생태계**

\- 오랜 역사와 활발한 커뮤니티를 바탕으로 풍부한 정보와 자료얻을 수 있음

\- 문제 발생 시 해결 용이

\- 스프링 생태계 또한 방대하여 다양한 라이브러리 및 도구 활용 가능

**(5) 객체 지향 설계 및 학습에 이점**

\- 스프링 프레임워크 자체가 객체지향 설계 원칙을 잘 반영하고 있어, 스프링을 학습하고 사용하는 과정에서 자연스럽게 객체 지향적인 사고방식과 개발 능력 향상 가능

#### **6\. 사용 방법**

**(1) 프로젝트 설정**

\- Maven 또는 Gradle과 같은 빌드 도구를 사용하여 스프링 관련 의존성을 프로젝트에 추가

**(2) 빈 정의**

\- 스프링 컨테이너가 관리할 객체(빈)을 XML 설정, 어노테이션, Java Config 등의 방식으로 정의

**(3) IoC 컨테이너 초기화**

\- ApplicationContext를 생성하여 스프링 IoC 컨테이너를 초기화

\- 빈 설정 정보를 로딩

**(4) 빈 사용**

\- ApplicationContext로부터 필요한 빈을 얻어와서 애플리케이션 로직에서 사용

\- 주로 의존성 주입을 통해 빈을 주입받아 사용함

**(5) AOP(관점 지향 프로그래밍) 적용**

\- 선택 사항

\- 횡단 관심사를 Aspect로 정의하고, 포인트컷과 어드바이스를 설정하여 AOP 적용

**(6) 스프링 모듈 활용**

\- 선택 사항

\- 웹 개발, 데이터 접근, 보안 등 필요한 스프링 모듈을 활용하여 애플리케이션 기능을 개발

#### **7\. 장점**

**(1) 높은 생산성**

\- IoC/DI, AOP, 다양한 모듈 제공으로 개발 생산성 향상

**(2) 유지 보수 용이성**

\- 느슨한 결합, 모듈화, 테스트 용이성으로 코드 유지보수성 증대

**(3) 엔터프라이즈 환경 최적화**

\- 트랜잭션 관리, 보안, 웹 개발 등 엔터프라이즈 기능 제공

**(4) 활발한 커뮤니티 및 생태계**

\- 풍부한 정보, 자료, 라이브러리 활용 가능

**(5) 객체지향 학습에 도움**

\- 객체지향 설계 원칙 기반 프레임워크, 학습 효과 증대

**(6) 유연성 및 확장성**

\- 다양한 설정 방식, 프레임워크 기능 확장 가능

**(7) 테스트 용이성**

\- DI, POJO 기반 설계로 단위/통합 테스트 용이

#### **8\. 단점**

**(1) 학습 곡선**

\- 프레임워크 기능이 다양하고 깊이 있어 초기 학습 곡선이 높을 수 있음

**(2) 설정 복잡성**

\- 다양한 설정 방식과 옵션으로 인해 설정이 복잡하게 느껴질 수 있음

**(3) 과도한 기능**

\- 모든 기능을 다 사용할 필요는 없지만, 기능이 많아 불필요한 기능까지 포함될 수 있음

\- 모듈 선택적으로 사용 가능

**(4) 성능 오버헤드**

\- IoC 컨테이너, AOP 등 프레임워크 기능 사용에 따른 성능 오버헤드가 발생할 수 있음 

#### **9\. Spring vs Spring Boot**

|   | **Spring framework** | **Spring Boot** |
| --- | --- | --- |
| **핵심** | IoC 컨테이너, 객체지향 프레임워크 | 스프링 기반의 설정 자동화 프레임워크 |
| **설정** | \- XMl, 어노테이션, Java Config 등 다양한 방식   \- 개발자 직접 설정 필요 | \- 자동 설정   \- 관례에 따른 설정   \- 설정 최소화 |
| **실행/배포** | WAR 파일로 WAS에 배포 | \- JAR파일   \- 내장 웹 서버   \- 독립 실행 가능 |
| **의존성 관리** | 각 모듈 의존성 직접 추가 | \- Starter PoM   \- 관련 의존성 자동 포함 |
| **운영 기능** | 직접 구현 또는 별도 설정 필요 | \- Actuator   \- 상태 체크   \- 매트릭   \- 모니터링 기능 기본 제공 |
| **개발 편의성** | 설정 및 환경 구성에 시간 소요 | \- 초기 설정 시간 단축   \- 빠른 개발 가능 |
| **학습 곡선** | \- 비교적 높음   \- 스프링 깊이 있는 이해 필요 | \- 상대적으로 낮음   \- 스프링 초심자도 쉽게 시작 가능 |

---

### **5️⃣ MVC**

#### **1\. 정의**

\- 소프트웨어 디자인 패턴 중 하나

\- 모델, 뷰, 컨트롤러 세 가지 역할로 분리하여 개발하는 방식

\- 각 역할은 독립적인 책임을 가짐

\- 서로 협력하여 사용자 인터페이스, 데이터, 비즈니스 로직 관리

#### **2\. MVC 패턴 구성 요소**

**(1) 모델**

\- 애플리케이션의 데이터와 비즈니스 로직 담당

\- 데이터베이스, 파일 시스템 등 데이터 소스로부터 데이터를 가져오고, 데이터를 처리하고 관리하는 역할 수행

\- 뷰나 컨트롤러에 직접적으로 의존하지 않음

\- 데이터 변경을 뷰에 알리는 역할

**(2) 뷰**

\- 사용자에게 정보를 표시하는 역할

\- 모델로부터 데이터를 받아서 사용자 인터페이스형태로 시각적으로 표현

\- 웹 애플리케이션에서는 HTML, CSS, JavaScript 등을 사용하여 웹 페이지를 렌더링함

\- 모델의 변경 감지

\- 사용자에게 최신 정보 보여주도록 업데이트

**(3) 컨트롤러**

\- 사용자 입력을 처리하고, 모델과 뷰 사이의 상호 작용을 관리

\- 사용자의 요청을 받아 모델을 업데이트하거나 데이터를 조회하고, 그 결과를 뷰에 전달하여 사용자에게 응답

\- 비즈니스 로직을 직접 수행하지 않고, 모델에게 비즈니스 로직 처리를 위임

#### **3\. MVC 패턴의 동작 흐름**

**(1) 사용자 요청**

\- 사용자가 UI를 통해 액션을 수행하거나, 웹 브라우저를 통해 특정 URL에 접속하는 등 시스템에 요청 보냄

**(2) 컨트롤러 요청 처리**

\- 사용자 요청은 컨트롤러에게 전달됨

\- 컨트롤러는 요청을 분석하고, 어떤 모델을 사용해야 할지, 어떤 뷰를 렌더링해야 할지 결정

**(3) 모델 데이터 처리**

\- 컨트롤러는 모델에게 필요한 데이터 처리를 요청

\- 모델은 데이터베이스나 다른 데이터 소스로부터 데이터를 가져오거나, 데이터를 가공하고 비즈니스 로직을 수행

**(4) 모델 결과 컨트롤러 반환**

\- 모델은 데이터 처리 결과를 컨트롤러에게 반환

**(5) 뷰 렌더링**

\- 컨트롤러는 모델로부터 받은 데이터를 뷰에 전달하고, 뷰는 데이터를 기반으로 사용자 인터페이스를 렌더링

\- 웹 애플리케이션의 경우 HTML, CSS, JavaScript를 사용하여 웹 페이지 생성

**(6) 사용자 응답**

\- 렌더링된 뷰는 사용자에게 응답으로 제공됨

 - 웹 브라우저를 통해 웹 페이지가 사용자에게 표시됨

#### **4\. MVC 패턴의 장점**

**(1) 관심사 분리**

\- 모델, 뷰, 컨트롤러로 역할을 분리하여 각 구성 요소는 자신의 책임에만 집중 가능

\- 코드의 모듈성과 응집도 높이고, 복잡성 감소

**(2) 코드 유지보수성 향상**

\- 각 역할이 분리되어 있어 코드 변경 시 영향 범위를 최소화 가능

**(3) 코드 테스트 용이성 향상**

\- 각 구성 요소가 독립적으로 개발되고 테스트될 수 있음

\- 모델, 뷰, 컨트롤러를 개별적으로 단위 테스트하기 용이

\- 통합 테스트도 효율적으로 수행 가능

**(4) 개발 효율성 증대**

\- 역할을 분담하여 개발할 수 있으므로, 개발 프로세스를 효율적으로 관리하고, 개발 속도 높일 수 있음

\- 프론트엔드 개발자와 백엔드 개발자 간의 협업을 용이하게 함

---

### **6️⃣ Spring MVC**

#### **1\. 정의**

\- 스프링 프레임워크에서 제공하는 웹 MVC 프레임워크 모듈

\- MVC 패턴을 기반으로 웹 애플리케이션을 개발하기 위한 다양한 기능과 편리한 개발 환경 제공

\- 스프링 프레임워크의 핵심 기능과 긴밀하게 통합되어 있음

\- 유연하고 확장가능한 웹 애플리케이션 개발 지원

#### **2\. 핵심 구성 요소**

**(1) DispatcherServlet**

\- Spirng MVC의 핵심 컴포넌트이자 프론트 컨트롤러

\- 웹 애플리케이션으로 들어오는 모든 HTTP 요청을 최초로 받아 처리하고, Spring MVC의 다양한 컴포넌트들에게 요청 처리를 위임하는 역할

\- 웹 요청 흐름을 중앙 집중적으로 관리

\- Spring MVC의 전체적인 동작 방식을 제어

**(2) HandlerMapping**

\- 사용자의 요청 URL을 분석하여, 해당 요청을 처리할 컨트롤러를 찾아주는 역할

\- 요청 URL과 컨트롤러 메서드를 매핑하는 다양한 전략 제공

\- @RequestMapping 어노테이션, XML 설정 등을 통해 매핑 정보 설정

\- RequestMappingHandlerMapping, BeanNameUrlHandlerMaping 등 다양한 구현체 존재

**(3) HandlerAdapter**

\- HandlerMapping에 의해 선택된 컨트롤러를 실행하는 역할

\- 다양한 타입의 컨트롤러를 실행할 수 있도록 어댑터 패턴으로 설계

**(4) Controller**

\- 웹 요청을 실제로 처리하는 역할

\- 사용자 요청을 분석하고, 모델을 사용하여 필요한 데이터를 처리하고, 뷰 이름을 반환하여 뷰 렌더링은 준비

\- @Controller 어노테이션을 사용하여 컨트롤러 정의

\- Controller 인터페이스를 구현하여 컨트롤러를 만들 수 있음

**(5) Model**

\- 컨트롤러에서 뷰로 전달할 데이터를 담는 컨테이너 역할

\- Model, ModeMap, ModelAndView 등의 객체를 사용하여 데이터를 뷰에 전달

\- 모델은 뷰 렌더링에 필요한 데이터를 담고, 뷰는 모델에 담긴 데이터를 사용하여 화면 구성

**(6) View**

\- 모델 데이터를 사용하여 화면을 렌더링하는 역할

\- 다양한 뷰 템플릿 엔진을 사용하여 뷰를 구현할 수 있음

\- Spring MVC는 뷰 이름에 따라 적절한 뷰 구현체를 선택하여 렌더링

**(7) ViewResolver**

\- 컨트롤러가 반환한 뷰 이름을 기반으로 실제 뷰 객체를 생성하는 역할

\- 뷰 이름과 뷰 구현체 간의 매핑을 관리하고, 뷰 이름을 뷰 객체로 변환

#### **3\. Spring MVC의 동작 흐름**

**(1) DispatcherServlet 요청 접수**

\- 웹 애플리케이션으로 들어오는 모든 HTTP 요청은 DispatcherServlet이 먼저 받음

\- DispatcherServlet운 Spring MVC의 진입접 역할

**(2) HandlerMapping을 통한 컨트롤러 탐색**

\- DispatcherServlet은 요청 URL을 기반으로 HandlerMapping에게 요청을 처리할 컨트롤러를 찾도록 요청

\- HandlerMapping은 설정된 매핑 정보를 참고하여 요청 URL에 매핑되는 컨트롤러를 찾아 DispatcherServlet에게 반환

**(3) HandlerAdapter를 통한 컨트롤러 실행**

\- DispatcherServlet은 찾은 컨트롤러를 HandlerAdapter에게 전달하고, 컨트롤러 실행 요청

\- HandlerAdapter는 컨트롤러 타입에 맞는 방식으로 컨트롤러를 실행하고, 컨트롤러가 반환한 ModelAndView를 DispatcherServlet에게 반환

**(4) ViewResolver를 통한 뷰 객체 획득**

\- DispatcherServlet은 컨트롤러가 반환한 ModelAndView에서 뷰 이름을 얻고, ViewResolver에게 뷰 이름에 해당하는 View 객체를 찾도록 요청

\- ViewResolver는 뷰 이름을 기반으로 실제 뷰 객체를 생성하여 DispatcherServlet에게 반환

**(5) 뷰 렌더링**

\- DispatcherServlet은 ViewResolver로부터 획득한 View 객체에게 렌더링을 요청

\- View 객체는 ModelAndView에 담긴 모델 데이터를 사용하여 뷰를 렌더링하고, 그 결과를 응답으로 사용자에게 전송

**(6) 응답 전송**

\- 렌더링된 뷰는 HTTP 응답으로 웹 브라우저에게 전송되고, 웹 브라우저는 응답 내용을 화면에 표시

#### **4\. Spring MVC 사용 이유**

**(1) 웹 애플리케이션 개발 생산성 향상**

\- 웹 애플리케이션 개발에 필요한 다양한 기능과 편리한 개발 환경을 제공하여 개발 생산성 향상

\- MVC 패턴 기반의 명확한 역할 분담, 다양한 기능 지원, 편리한 설정 및 개발 도구 지원 등을 통해 개발 효율성 높임

**(2) 높은 유연성 및 확장성**

\- 유연한 아키텍처와 다양한 확장 포인트를 제공하여 개발자가 필요에 따라 프레임워크 기능을 확장하거나 커스터마이징 가능

\- 다양한 뷰 템플릿 엔진 지원, HandlerMapping 및 ViewReslolver 확장, 인터셉터 및 예외 처리 기능 등을 통해 유연성 확보

**(3) 스프링 프레임워크의 강력한 기능 활용**

\- 스프링의 DI 컨테이너를 통해 컨트롤러, 서비스, 리포지토리 등 컴포넌트들을 효율적으로 관리하고 의존성 주입 가능

\- AOP를 활용하여 횡단 관심사를 효과적으로 처리 가능

**(4) RESTful API 개발 지원**

\- @RestController 어노테이션, @RequestMapping 어노테이션, HTTP 메시지 컨버터 등을 통해 RESTful API를 쉽게 개발

\- JSON, XML 등 다양한 형식의 응답을 생성 가능

**(5) 테스트 용이성**

\- 각 컴포넌트들이 인터페이스 기반으로 설계되어 있고, 스프링의 DI 컨테이너를 통해 의존성을 주입받으ㅁ로, 단위 테스트 및 통합 테스트를 용이하게 수행 가능

\- 테스트 지원 도구를 활용하여 웹 애플리케이션을 효과적으로 테스트 가능

#### **5\. 사용 방법**

**(1) 프로젝트 설정**

\- Maven 또는 Gradle과 같은 빌드도구를 사용하여 Spring MVC 관련 의존성을 프로젝트에 추가

\- spring-boot-starter-web 스타터 의존성을 추가하면 Spring MVC와 내장 톰캣 서버, Jackson JSON 라이브러리 등 웹 개발에 필요한 기본적인 의존성을 한 번에 설정 가능

**(2) DispatcherServlet 설정**

\- web.xml 또는 Java Config 클래스를 사용하여 DispatcherServlet을 웹 애플리케이션의 프론트 컨트롤러로 설정

\- Spring Boot를 사용하는 경우, DispatcherServlet은 자동 설정

**(3)  Contoller 클래스 작성**

\- @Controller 또는 @RestController 어노테이션을 사용하여 컨트롤러 클래스 작성

\- @RequestMapping 어노테이션을 사용하여 요청 URL과 컨트롤러 메서드를 매핑함

\- 컨트롤러 메서드는 사용자 요청을 처리하고, 모델 데이터를 생성하고, 뷰 이름 반환

**(4) View 템플릿 작성**

\- 뷰 템플릿 엔진을 사용하여 뷰 템플릿 파일 작성

\- 뷰 템플릿 파일은 컨트롤러부터 전달받은 모델 데이터를 사용하여 화면을 렌더링

\- Spring Bootdptjsms Thymeleaf 템플릿 엔진을 기본적으로 지원

**(5) ViewResolver 설정**

\- application.properties 또는 Java Config 클래스를 사용하여 ViewResolver를 설정

\- ViewResolver는 뷰 이름과 뷰 템플릿 파일의 위치를 매핑하는 역할

\- Spring Boot에서는 TymeleafViewResolver가 자동으로 설정됨
