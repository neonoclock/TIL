## **🧠 회고**

연휴 전전날이다!!! 연휴가 다가와서 그런지 마음이 조금 헤이해지는 것 같다... 하지만 케빈 말대로 이러면 나중에 취업도 망하겠지? 다시 한 번 마음을 붙잡고 첫 주의 열정 그대로 열심히 해야겠다는 생각을 했다. 그런데 스프링 너무 어렵고... 그래도 열심히 해야지. 하면 된다! 뭐든지! 파이팅!

## **🪽 오늘의 다짐**

1.  배운 미루지 않고 복습하기
2.  헤이해지지 않기

---

## **📝 Today I Learned**

### **1️⃣ Annotation**

#### **1\. 정의**

\- 자바 소스 코드에 추가하여 사용할 수 있는 메타데이터

\- 어노테이션 자체는 직접적인 기능이 없음

\- 코드에 대한 부가적인 정보를 제공하는 태그, 또는 주석과 같은 역할

\- 스프링 프레임워크는 특정 어노테이션을 인식하고, 그 정보를 바탕으로 객체를 생성하거나, 의존성을 주입하거나, 특정 기능을 부여하는 등의 처리를 수행

#### **2\. 역할과 원리**

\- 과거 XML 기반의 복잡한 설정을 대체하고, 개발자가 코드의 의도를 더 명확하게 표현할 수 있도록 돕는 핵심 도구

| **IoC** | \- 클래스에 @Component를 붙여 "이 클래스는 Spring 컨테이너가 관리해야 할 대상입니다"라고 표시함   \- Spring 컨테이너는 시작 시점에 @Component가 붙은 클래스들을 스캔하여 스스로 Bean으로 등록하고 생명주기 관리   \- 즉, 개발자가 직접 객체를 제어하는 것이 아니라, 어노테이션으로 표시만 해두면, Spirng이 제어권을 가져가 관리해주는 IoC 실현 |
| --- | --- |
| **DI** | \- @Autowired 어노테이션은 "이 필드(혹은 생성자)에는 Spring 컨테이너가 관리하는 적절한 타입의 Bean을 주입해주세요"라는 의도 나타냄   \- 개발자가 new 키워드로 의존 객체를 직접 생성하는 대신, Spring 컨테이너가 어노테이션 정보를 읽어 해당 위치에 의존성 주임   \- 의존 관계 역전 원칙을 코드로 구현하는 방식 |
| **AOP** | \- @Transactional이나 @Aspect 같은 어노테이션은 횡단 관심사를 적용할 대상을 선언하는 역할을 함   \- Spring은 런타임 프록시를 통해 해당 어노테이션이 붙은 메서드가 호출될 때, 핵심 로직 실행 전후로 트랜잭션 시작, 커밋, 롤백이나 로깅과 같은 부가 기능을 끼워 넣음   \- 즉, 어노테이션은 AOP 적용 대상을 선언하는 손쉬운 방법   \- 실제 포인트컷과 어드바이스 결합은 프레임워크가 내부적으로 결정됨 |
| **추상화** | \- @GetMapping("/users")와 같은 어노테이션은 복잡한 서블릿 API를 추상화한 것   \- 개발자는 HTTP 요청을 처리하는 저수준 코드를 작성할 필요 없이, 단지 어노테이션 하나로 고수준의 의도만 선언하면 된다. |

#### **3\. 핵심 어노테이션**

@SpringBootApplication

\- 스프링 부트 애플리케이션의 시작점

\- @Configuration, @EnableAutoConfiguration, @ComponentScan을 합친 메타 어노테이션

\- 기본 컴포넌트 스캔 범위는 이 클래스가 속한 패키지와 하위 패키지이므로, 이 클래스를 프로젝트 루트 패키지에 두는 것이 권장됨

#### **4\. 주요 어노테이션 유형**

**(1) Bean 등록**

\- Spring 컨테이너에게 이 클래스를 Bean으로 등록하라고 알려주는 어노테이션

\- @Component가 가장 기본

\- 나머지는 특정 계층이나 역할을 나타내는 특수한 형태의 @Component

| **@Component** | \- 가장 일반적인 스테레오타입 어노테이션   \- 개발자가 직접 정의한 클래스를 Bean으로 등록할 때 사용 |
| --- | --- |
| **@Controller** | \- 표현 계층에서 사용   \- Spring MVC의 컨트롤러 역할을 하는 클래스에 붙임 |
| **@RestController** | \- @Controller 와 @ReponseBody가 합쳐진 어노테이션   \- 주로 RESTful API를 만들 때 사용하며, 반환값을 JSON/XML 형태로 자동 변환해줌 |
| **@Service** | \- 비즈니스 계층에서 사용   \- 비즈니스 로직을 처리하는 서비스 클래스에 붙임 |
| **@Repository** | \- 데이터 접근 계층에서 사용   \- 데이터베이스에 접근하는 DAO 클래스에 붙임   \- 데이터 관련 예외를 Spring 예외로 변환해주는 기능 포함 |

**(2) 의존성 주입**

\- Bean 간의 의존관계를 설정하기 위해 사용

| **@Autowired** | \- Spring 컨테이너에 등록된 Bean 중에서, 필요한 의존 객체를 타입에 맞춰 찾아 자동으로 주입해줌   \- 생성자, 필드, Setter 메서드에 사용할 수 있으며 생성자 주입 방식이 가장 권장 됨 |
| --- | --- |
| **@Qualifier** | \- 같은 타입의 Bean이 여러 개 있을 때, 특정 이름을 가진 Bean을 지정하여 주입받을 수 있도록 도와줌 |
| **@Primary** | \- 같은 타입의 Bean이 여러개 있을 때, @Primary가 붙은 Bean이 기본값으로 주입되도록 우선순위 부여 |

**(3) Java 기반 설정**

| **@Configuraton** | 이 클래스가 Spring 의 설정정보를 담고 있는 클래스임을 나타냄 |
| --- | --- |
| **@Bean** | \- @Configuration 클래스의 메서드에 사용하여, 해당 메서드가 반환하는 객체를 Bean으로 등록하도록 함   \- 외부 라이브러리 객체를 Bean으로 등록할 때 유용 |
| **@Value("${property.name}")** | application.properties나 application.yml 파일에 정의된 속성 값을 필드에 주입 |

**(3-1) 환경/설정 바인딩**

| **@ConfigurationProperties(prefix="app")** | \- 다수의 관련 프로퍼티를 타입 셰이프하게 묶어 바인딩   \- 복잡한 설정을 @Value로 흩뿌리기보다 설정 전용 POJO로 관리하는 것이 유지보수에 유리 |
| --- | --- |
| **@EnableConfigurationPropeties** | @ConfigurationProperties 클래스를 활성화함 |

**(4) HTTP 요청 처리**

| **@RequestMapping("/path")** | \- 특정 경로로 들어오는 모든 HTTP 메서드(GET, POST 등)의 요청을 처리하는 핸들러 메서드나 클래스에 매핑   \- 클래스 레벨과 메서드 레벨에 모두 사용 가능 |
| --- | --- |
| **@GetMapping("/path")** | @RequestMapping(method = RequestMethod.GET)의 축약형   \- HTTP GET 요청을 처리 |
| **@PostMapping("/path")** | @RequestMapping(method = RequestMethod.POST)의 축약형.   \- HTTP POST 요청을 처리 |
| **@PutMapping("/path")** | @RequestMapping(method = RequestMethod.PUT)의 축약형.   \- HTTP PUT 요청을 처리 |
| **@DeleteMapping("/path")** | @RequestMapping(method = RequestMethod.DELETE)의 축약형.   \- HTTP DELETE 요청을 처리 |
| **@PathVariable** | URL 경로의 일부를 변수로 받아올 때 사용 |
| **@RequestParam** | URL의 쿼리 파라미터(Query Parameter)를 받아올 때 사용 |
| **@RequestBody** | HTTP 요청의 본문(body)에 담긴 JSON, XML 등의 데이터를 Java 객체로 변환(역직렬화)하여 받아올 때 사용 |
| **@ResponseBody** | @RestController가 아닌 일반 @Controller에서, 메서드의 반환값(Java 객체)을 HTTP 응답 본문에 직접 JSON, XML 등의 데이터로 변환(직렬화)하여 넣도록 지정 |
| **@ExceptionHandler** | \- 특정 예외가 발생했을 때, 이를 처리하는 메서드임을 지정합니다. **해당 컨트롤러 범위**에서 발생한 예외를 처리.   \- 여러 컨트롤러에 공통 적용하려면 @ControllerAdvice(또는 @RestControllerAdvice)를 사용 |

**(4-1) 웹 계층: 글로벌 예외 처리와 검증**

| **@ControllerAdvice** **/** **@RestControllerAdvice** | \- 여러 컨트롤러에 공통으로 적용되는 **글로벌 예외 처리/바인딩 설정**을 제공   \- @ExceptionHandler 메서드를 이곳에 모아두면 예외 응답을 일관되게 관리 |
| --- | --- |
| **@ResponseStatus** | \- 예외 또는 핸들러 메서드의 **HTTP 상태 코드를 선언적으로 지정** |
| **@Valid** **/** **@Validated** | \- 요청 바인딩 시 **Bean Validation**을 수행   \- @Validated는 **그룹 검증**에 유용 |

**(5) 트랜잭션 실무 포인트**

| **@Transactional** | **\- 서비스 계층**에 선언하여 트랜잭션 경계를 명확히 함   \- 읽기 전용 조회 메서드는 @Transactional(readOnly = true)로 최적화   \- 자기 내부 호출(self-invocation)에는 프록시가 적용되지 않으므로, 같은 클래스 내에서 트랜잭션 메서드를 직접 호출하면 해당 어노테이션이 적용되지 않음   \- 필요한 경우 설계를 분리하거나 호출 경로를 프록시 바깥에서 만들도록 조정 |
| --- | --- |

**(6) 빈 스코프/프로파일**

| **@Scope** | \- 빈의 스코프를 지정   \- 기본은 singleton   \- 웹 요청마다 새 인스턴스를 원하면 프록시 모드를 함께 사용합니다. |
| --- | --- |
| **@Profile("dev")** | \- 특정 프로파일에서만 빈을 활성화   \- 로컬/운영 환경별로 구현을 분리할 때 유용 |

**(7) 테스트**

| **@SpringBootTest** | **\- 통합 테스트**를 위해 사용   \- 실제 애플리케이션 실행과 거의 동일하게 모든 Bean을 로드하여 테스트 환경을 구성 |
| --- | --- |
| **@WebMvcTest** | **\- 웹 계층(Controller) 슬라이스 테스트**를 위해 사용   \- @Controller, @RestController 등 웹 관련 Bean들만 로드하여 테스트를 가볍고 빠르게 만듦 |
| **@DataJpaTest** | **\- 데이터 접근 계층(Repository) 슬라이스 테스트**를 위해 사용   \- JPA 관련 설정과 @Repository Bean들만 로드   \- 각 테스트는 기본적으로 트랜잭션 내에서 실행되고 끝나면 롤백됨 |
| **@MockBean** | \- 테스트 대상이 의존하는 Bean을 가짜 객체(Mock)로 대체하여 주입   \- 이를 통해 외부 서비스나 데이터베이스와의 의존성을 끊고 순수한 단위 테스트를 수행할 수 있음 |

**(7-1) 테스트 보강**

| **@SpringBootTest(webEnvironment = WebEnvironment.RANDOM\_PORT)** | \- 실제 서블릿 컨테이너 유사 환경에서 통합 테스트를 수행   \- TestRestTemplate/WebTestClient와 함께 사용 |
| --- | --- |
| **@AutoConfigureMockMvc** | @SpringBootTest와 함께 MockMvc를 자동 구성 |
| **@SpyBean** | 실제 빈을 **스파이**로 대체하여 일부 동작만 스텁하고 나머지는 그대로 사용 |
| **@ActiveProfiles("test")** | 테스트 전용 설정/데이터소스를 활성화 |
| **@AutoConfigureTestDatabase(replace = Replace.NONE)** | @DataJpaTest에서 **내장 DB로 자동 대체되는 것을 방지**하고 실제 설정을 사용 |
| **@Sql** | 테스트 전/후 데이터 스크립트를 실행 |

---

### **2️⃣ IoC**

#### **1\. 정의**

\- 객체 생성, 의존 관계 관리 등 객체 제어 권한이 개발자에서 스프링 컨테이너로 역전되는 개념

\- 제어의 역전

#### **2\. 특징**

**(1) 객체 제어 권한 역전**

\- 객체 생성, 의존 관계 설정, 생명 주기 관리 등 객체에 대한 제어 권한이 개발자 코드에서 프레임워크(스프링 컨테이너)로 넘어감

**(2) 스프링 컨테이너가 객체 관리**

\- 스프링 컨테이너가 객체의 생성, 의존성 주입, 초기화, 소멸 등 전반적인 생명 주기 관리

**(3) 코드 결합도 감소**

\- 객체 간의 의존 관계를 외부 설정을 통해 정의하고, 컨테이너가 주입하므로 코드 결합도가 낮아짐

**(4) 모듈화 및 재사용성 증대**

\- 객체는 독립적인 컴포넌트 형태로 개발되고, 컨테이너에 의해 조립되므로 모듈화 및 재사용성이 높아짐

**(5) 테스트 용이성 향상**

\- 객체 간의 결합도가 낮아지고, 의존성이 주입되므로 단위 테스트 및 통합 테스트를 수행하기 용이

#### **3\. 사용 이유**

**(1) 객체 결합도 감소**

\- 객체 간의 의존 관계가 외부에서 설정되고 주입되므로, 객체 간의 결합도가 낮아짐

\- 코드 변경에 대한 영향 범위를 줄이고, 시스템을 유연하게 만들어줌

**(2) 모듈화 및 재사용성 증대**

\- 객체는 독립적인 컴포넌트 형태로 개발되고, 스프링 컨테이너에 의해 조립되므로 모듈화 및 재사용성이 높아짐

**(3) 테스트 용이성 향상**

\- 객체 간의 결합도가 낮아지고, 의존성이 주입되므로 단위 테스트 및 통합 테스트를 수행하기 용이해짐

\- Mock 객체 등을 활용하여 의존 객체를 쉽게 대체하고 테스트를 격리할 수 있음

**(4) 개발 생산성 및 유지보수성 향상**

\- 객체 관리 및 의존성 관리 부담을 줄여 개발 생산성을 향상시킴

\- 낮은 결합도와 높은 모듈화로 인해 시스템 유지보수성 높임

#### **4\. 사용 방법**

**(1) 스프링 컨테이너 사용**

\- 스프링 IoC 컨테이너의 핵심 인터페이스인 ApplicationContext를 생성하고, 설정 정보를 로딩하여 IoC 컨테이너를 초기화함

**(2) 빈 정의**

\- 스프링 컨테이너가 관리할 객체를 XML 설정, 어노테이션, Java Config 등의 방식으로 정의

**(3) 의존성 주입(DI) 설정**

\- 빈 간의 의존 관계를 설정 파일 또는 어노테이션 등을 사용하여 정의

\- 스프링 컨테이너는 설정 정보를 바탕으로 빈을 생성하고 의존성 주입

**(4) 빈 획득 및 사용**

\- 스프링 컨테이너에서 필요한 빈을 조회하여 사용함

---

### **3️⃣ Bean**

#### **1\. 정의**

\- 스프링 프레임워크에서 관리하는 객체

\- 애플리케이션을 구성하는 컴포넌트이자, 스프링 컨테이너의 핵심 관리 대상임

#### **2\. 특징**

**(1) 스프링 컨테이너에 의해 관리**

\- 빈은 스프링 컨테이너의 생성, 의존성 주입, 생명주기 관리 등 전반적인 관리를 받음

**(2) 설정 메타 정보를 통해 정의**

\- 어노테이션과 Java Config를 통해 정의하는 것이 기본

\- XML 설정은 레거시 호환 목적에서만 사용

**(3) 재사용 가능한 컴포넌트**

\- 독립적인 객체로 설계되어 재사용성이 높음

\- 애플리케이션의 다양한 곳에서 활용 가능

**(4) DI(의존성 주입) 대상**

\- 다른 빈과의 의존 관계를 가질 수 있음

\- 스프링 컨테이너로부터 의존성을 주입받아 결합도를 낮춤

#### **3\. 사용 이유**

**(1) 객체 관리의 효율성 증대**

\- 스프링 컨테이너가 빈의 생성, 소멸, 의존성 관리를 자동으로 처리해주므로 개발자는 객체 관리에 대한 부담을 덜고 비즈니스 로직에 집중 가능

**(2) 컴포넌트 재사용성 및 유지보수성 향상**

\- 독립적인 단위로 설계되어 재사용성이 높음

\- 설정과 코드가 분리되어 유지보수가 용이

**(3) IoC/DI 컨테이너의 핵심 요소**

\- 빈은 스프링 IoC/DI 컨테이너의 핵심 관리 대상

\- 스프링 프레임워크의 다양한 기능을 활용하기 위한 기본적인 구성 요소

#### **4\. 사용 방법**

**(1) 빈 정의**

\- XML 설정 파일, 클래스 레벨 어노테이션, 또는 Java Config 등을 사용하여 빈을 정의

\- 빈의 클래스 정보, 초기화/소멸 메서드, 의존 관계 등을 설정 정보에 명시

**(2) 스프링 컨테이너에 등록**

\- 정의된 빈 설정 정보를 스프링 컨테이너에게 전달하여 빈을 컨테이너에 등록함

\- 컨테이너는 설정 정보를 기반으로 빈을 생성하고 관리함

**(3) 빈 획득 및 사용**

\- 애플리케이션 코드에서는 의존성 주입으로 빈을 전달받아 사용함

\- ApplicationContext#getBean() 직접 조회는 테스트, 초기 부트스트랩, 프레임워크/인프라 코드에서만 예외적으로 사용함

#### **5\. 빈의 스코프**

**(1) 주요 스코프 유형**

| **Singleton** |  - 기본 스코프   \- 애플리케이션 전체에서 단 하나의 객체 인스턴스만을 유지   \- 기본적으로 컨테이너 초기화 시점에 미리 생성됨   \- @Lazy 지정 시 최초 요청 시점에 생성됨   \- 애플리케이션 전체가 아니라 ApplicationContext 당 한 개임   \- 가장 일반적인 스코프   \- 스프링 BEAN의 기본 스코프 |
| --- | --- |
| **Prototype** | \- 빈을 요청할 때마다 새로운 객체 인스턴스를 생성   \- 상태를 가지는 객체를 매번 새롭게 필요로 하는 경우에 사용됨   \- 생성 시점마다 새 객체가 생성되므로, 소멸 시점 관리는 컨테이너가 아닌 사용자가 직접 담당해야 하는 경우가 많음   \- 초기화 콜백은 호출되지만, 소멸 콜백은 호출되지 않음 |
| **Request** | \- 웹 애플리케이션 환경에서, HTTP 요청 당 하나의 빈 인스턴스가 생성되고 요청이 끝나면 소멸됨   \- 주로 Spring MVC 요청 처리 과정에서 사용 |
| **Session** | \- 웹 애플리케이션 환경에서, HTTP 세션 당 하나의 빈 인스턴스를 유지   \- 사용자별 세션 범위로 객체를 관리해야 할 때 사용 |
| **Application** | \- 웹 애플리케이션 환경에서, 서블릿 컨텍스트(애플리케이션) 당 하나의 빈 인스턴스를 유지함   \- 공용 캐시, 공용 메타데이터 보관 등에 사용됨 |
| **WebSocket** | \- WebSocket 세션 당 하나의 빈 인스턴스를 유지함   \- 실시간 통신 세션별 상태를 유지해야 하는 경우에 사용됨 |

#### **6\. 빈의 생명주기**

\- 스프링 빈은 컨테이너에 의해 생성되고

\- 의존성을 주입받으며

\- 필요한 경우 초기화 및 소멸 과정 등을 거침

| **Bean 생성(Instantiation)** | \- 스프링 컨테이너가 빈 정의를 확인하고, 빈 클래스로부터 인스턴스를 생성함 |
| --- | --- |
| **의존성 주입(Dependency Injection)** | \- @Autiwired 어노테이션, 생성자 주입, 세터 주입 등을 통해 필요한 다른 빈을 주입 받음 |
| **초기화 단계** | \- 빈 생성과 의존성 주입이 끝난 후, 필요한 초기화 로직을 수행   \- 어노테이션기반 혹은 XML 설정을 통해 초기화 메서드를 지정할 수 있음   \- 초기화 과정에서 추가적으로 BeanPostProcessor들이 개입하여 빈의 프로퍼티를 확인하거나, AOP 적용 등 다양한 후처리 수행 가능 |
| **사용** | \- 애플리케이션 로직에서 빈을 활용함   \- 싱글톤 스코프 빈은 컨테이너가 종료되기 전까지 계속 유지됨   \- 프로토타입 스코프 빈은 획득 시마다 새 인스턴스로 사용됨 |
| **소멸 단계** | \- 스프링 컨테이너가 종료되거나, 빈이 더 이상 필요 없을 때 소멸 과정을 거침   \- 소멸 직전에 필요한 정리 작업(리소스 해제) 을 수행 가능   \- 프로토타입 스코프 빈의 경우 컨테이너가 소멸과정을 관리하지 않으므로, 사용자가 직접 소멸 처리를 해주어야 할 수 있음 |
