## **🧠 회고**

연휴 전날이다!!! 그동안 열심히 달려온 내가 너무 기특하다... 하지만 연휴에도 놀면 안되겠지 ㅠ.ㅠ 꼬박꼬박 복습하고 노트정리도 꼭 해야겠다... 지금 안하면 할 시간이 없을 듯... CS 지식도 좀 쌓고... 부족한 만큼 열심히 해야겠다... 

## **🪽 오늘의 다짐**

1.  배운 내용 총 복습
2.  노트 정리하기

---

## **📝 Today I Learned**

### **1️⃣ DI**

#### **1\. 정의**

\- 객체가 필요로 하는 의존 객체를 직접 명시하지 않고, 외부에서 주입받는 디자인 패턴

\- 객체 간의 의존 관계를 코드 내부가 아닌 외부에서 설정하고 주입하는 방식

\- 객체 간의 결합도를 낮추고, 코드 재사용성, 유지보수성, 테스트 용이성을 높일 수 있음

#### **2\. DI / IoC**

**(1) DI**

\- IoC를 구현하는 구체적인 방법 중 하나

\- IoC는 객체 생성, 생명주기 관리 등 객체에 대한 제어 권한을 개발자로부터 프레임워크로 역전시키는 원리

\- DI는 이러한 IoC를 달성하기 위한 핵심 메커니즘으로 사용됨

**(2) IoC**

\- 스프링 프레임워크는 IoC 컨테이너를 제공하고, DI를 주요 방식으로 활용하여 IoC를 구현함

#### **3\. 특징**

**(1) 의존 객체를 외부에서 주입**

\- 객체가 필요로 하는 의존 객체를 직접 생성하거나 찾지 않고, 외부에서 주입받음

**(2) 객체 간 결합도 감소**

\- 의존 객체를 직접 생성하는 대신 주입받으므로, 객체 간의 결합도가 낮아짐

**(3) 인터페이스 기반 설계 장려**

\- 인터페이스 또는 추상 클래스를 통해 의존성을 주입받는 형식을 권장하여, 구현 클래스에 대한 의존성을 줄이고 유연성을 높임

#### **4\. 사용 이유**

**(1) 객체 결합도 감소**

\- 객체 간의 의존 관계가 외부에서 설정되고 주입되므로, 객체 간의 결합도가 낮아짐

\- 코드 변경에 대한 영향 범위를 줄이고, 시스템을 유연하게 만들어줌

**(2) 코드 재사용성 및 모듈화 증대**

\- 객체는 독립적인 컴포넌트 형태로 개발될 수 있으며, 다양한 환경에서 재사용될 수 있음

\- 모듈화된 컴포넌트들을 조립하여 애플리케이션을 구성하기 용이해짐

**(3) 테스트 용이성 향상**

\- 의존 객체를 Mock 객체나 테스트용 구현체로 쉽게 대체할 수 있음

\- 단위 테스트를 격리된 환경에서 수행하고, 테스트 코드 작성을 용이하게 만들어줌

**(4) 개발 생산성 및 유지보수성 향상**

\- 객체 생성 및 의존 관계 설정에 대한 코드를 줄여 개발 생산성을 향상시킴

\- 낮은 결합도와 높은 모듈화로 인해 시스템 유지보수성을 높임

#### **5\. 사용 방법**

\- 세 가지 방식

**(1) 생성자 주입**

\- 생성자를 통해 의존 객체를 주입받는 방식

\- 필수적인 의존 관계에 사용됨

\- 객체 생성 시점에 의존성이 완전히 주입되어야 함

**(2) Setter/메서드 주입**

\- Setter 또는 일반 메서드를 통해 의존 객체를 주입받는 방식

\- 선택적인 의존 관계에 사용됨

\- 객체 생성 후에도 의존성을 주입할 수 있음

**(3) 필드 주입 (지양)**

\- 필드에 직접 의존 객체를 주입받는 방식

\- 코드가 간결해짐

\- 불변성 보장 불가, 테스트의 어려움, 순환 참조를 숨겨 문제 발견이 늦어질 수 있음 

---

### **2️⃣ AOP**

#### **1\. 정의**

\- 관점 지향 프로그래밍

\- 핵심 관심사와 횡단 관심사를 분리하여 모듈화하는 프로그래밍 패러다임

> **❓ 핵심 관심사**  
> \- 애플리케이션의 비즈니스 로직 자체에 해당하는 기능  
> \- 애플리케이션의 주요 목표를 달성하기 위한 핵심적인 로직

> **❓ 횡단 관심사**  
> \- 여러 핵심 관심사(클래스, 메서드 등)에 공통적으로 적용되는 기능  
> \- 애플리케이션 전체에 걸쳐 반복적으로 나타나며, 핵심 로직과 분리하여 관리하는 것이 효율적

#### **2\. 사용 이유**

**(1) 횡단 관심사 코드 중복 제거**

\- 횡단 관심사(로깅, 보안, 트랜잭션 등)를 Aspect로 모듈화

👉🏻 여러 핵심 관심사에 반복적으로 나타나는 횡단 관심사 코드를 제거하고 중복을 줄임

**(2) 핵심 로직 코드 가독성 및 유지보수성 향상**

\- 횡단 관심사 코드를 핵심 로직 코드에서 분리함

👉🏻 핵심 로직 코드를 더 간결하고 이해하기 쉽게 만들고, 유지보수성 향상시킴

\- 핵심 로직은 비즈니스 로직에만 집중하고, 횡단 관심사는 Aspect에서 관리함

👉🏻 코드의 응집도가 높아짐

**(3) 모듈성 및 재사용성 증대**

\- Aspect는 횡단 관심사를 모듈화한 독립적인 단위

👉🏻 여러 애플리케이션 또는 모듈에서 재사용 가능

\- 횡단 관심사 변경 시 Aspect만 수정하면 됨

👉🏻 시스템의 모듈성과 재사용성을 높임

**(4) 비침투적 적용**

\- Aspect는 핵심 로직 코드 자체를 수정하지 않고 적용됨

👉🏻 기존 코드에 대한 영향 없이 횡단 관심사를 추가하거나 제거할 수 있음

\- 애플리케이션 기능 확장 및 변경에 유연하게 대처 가능

#### **3\. 사용 방법**

**(1) 주요 개념**

| **Aspect** | \- 횡단 관심사를 모듈화한 코드   \- 횡단 관심사를 구현하는 Advice와 Advice를 적용할 Pointcut을 함께 정의함   \- 클래스 형태로 구현됨   \- 스프링에서는 @Aspect 어노테이션을 사용하여 Aspect 정의 |
| --- | --- |
| **Advice** | \- Aspect가 실제로 수행하는 횡단 관심사 기능을 구현한 코드   \- 특정 Join Point에 삽입되어 실행됨   \- 실행 시점 및 방식에 따라 여러종류가 있음      1\. Before Advice   \- Join Point 전에 실행되는 Advice   \- 메서드 실행 전에 로깅, 인증 등의 작업을 수행할 때 사용됨      2\. After Returning Advice   \- Join Point가 정상적으로 완료된 후 실행되는 Advice   \- 메서드 실행 성공 후 결과 값에 대한 작업을 수행할 때 사용됨      3\. After Throwing Advice   \- Join Point에서 예외가 발생했을 때 실행되는 Advice   \- 메서드 실행 중 예외 발생 시 예외 처리, 로깅 등의 작업을 수행할 때 사용됨      4\. After Finally Advice   \- Join Point 실행 결과와 상관없이 항상 실행되는 Advice   \- 리소스 해제, 마무리 작업 등을 수행할 때 사용됨      5\. Aroung Advice   \- Join Point 전 후에 모두 실행되는 Advice   \- 가장 강력함   \- Join Point 실행 자체를 제어 가능   \- 메서드 실행 시간 측정, 트랙잭션 처리, 보안 검사 등을 수행할 때 사용됨 |
| **Pointcut** | \- Advice를 적용할 Join Point를 지정하는 표현식   \- 어떤 클래스의 어떤 메서드에 Advice를 적용할지 결정함   \- AspectJ 포인트컷 표현식을 사용함   \- 스프링 AOP 에서는 어노테이션 또는 XML 설정을 통해 포인트컷을 정의 |
| **Join Point** | \- Advice가 삽입되어 실행될 수 있는 프로그램 실행 시점   \- 스프링 AOP에서는 메서드 실행만 Join Point가 됨   \- Advice는 Pointcut에 의해 지정된 Join Point에서 실행됨 |
| **Weaving** | \- Aspect를 핵심 관심사 코드에 적용하는 과정   \- AspectJ에서는 Weaving을 컴파일 시점이나 클래스 로드 시점 등에 수행할 수 있음   \- 스프링 AOP는 기본적으로 컴파일/로드타임 Weaving을 사용하지 않고, 런타임에 생성된 프록시를 통해 Aspect를 적용함 |

**(2) 사용 방법 (어노테이션 기반)**

\- Aspect 클래스 정의

👉🏻 @Aspect 어노테이션을 사용하여 Aspect 클래스를 정의함

👉🏻 @Component 어노테이션을 함께 사용하여 스프링 빈으로 등록함

\- Advice 정의

👉🏻 Aspect 클래스 내에 @Before, @AfterReturning, @AfterThrowing, @After, @Around 어노테이션을 사용하여 Advice 메서드 정의

👉🏻 Advice 어노테이션에는 Pointcut 표현식을 파라미터로 지정하여 Advice를 적용할 Join Point를 설정

\- Pointcut 정의 (선택사항)

👉🏻 포인트컷 표현식을 재사용하기 위해 @Pointcut 어노테이션을 사용하여 포인트컷을 별도로 정의할 수 있음

👉🏻 @Pointcut 어노테이션이 붙은 메서드는 내용이 비어있어도 되며, 다른 Advice 어노테이션에서 @Pointcut 어노테이션이 정의된 메서드 이름을 참조하여 포인트컷을 재사용할 수 있음

\- AOP 활성화

👉🏻 스프링 부트에서는 spring-boot-starter-aop의존성을 추가하면 자동 구성으로 AOP가 활성화됨

#### **4\. AOP vs OOP**

|   | **OOP (객체지향 프로그래밍)** | **AOP (관점 지향 프로그래밍)** |
| --- | --- | --- |
| **주요 관심사** | \- 핵심 관심사   \- 비즈니스 로직 | \- 횡단 관심사   \- 애플리케이션 전반에 걸친 공통 기능 |
| **모듈화 단위** | \- 클래스   \- 객체 | \- Aspect   \- 횡단 관심사 모듈 |
| **코드 구성 방식** | 클래스, 상속, 다형성 등 객체지향 원칙 기반으로 코드 구성 | Aspect, Advice, Pointcut 등 AOP 관련 용어 및 개념 기반으로 코드 구성 |
| **목적** | 코드 재사용성, 유지 보수성, 캡슐화, 추상화 등 객체 모델링 및 비즈니스 로직 구현에 집중 | 횡단 관심사 모듈화, 코드 중복 제거, 핵심 로직 코드 가독성 향상 |
| **적용 대상** | 비즈니스 로직 | 횡단 관심사 |
| **관계** | 핵심 로직 구현에 적합한 패러다임 | OOP로 해결하기 어려운 횡단 관심사 문제 해결에 특화된 보조적인 패러다임 |

**(1) OOP**

\- 클래스와 객체를 중심으로 데이터와 행동을 묶어 캡슐화

\- 상속과 다형성을 통해 코드 재사용성과 확장성을 높이는 데 초점을 맞춤

\- 주로 핵심 비즈니스 로직을 객체 모델링하고 구현하는 데 효과적

**(2) AOP**

\- OOP로 모듈화하기 어려운 횡단 관심사를 Aspect라는 독립적인 모듈로 분리하여 관리

\- 핵심 로직 코드에 비침투적으로 적용하는 데 초점을 맞춤

\- 주로 횡단 관심사를 모듈화하고 코드 중복을 제거

\- 핵심 로직 코드의 가독성과 유지 보수성을 높이는 데 효과적

👉🏻 AOP가 OOP를 대체하는 것이 아니라, OOP로 해결하기 어려운 횡단 관심사 문제를 효과적으로 해결하기 위해 OOP를 보완하는 역할을 함

👉🏻 OOP로 핵심 비즈니스 로직을 구현하고, AOP로 횡단 관심사를 모듈화하여 시스템 전체의 모듈성, 재사용성, 유지보수성을 높일 수 있음
