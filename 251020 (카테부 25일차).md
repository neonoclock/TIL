## **🧠 회고**

오늘은 본격적인 오프라인 강의 첫 날이었다!

역시 집에서 온라인으로 듣는 것 보다 오프라인으로 사람들과 함께 모여 듣는 것이 훨씬 집중 잘되고 동기부여가 가득 되는 것 같았다.

점심에 팀원들이랑 같이 밥도 먹고 얘기도 하고... 너무 좋다!

앞으로 더 친해지고 더 열심히 서로 긍정적인 영향을 주고받는 6개월이 되었으면 좋겠다 ㅎㅎ

## **🪽 오늘의 다짐**

1\. 이번주에 복습 spring 밀린거 다하기...

2\. 5주차 과제 완료 후 제출

3\. 6주차 과제 최대한 빨리 끝내자!

---

## **📝 Today I Learned**

### **1️⃣ Database**

#### **1\. 정의**

\- 자료를 정보로 활용하기 위해서 구조화 해놓은 데이터 모음\- 체계적인 구조를 갖고 데이터를 저장하고 관리함으로써 언제든지 의미있는 정보로 가공하여 활용할 수 있도록 만들어진 데이터의 집합체

#### **2\. 사용 이유**

**(1) 데이터의 영속성 및 안정성**

\- 메모리는 휘발성이기에 하드디스크나 SSD에 저장하기 위함\- 데이터의 주기를 영속적으로 만들어줌

**(2) 데이터의 무결성 및 신뢰성**

\- 데이터베이스는 구조화를 강제할 수 있음

> **❓ 무결성**  
> \- 데이터가 정확하고 일관되게 유지하는 성질  
> \- 잘못된 값이나 중복이 없음을 의미

> **❓ 신뢰성**  
> \- 데이터가 오류 없이 안전하게 보관되고, 언제나 올바르게 접근 가능한 상태

**(3) 데이터의 동시 접근 및 공유**

\- 트랜잭션, 락을 이용해서 동시성을 보장  👉🏻 데이터의 일관성을 해치지 않도록 관리

#### **3\. RDB**

**(1) 정의**

\- 자료를 정보로 활용하기 위해 테이블 형태로 관계를 맺어 놓은 데이터 모음

**(2) 사용 이유**

\- 데이터를 테이블 체계로 저장하여, 데이터의 안정성과 신뢰성을 보장하기 위함

**(3) 사용 방법**

\- 특정 규칙에 따라 데이터를 입력, 업데이트, 조회하는 SQL을 통하여

**(5) RDBMS**

\- 관계형 데이터베이스를 관리할 수 있는 프로그램

#### **4\. 테이블 구조**

\- 하나의 row는 하나의 개체에 대한 완전한 정보(칼럼 대비)를 담고 있다[##_Image|kage@bVwVcr/dJMb9LYhLgm/AAAAAAAAAAAAAAAAAAAAAJ_kmMB4El3IfDaVPSjO2TSLjkXwhuKSl_vEa6Dkgfeq/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=knYtY5KKGwNTVlX%2BH8V69VXYCFc%3D|CDM|1.3|{"originWidth":1530,"originHeight":758,"style":"alignCenter","filename":"스크린샷 2025-10-20 오후 3.22.26.png"}_##]

#### **5\. 칼럼에서 사용할 수 있는 타입**

**(1) BOOLEAN**

\- true 또는 false일 수 있는 bool 값\- DB에서 제공하는 자료형을 사용하기도 하는데 TINYINT(1)로 관리하기도 함\- 0 혹은 1을 구현하기도 함(0은 False, 1은 True)\- 소프트 딜리트(삭제 여부, is\_deleted, deleted\_at), 공개 여부(is\_public)

**(2) INT**

\- 정수 값을 저장하는 데 사용됨

**(3) FLOAT**

\- 부동 소수점 숫자\- 소수점 다루지만 정밀도 문제 발생할 수 있다\- 계산할 때는 DECIMAL

**(4) VARCHAR(n)**

\- 가변 길이 문자열을 저장하는데 사용됨\- n은 최대 문자열 길이 의미

**(5) CHAR(n)**

\- 고정 길이 문자열을 저장하는데 사용됨\- n은 고정된 최대 문자열 길이\- 주민 등록 번호, Y/N, 국가 코드, 성별

**(6) TEXT**

\- 최대 65,535자 길이의 더 긴 문자열\- 더 많은 길이의 문자열 저장할 수 있으나 검색시 성능 이슈 존재

**(7) DATE**

\- YYYY-MM-DD 형식으로 날짜 값

**(8) DATETIME**

\- YYYY-MM-DD HH:MI:SS 형식으로 날짜 및 시간 값 형식

**(9) TIMESTAMP**

\- time\_zone이라는 시스템 변수로 저장된 값을 기본으로 함\- 범위: 1970-01-01 00:00:01 UTC 부터 2038-01-19 03:14:07 UTC\- 장점: 날짜를 따로 입력 안해도 row 추가시 자동으로 입력 가능\- row 추가한 시간을 자동으로 알 수 있음\- 게시글 업로드 시간

#### **6\. DBMS  
**

**(1) 정의**

\- 데이터베이스를 관리할 수 있는 체계, 프로그램

**(2) 사용이유**

\- 다수의 사용자들이 데이터베이스 내의 데이터에 접근할 수 있도록 하기 위함

#### **7\. RDBMS**  

**(1) 정의**

\- 관계형 데이터 베이스를 관리할 수 있는 프로그램

> **DBMS**는 데이터를 저장·관리하는 시스템이고,  
> **RDBMS**는 그중에서도 데이터를 테이블(관계형) 구조로 관리하는 시스템이다.

---

### **2️⃣ 정규화**

#### **1\. 정의**

\- 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스

\- 데이터 구조를 안전하고 효율적으로 다루기 위하여 존재하는 원칙

#### **2\. 사용 이유**

\- 무결성을 유지하고 저장 용량을 줄이기 위함

\- 중복의 최소화

👉🏻 저장 공간 낭비

👉🏻 데이터 불일치

👉🏻 데이터가 단 한 곳에서 저장되도록 구조를 개선

\- 데이터 구조화

👉🏻 논리적 근거에 따라서 데이터의 관계를 명확하게 하고 관계에 맞게 테이블을 재구성하는 과정

👉🏻 데이터의 의미가 명확해짐

👉🏻 시스템의 구조가 이해하기 쉬워지고 유지보수나 확장에 용이

#### **3\. 이상 현상** 

\- 데이터베이스 설계가 잘못되었을 떄 발생하는 문제점

\- 데이터의 중복, 삽입, 삭제, 갱신 등의 연산이 부적절하게 이루어질 때 발생

\- 삽입 이상, 삭제 이상, 갱신이상

**(1) 삽입 이상**

\- 데이터를 삽입하려고 할 때, 원하지 않는 정보까지 입력해야 하는 경우

**(2) 삭제 이상**

\- 한 데이터를 삭제할 때, 관련된 정보까지 함께 삭제되어 원하지 않는 데이터 손실이 발생하는 현상

**(3) 갱신 이상**

\- 데이터 중복으로 인해 데이터를 갱신할 때 일관성이 없어지는 현상

👉🏻 데이터베이스 이상현상을 없애기 위해 테이블을 나누는 작업 필요

👉🏻 정규화

#### **4\. 사용 방법**

\- 정규화 과정을 적용해서 DB 설계함

**(1) 제 1정규형**

\- 데이터베이스 테이블이 가장 기본적인 정리 단계에 있을 때의 상태

\- 테이블이 기본적인 구조를 가지며, 각 필드(열)에는 하나의 값만 들어가야 함

\- 테이블의 모든 칼럼은 반드시 원자값을 가져야 한다

**(2) 제 2정규형**

\- 제1정규형을 만족하는 테이블에서, 기본 키가 아닌 나머지 컬럼들이 기본 키 전체에 완전히 종속될 때

\- 주 키의 일부만을 사용하여 다른 속성을 결정할 수 없어야 함

\- 기본 키의 일부가 아닌 모든 컬럼은 기본키의 전체에 완전 함수 종속되어야 한다

👉🏻 완전 함수 종속

👉🏻 부분 함수 종속: 복합 기본키를 구성하는 여러 컬럼이 있다면 일부 컬럼에 종속되는 컬럼이 존재하는 경우 제 2정규형은 이 부분 함수 종속을 제거하는 과정

\- 테이블에서 부분적 종속성을 제거하여 데이터 중복을 줄이고, 데이터 무결성을 보장하기 위함

**(3) 제 3정규형**

\- 제 2정규형을 만족하며, 모든 non-key 속성이 non-key가 아닌 다른 속성에 대해 이행적으로 종속되지 않는 상태

\- 어떤 속성도 기본 키에만 직접적으로 종속되어야 하며, 다른 non-key 속성에 의존해서는 안됨

\- 데이터 중복을 더욱 줄이고, 데이터를 수정할 때 발생할 수 있는 오류 방지

> **제1정규형 (1NF)**: 모든 컬럼이 원자값(쪼갤 수 없는 값)만 가져야 함.  
> **제2정규형 (2NF)**: 부분 함수 종속 제거 — 기본키의 일부에만 의존하는 컬럼 제거.  
> **제3정규형 (3NF)**: 이행적 종속 제거 — 기본키가 아닌 컬럼에 의존하는 컬럼 제거.

---

### **3️⃣  SQL 기초**

#### **1\. 정의**

\- 데이터베이스 시스템에서 자료를 처리하는 용도로 사용되는 구조적 데이터 질의 언어

\- 선언형 언어

👉🏻 무엇을(what) 원하는지만 말하면 어떻게 그 작업을(how) 수행할지는 DBMS가 알아서 결정함

👉🏻 DB 내부의 옵티마이저가 how에 관한 역할을 함

#### **2\. 사용 이유**

\- 데이터 베이스의 데이터를 조회, 추가, 수정, 삭제하기 위함

#### **3\. 사용 방법**

\- SQL 명령어를 작성해서 사용

**(1) 데이터 정의어 (DDL)**

\- 데이터베이스의 구조를 만들거나 변경하는 데 사용되는 언어

**<테이블 추가>**

| **CREATE** | 새 테이블이나 DB 만들기 |
| --- | --- |

**<테이블 수정>**

| **ADD** | \- 새로운 열을 테이블에 추가   \- 열의 이름, 데이터 유형을 지정해야함   \- 필요한 경우 제약조건도 추가 가능 |
| --- | --- |
| **AFTER** | \- ADD 작업과 함께 사용되어 새로 추가하는 열의 위치를 기존 열 다음으로 지정할 때 사용됨   \- 만약 AFTER를 사용하지 않으면, 새 열은 테이블의 마지막에 추가됨 |
| **MODIFY** | \- 기존의 열의 데이터 유형을 변경할 때 사용됨   \- 열의 데이터 유형을 새로운 유형으로 변경할 수 있음   \- 필요에 따라 제약조건도 수정 가능 |
| **ALTER** | \- 테이블의 구조 구조(칼럼, 제약조건 등) 변경   \- 이 명령어 뒤에는 테이블 이름과 수행할 작업이 지정 |

**<테이블 삭제>**

| **DROP** | \- 테이블에서 기존의 열을 삭제할 때 사용됨   \- 삭제하고자 하는 열의 이름을 지정해야 함   \- 열을 삭제하면 해당 열에 저장된 모든 데이터도 함께 삭제되므로 주의 필요 |
| --- | --- |
| **TRUNCATE** | 테이블 내용 전부 지우기 (구조는 남음) |

**(2) 데이터 조작어 (DML)**

\- 데이터베이스에 저장된 데이터를 조회, 추가, 수정, 삭제하는 데 사용되는 언어

**<데이터 삽입>**

| **INSERT** | \- 새로운 데이터를 테이블에 삽입하기 위해   \- 이 명령어 뒤에는 데이터를 추가할 테이블의 이름, 데이터를 삽입할 열의 이름이 괄호 안에 나열됨   \- 열의 이름을 지정한 순서대로 데이터를 삽입함 |
| --- | --- |

**<데이터 조회>**

| **SELECT** | \- 테이블에서 하나 이상의 열의 데이터를 조회하기 위해 사용됨   \- 조회하고자 하는 열의 이름 명시 가능   \- 특정 조건을 만족하는 데이터만 선택하는 등 다양한 옵션을 함께 사용 가능 |
| --- | --- |
| **SELECT \*** | \- 모든 열을 의미   \- 사용하지 않아야 하는 이유   👉🏻 성능 저하: 사용하지도 않을 불필요한 데이터까지 모두 가져와서 메모리 사용 비효율   👉🏻 유지보수 어려움: 테이블에 새로운 컬럼 추가되면 예상하지 못한 데이터가 넘어올 수도 있음   👉🏻 가독성: 필요한 컬럼을 명시적으로 작성을 해주는게 의도를 파악하기 쉬움 |

**<데이터 수정>**

| **UPDATE** | \- 기존에 저장된 데이터의 값을 변경하기 위해 사용됨   \- 이 명령어 뒤에는 데이터를 수정할 테이블의 이름이 옴   \- 수정 작업은 선택된 테이블에 대해 수행되며, 특정 조건을 만족하는 레코드에 한해서만 값으 ㄹ변경 가능 |
| --- | --- |
| **SET** | \- UPDATE 명령어와 함께 사용됨   \- 수정하고자 하는 열과 새로운 값을 지정   \- SET 다음에는 열의 이름과 그 열에 할당할 새로운 값 등장   \- 열 이름 뒤에 등호를 사용해 해당 열에 새로운 값 할당 |

**<데이터 삭제>**

| **DELETE** | \- 테이블에서 특정 레코드를 삭제하기 위해 사용됨   \- 삭제할 데이터의 조건을 명시할 수 있음   \- 조건을 명시하지 않으면 테이블의 모든 레코드가 삭제될 위험 (WHERE 사용) |
| --- | --- |
| **FROM** | \- DELETE 명령어에서 데이터를 삭제할 테이블을 지정하는 데 사용   \- FROM 다음에는 테이블의 이름이 위치함, 이 테이블로부터 데이터가 삭제됨      \- 실무에서는 직접 DELETE 쿼리를 사용하는 것 자체를 Hard Delete라고 표현   \- DELETE 사용하지 않고 상태만 변경해서 삭제되었다고 표시하는 것을 Soft Delete (is\_deleted) |

**<WHERE>**

| **BETWEEN** | \- 두 값 사이에 있는 데이터 선택 |
| --- | --- |
| **AND** | \- 두 개 이상의 조건을 모두 만족하는 데이터를 찾을 때 사용 |
| **OR** | \- 여러 조건 중 하나라도 만족하는 데이터를 찾을 때 사용됨 |
| **NOT** | \- 조건을 부정할 때 사용됨 |
| **IN** | \- 지정된 값들 중 하나와 일치하는 데이터를 찾을 때 사용됨 |
| **LIKE** | \- 패턴 매칭을 이용하여 데이터를 찾을 때 사용됨   \- %는 0개 이상의 임의의 문자와 일치   \- \_는 정확히 하나의 임의의 문자와 일치   \- 검색어 앞에 % 붙으면 인덱스 사용 못함 (성능 저하) (문자열의 시작 위치가 불명확해서 DB가 전체 데이터를 다 뒤져야 함)   \- 검색이 필요하면 Full text Index, Elastic Search |

**<집계함수>**

| **MAX** | \- 어떤 열의 최대값을 찾을 때 사용 |
| --- | --- |
| **MIN** | \- 어떤 열의 최소값을 찾을 때 사용 |
| **AVG** | \- 열의 평균값을 계산할 때 사용 |
| **SUM** | \- 열의 값들을 모두 더하는 데 사용 |
| **COUNT** | \- 행의 수를 세는 데 사용   \- 특정 조건을 만족하는 행의 수를 세거나, 테이블 전체 레코드 수를 세는 등 다양한 용도로 사용 가능 |

**<정렬>**

| **HAVING** | \- GROUP BY 로 만들어진 그룹에 조건을 적용할 떄 사용   \- 그룹화된 데이터의 조건을 필터링 |
| --- | --- |

**(3) 데이터 제어어 (DCL)**

| **GRANT** | 사용자에게 권한 부여 |
| --- | --- |
| **REVOKE** | 사용자 권한 취소 |

---

### **4️⃣  SQL 응용**

#### **1\. JOIN**

**(1) 정의**

\- 하나 이상의 테이블 열을 새 테이블로 결합하는 것

**(2) 사용 이유**

\- 두 개 이상의 테이블에서 관련된 컬럼들을 결합하여 하나의 테이블 결과처럼 데이터를 조회하기 위함

**(3) 사용 방법**

\- JOIN 탕입을 명시한 후, 결합될 두 테이블을 지정하고 ON 키워드를 사용하여 조인의 기준이 되는 컬럼을 정의

**(4) 잘못 사용된 JOIN**

\- ON 절에서 조건 컬럼에 INDEX가 없는 경우

👉🏻 두 테이블의 모든 데이터를 하나씩 비교

👉🏻 성능 저하의 원인

👉🏻 FULL TABLE SCAN

\- 너무 많은 테이블을 JOIN 하는 경우

👉🏻 쿼리가 너무 복잡해지면 옵티마이저가 제대로 동작하지 못함

#### **2\. VIEW**

**(1) 정의**

\- 하나 이상의 테이블 (또는 다른 뷰)에서 원하는 모든 데이터를 선택해 사용자 정의하여 나타냄

\- 쿼리 성능 자체를 직접적으로 향상 시켜주지는 않음

\- 저장된 쿼리의 별명

**(2) 사용 이유**

\- 데이터 조회를 빠르게 하고, 재사용과 유지보수를 용이하게 하기 위함

**(3) 사용 방법**

\- CREATE VIEW SQL문을 사용해 필요한 데이터를 선택적으로 보여주는 가상의 테이블 상성

**(4) Materialized View**

\- VIEW가 쿼리 정의만 저장하는 가상 테이블

\- Materialized VIEW는 쿼리의 결과를 실제 물리적인 테이블처럼 저장해두는 개념

\- 단점

👉🏻 추가적인 저장 공간 필요

👉🏻 원본 테이블의 데이터 변경되면 갱신해줘야 함

\- 실무 사례

👉🏻 통계 데이터, 매일 전날 매출 통계 대시보드 (대시보드 페이지 조회할 때마다 계산하는 것 비효율적)

#### **3\. UNION**

**(1) 정의**

\- 두 SQL 쿼리문의 결과를 합치는 연산자

**(2) 사용 이유**

\- 서로 다른 테이블에서 검색된 결과를 하나의 결과로 결합하기 위함

**(3) 사용 방법**

\- 두 개 이상의 SELECT 문을 연결하여 각 쿼리의 결과를 하나의 결과 집합으로 합침

**(4) UNION vs UNION ALL**

\- UNION: 두 결과 집합을 합친 후 중복된 행을 제거

\- UNION ALL: 두 결과 집합을 그냥 그대로 합침, 중복제거 안함

👉🏻 중복을 제거한다는 것 자체가 DB에게 성능상 부담스러움

👉🏻두 결과 집합에 중복된 데이터가 나올 수 없는 상황이거나 중복이 있어도 상관 없으면 -> UNION ALL

👉🏻 중복 제거를 꼭 DB가 아니라 일단 조회해온 다음 백엔드 API Server에서 진행할 수도 있음

---

### **5️⃣ ERD**

#### **1\. 정의**

\- 개체와 관계를 한 눈에 알아볼 수 있도록 그려놓은 도표

#### **2\. 사용 이유**

\- 데이터베이스의 구조를 시각적으로 표현하여 데이터 간의 관계와 구조를 명확하게 이해하기 위함

#### **3\. 사용 방법**

\- 데이터베이스 구조를 설계할 때 엔터티와 속성, 관계를 식별하여 다이어그램으로 표현

\- 까마귀 발 표기법

[##_Image|kage@7I373/dJMb9YpIcmh/AAAAAAAAAAAAAAAAAAAAANXONQNxsLNHiXxCewrw3Q9zCqOdwJEf4Pbet-Iz3VUO/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=gwdhBILEtCT0Q8eeuKKMYDrlFIQ%3D|CDM|1.3|{"originWidth":1530,"originHeight":758,"style":"alignCenter","filename":"스크린샷 2025-10-20 오후 5.11.31.png"}_##]

**(1) One to One**

\- 하나의 엔티티(테이블)가 다른 엔티티(테이블) 하나만 관계를 맺는 경우

\- User와 UserProfile

\- 성능이나 보안상 이유로 테이블을 분리할 때 이런 구조

**(2) One to Many**

\- 하나의 엔티티(테이블)가 다른 여러 개의 엔티티(테이블)와 관계를 맺는 경우

\- User와 Order

**(3) Many to Many**

\- 양쪽 엔티티 모두 서로에 대해 여러 인스턴스와 관계를 맺을 수 있는 경우

\- 학생과 과목 -> 수강 신청 테이블을 추가

\- RDB에서는 다대다 관계를 물리적으로 표현할 수 없다 (1 정규형 위반)

\- mapping table(entity)
