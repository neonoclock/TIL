## **🧠 회고**

오늘은 오프라인 두 번째날! 오늘 5시에 일어나서 5주차 과제 하고... 위클리 챌린지때도 5주차 과제하고... 과제의 늪에 빠졌다.

과제를 계속 하다보니 복습이 미뤄지고 있는 것 같은데, DB 우선 정리와 과제 끝내고 지난번에 배웠던 Spring을 다시 한 번 봐야할 것 같다... 파이팅 ㅜㅜ

## **🪽 오늘의 다짐**

1\. DB 키워드 정리 다 하기

2\. 졸지 않기!!!!!!!!!

---

## **📝 Today I Learned**

### **1️⃣ Index**

#### **1\. Tree, BST, B-Tree, B+Tree**

**(1) Tree**

\- 노드로 이루어진 자료구조

\- 한 노드에서 시작해 다른 정점들을 순회하여 자기 자신에게 돌아오는 순환이 없는 연결 그래프

\- 트리 구조

-   계층적인 데이터 구조
-   부모-자식 관계를 가지는 노드들로 구성됨
-   상위 노드와 하위 노드 사이의 연결을 통해 계층적인 관계 형성

[##_Image|kage@Q5b21/dJMb9YiWOYI/AAAAAAAAAAAAAAAAAAAAAAnuKSjh6OgaSc88dDcbBZJ9nEFRx86aebS_jmIwu-LO/img.jpg?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=Rp7Syy5neOcyeKRdJQZJL0SaiFk%3D|CDM|1.3|{"originWidth":1880,"originHeight":1176,"style":"alignCenter","filename":"CED29E46-DD4B-40AB-B31E-0ABE16DDBF59.jpeg"}_##]

**(2) BST (Binary Search Tree)**

\- 이진 탐색 트리

\- 각 노드에 값이 있다

\- 값들은 정렬된 순서가 있다 (총 순서가 있음, 트리 안에서 값을 비교할 때 항상 어느 값이 더 크고 작은지 비교 가능)

\- 노드의 왼쪽 서브트리에는 그 노드의 값보다 작은 값들을 지닌 노드들로 이루어져 있음

\- 노드의 오른쪽 서브트리에는 그 노드의 값보다 큰 값들을 지닌 노드들로 이루어져 있음

\- 좌우 하위 트리는 각각이 다시 이진 탐색 트리여야 함

\- 문제점: 편향된 트리 구조 가지게 될 수 있음

[##_Image|kage@k26G4/dJMb9NBObTs/AAAAAAAAAAAAAAAAAAAAAOLFMf9sCOE5P22l8jxWbmW44j1gvZVX9KYre90fcKJ6/img.jpg?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=QARRHa6h3pmrcYCugLOnPtLC0Dg%3D|CDM|1.3|{"originWidth":885,"originHeight":737,"style":"alignCenter","filename":"363592C6-AA17-4054-B683-55D3F65A9D9B.jpeg"}_##]

**(3) B-tree**

\- 데이터베이스 및 파일 시스템에서 효율적인 데이터 검색을 위해 사용하는 트리 자료 구조

\- 하나의 노드가 여러 자식 노드를 가질 수 있음

\- 트리의 높이를 균형 있게 유지

\- 데이터 검색, 삽입, 삭제 작업이 로그 시간 복잡도를 유지

\- 인덱스에서 자주 사용

\- 대용량 데이터 처리에 유리한 구조

[##_Image|kage@bFu6qJ/dJMb9Qyw3u3/AAAAAAAAAAAAAAAAAAAAAJyoPeXiFtZwBHD0hnV0TGkM83omHloYsKDT_RmnsPNK/img.jpg?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=EC3gHH%2BPYxqxEMEBVQZR0g%2BnJzM%3D|CDM|1.3|{"originWidth":1612,"originHeight":500,"style":"alignCenter","filename":"E0C8B89D-E58A-45FD-9142-526C4C760E96.jpeg"}_##]

**(4) B+tree**

\- mysql innodb에서 데이터를 관리하는 자료구조

\- 키에 의해 각각 식별되는 레코드의 효율적 삽입, 검색과 삭제를 통해 정렬된 데이터를 표현하기 위한 트리자료 구조

\- 동적임

\- 각각의 인덱스 세그먼트(블록, 노드)내에 최대와 최소 범위의 키의 개수를 가지는 다계층 인덱스로 구성됨

\- 모든 레코드들이 가장 하위 레벨에 정렬되어 있음

\- 오직 키들만이 내브 블록에 저장됨

\- 데이터가 leaf 노드에만 있음

\- 리프노드가 아닌 노드는 인덱스 역할만 수행

[##_Image|kage@pAMDz/dJMb9aX0mtj/AAAAAAAAAAAAAAAAAAAAAMmn09K6n-fvAKou9cV5assBNpl_PnBHtN3BEwN3inkA/img.jpg?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=KOkWw4Ae2IRFTPHOnlgxLTpFCfU%3D|CDM|1.3|{"originWidth":895,"originHeight":427,"style":"alignCenter","filename":"20F18896-A8BB-4964-AEC8-8EC9729B6B81.jpeg"}_##]

#### **2\. Index**

**(1) 정의**

\- 데이터베이스 분야에 있어서 테이블에 대한 조회 동작의 속도를 높여주는 자료구조

**(2) 클러스터형 인덱스**

\- 데이터가 인덱스 순서대로 물리적으로 정렬되어 저장되는 인덱스

\- 특징

| 단일성 | \- 한 테이블에는 오직 하나의 클러스터형 인덱스만 존재 가능   \- 클러스터형 인덱스가 테이블의 물리적인 구조를 결정하기 때문 |
| --- | --- |
| 물리적 정렬 | \- 테이블의 레코드를 인덱스가 정의한 순서대로 물리적으로 재정렬 |
| 자동 생성 | \- 일반적으로 테이블의 기본 키를 설정하면 해당 키에 대해서 클러스터형 인덱스가 자동으로 생성됨   \- 기본 키가 없는 경우에는 유저가 직접 클러스터형 인덱스를 지정할 수 있음 |
| 인덱스 구조 | \- 별도의 인덱스 테이블을 만들지 않고 데이터 테이블 자체를 인덱스로 사용   \- 데이터 조회 시 인덱스 테이블과 데이터 테이블 사이의 별도 이동 없이 바로 접근이 가능하다는 장점 |

**(3) 비클러스터형 인덱스**

\- 인덱스와 데이터가 물리적으로 분리되어 있음

\- 인덱스가 별도의 인덱스 테이블에 저장되고, 이 테이블에는 원본 데이터 위치를 가리키는 포인터만 포함되어 있는 인덱스

👉🏻 이러한 포인터를 통해 원본 데이터를 참조함

\- 특징

| 다중성 | \- 한 테이블에 여러 개의 비클러스터형 인덱스 존재 가능   \- 서로 다른 검색 조건과 쿼리에 최적화된 다양한 인덱스를 생성할 수 있기 때문 |
| --- | --- |
| 논리적 정렬 | \- 인덱스 키 값을 기준으로 정렬된 인덱스 페이지 생성   \- 이 페이지는 원본 데이터 행을 가리키는 포인터 포함 |
| 공간 요구 | \- 인덱스 구조 자체가 별도의 저장 공간을 차지함   \- 인덱스를 많이 만들면 만들수록 더 많은 디스크 공간 사용 |
| 활용 예시 | \- 검색 속도 향상시키기 위해 사용됨 |

> **❓ 인덱스 페이지**  
> \- 인덱스 데이터가 저장된 논리적 페이지  
> \- 특정 키 값과 원본 데이터 위치를 가리키는 포인터가 포함되어 있음  
> \- 데이터베이스가 빠르게 필요한 정보를 찾을 수 있도록 하는 구조

> **❓ 포인터**  
> \- 실제 데이터가 저장된 위치를 가리키는 정보  
> \- 개발자가 직접 볼 수 있는 데이터가 아님  
> \- 비클러스터형 인덱스의 내부 구조에 포함되어 데이터베이스 엔진이 데이터 조회 시 참조할 수 있도록 설계된 것

\- 구조

-   B-tree 또는 B+tree와 같은 구조로 구현됨
-   각 인덱스 페이지는 트리의 노드처럼 동작함

| 루트 페이지 | \- 인덱스의 최상위 페이지   \- 트리 구조에서 최상위 노드 역할   \- 검색 시작 |
| --- | --- |
| 중간 페이지(내부 노드) | \- 루트와 리프 페이지 사이의 중간 노드   \- 검색 경로 가속화 |
| 리프 페이지(최하위 노드) | \- 인덱스의 최하위 레벨 페이지   \- 각 키 값과 그에 대한 포인터 포함   \- 원본 데이터 직접 가리킴 |

> **❓ 카디널리티**  
> \- 데이터베이스의 테이블 열(컬럼)에서 데이터 값의 고유성을 나타내는 지표  
> \- 컬럼당 고유한 값의 개수  
> \- 카디널리티가 낮다 = 중복도가 높다  
> \- 카디널리티가 높다 = 중복도가 낮다

**(4) 알아야하는 이유**

\- 인덱스를 사용해 데이터를 정렬하면 매우 빠르게 정렬된 결과를 출력할 수 있기 때문

\- 단점

-   실제 칼럼이 수정, 삭제되면 인덱스 데이터도 수정, 삭제해야 하기에 오히려 느릴 수 있음
-   조회할 때 LIKE '%검색어'로 %가 들어갈 때는 인덱스 사용 불가능
