## **🧠 회고**

오늘 수요일인데 왜 이렇게 목요일 같을까... 우선 5주차 과제 완료해서 어제 제출하였고, 이번주 과제는 금요일까지 꼭 마감할 것이다.

그리고 키워드 정리로 복습을 진행해야할 것 같은데 지금까지 이 블로그에서 작성한 것 처럼 흐름으로 정리하는 것도 좋을 것 같고... 사실 둘 다 하고 싶고 노트로도 단원별로 싹 다 정리하고 싶은데 시간이 없다 제발 하루가 48시간이길

## **🪽 오늘의 다짐**

1\. 졸지 않기 (수업 집중 잘하기)

2\. 할 일 다하기

3\. 별 다른 일 없으면 워크 스페이스에서 9시까지 있다가 가기

---

## **📝 Today I Learned**

### **1️⃣ Index (2)**

#### **1\. 단점**

\- 물리적인 공간 차지

\- CUD 성능 저하

-   CUD 할때마다 데이터만 바꾸는 것이 아니라 테이블에 걸린 모든 인덱스를 함께 갱신해야 함

> **❓ CUD**  
> Create, Update, Delete

#### **2\. EXPLAIN**

\- 실행 계획 확인하기

\- 개발자가 인덱스를 제대로 이해하고 사용하는지 가장 좋은 방법 = 실행계획을 볼 줄 아는가

\- 데이터베이스의 쿼리 옵티마이저가 쿼리를 어떻게 실행할 것인지 계획을 미리 보여주는 도구

#### **3\. EXPLAIN 쿼리 결과**

**(1) type**

\- 이 쿼리가 데이터를 어떻게 찾았는지를 나타냄

-   **ALL**
    -   풀스캔
    -   인덱스 전혀 활용 못하고 있음
-   **index**
    -   풀 인덱스 스캔
    -   인덱스 전체를 훑음
-   **range**
    -   인덱스를 사용해서 특정범위 탐색함
    -   BETWEEN, >, < 조건에서 나타남
-   **ref**
    -   인덱스 사용해서 동등비교함 (=)
-   **const, system**
    -   결과를 한 건으로 특정할 수 있을 때
    -   pk, unique
-   **fulltext**
    -   fulltext index 사용함

**(2) possible\_keys**

\- 옵티마이저가 이 쿼리에 사용할 수 있다고 고려한 인덱스 목록

**(3) key**

\- 옵티마이저가 여러 후보 중 실제로 사용하기로 한 인덱스

\- NULL이면 인덱스 사용안했다는 뜻

**(4) rows**

\- 옵티마이저가 이 쿼리를 처리하기 위해 읽어야 할 것이라고 예측한 데이터 행의 수

**(5) Extra**

\- 추가적인 정보 표시

-   **Using where**
    -   WHERE절 조건으로 데이터 필터링 했다는 이야기
-   **Using index**
    -   커버링 인덱스가 사용됐다는 의미
    -   쿼리에 필요한 모든 데이터가 인덱스에 포함되어 있어서 굳이 실제 테이블까지 가지 않고 인덱스에서만 정보 읽어서 처리함
-   **Using filesort**
    -   인덱스 사용하지 못하고 별도의 메모리 공간이나 디스크 사용해서 데이터 정렬
    -   성능저하의 주범

> **❓ 옵티마이저**  
> SQL을 실행할 때 가장 효율적인 실행 계획을 자동으로 선택하는 DB의 두뇌

> **❓ 커버링 인덱스**  
> 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 테이블을 읽지 않고 인덱스만으로 결과를 반환할 수 있는 인덱스

#### **4\. INDEX 단점**

\- INDEX는 무조건 성능을 좋게 만들지 않음

**(1) 데이터 크기**

\- 인덱스는 데이터가 많을수록 효과가 커지지만, 10만 건 정도의 규모에서는 인덱스 효과가 뚜렷하지 않을 수도 있음

**(2) 캐싱**

\- 데이터베이스는 한 번 읽은 데이터를 메모리(InnoDB 버퍼 풀) 에 캐싱

\- 따라서 캐시된 상태에서는 인덱스 효과가 왜곡될 수 있어, 정확한 성능 비교를 위해 테스트 전 캐시를 비우는 것이 중요

**(3) 옵티마이저의 판단**

\- 데이터 분포나 조건에 따라 인덱스를 타는 것보다 전체 스캔이 더 효율적이라 판단해 인덱스를 사용하지 않을 수도 있음

#### **5\. 인덱스는 트레이드 오프다**

\- 읽기 속도를 위해서 쓰기 속도와 저장 공간을 희생하는 것

\- 서비스에서 읽기 중심인지, 쓰기 중심인지에 따라 인덱스 전략이 달라짐

#### **6\. Cardinality와 Selectivity**

**(1) Cardinality (고유값의 개수)**

\- 특정 칼럼의 고유값 개수

\- 높은 카디널리티: 중복이 적고 고유값이 많음

**(2) Selectivity (선택도)**

\- 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는지를 나타냄

\- Selectivity = Cardinality/Total Number of Records

\- Selectivity가 1에 가까울 수록 인덱스로 적합함 (고유값이 많을수록)

#### **7\. 다수 컬럼 인덱스**

\- 여러 컬럼을 묶어서 하나의 인덱스로 만드는 것

\- 컬럼의 순서가 인덱스 성능에 영향을 미침

\- WHERE 절에서 자주 사용되고 카디널리티 높은 컬럼을 앞 순서에 두어야 함

---

### **2️⃣ Full Text Index**

#### **1\. 정의**

컴퓨터에 저장된 문서나 텍스트 데이터 전체를 단어 단위로 분석해서, 원하는 키워드가 포함된 문서를 찾아주는 검색 기법 

#### **2\. 알아야 하는 이유**

\- 검색 기능과 같은 많은 내용들을 자주 검색해야할 때 더 빠르게 검색하기 위함

| **효율적인 검색** | \- 텍스트를 포함한 데이터베이스에서 필요한 정보 빠르게 찾을 수 있음 |
| --- | --- |
| **정확한 결과 제공** | \- 사용자가 검색 키워드를 입력   👉🏻 Index는 해당 키워드가 포함된 문서를 신속하게 찾아냄   👉🏻 관련성에 따라 정렬하여 보여줌 |
| **검색 규칙 적용 가능** | \- 특정 단어를 제외하는 등의 추가적인 검색 규칙을 적용하여 더욱 정밀한 검색 결과 얻을 수 있음 |

#### **3\. 동작 과정**

**(1) 파싱 및 토큰화**

\- 인덱스로 지정된 텍스트 컬럼의 내용을 단어(토큰) 단위로 전부 쪼갬

> **❓ 파싱**  
> 문장이나 데이터를 의미 있는 구조로 분석하는 과정

> **❓ 토큰화**  
> 파싱 과정에서 문장을 단어(토큰) 단위로 쪼개는 과정

**(2) 불용어(Stop words) 처리**

\- 검색에서 큰 의미가 없는 단어 제거

\- 변별력을 주지 못하는 것들을 미리 제거

\- 은, 는, 이, 가

\- MySQL 내장된 불용어 목록 존재 -> 커스터마이징 가능

\- 토큰화 과정에서 영어, 한국어 차이

-   한국어는 조사가 단어에 붙음 (ngram parser 사용)

> **❓ ngram 파서**  
> \- 글자 단위로 일정 길이씩 잘라서 인덱싱  
> \- 형태소 분석이 어려운 한국어, 일본어 등에서 효과적  
> \- 띄어쓰기나 오타 있어도 검색 잘 작동  
> \- 검색 결과 정확도 떨어짐

**(3) Inverted Index 구축**

\- 처리된 단어들을 기준으로 어떤 단어가 어떤 문서의 어떤 위치에 있는지 정보를 표로 만듦

\- 특정 키워드에 대해서 어느 페이지에 있는지

\- 단어를 기준으로, 그 단어가 포함된 문서들의 위치나 ID를 기록해 두는 구조  
\- 전문 검색(Full-Text Search)에서 특정 단어가 들어 있는 문서를 빠르게 찾기 위해 사용 

#### **4\. 형식**

**(1) 기본 검색**

\- 일반적인 자연어 검색 방식

\- 검색어와 문서의 연관도를 계산해 결과 정렬

**(2) 정밀 검색**

\- +,-,\* 연산자를 사용해 검색조건 세밀하게 제어할 수 있는 방식

\- 검색의 정확도에 따라 결과가 정렬되지 않음

\- 구문 검색 가능

#### **5\. Like 검색의 문제**

LIKE '%검색어%', LIKE '%검색어'

\- 검색어가 어디에 위치할지 모르기 때문에 데이터베이스 인덱스 포기하고 모든 데이터를 하나씩 비교함

#### **6\. Full Text Index 한계**

**(1) 정교한 언어 처리의 부재**

\- ngram은 형태소 분석에 비하면 단순함

\- 고급 언어 처리 약함

**(2) 동의어 설정 불가능**

**(3) 복잡한 랭킹 모델의 한계**

\- 관련도 점수를 튜닝하거나 특정 필드에 가중치 부여하는 것이 불가능

**(4) 확장성**

\- 검색 트래픽이 높아지면 DB 자체에 부하가 오고 검색 기능 때문에 데이터베이스 전체가 느려짐

👉🏻 검색 엔진 사용

#### **7\. SQL EXPLAIN을 통한 스캔 타입 및 비용 분석**

**(1) Index Scan**

\- 데이터베이스가 인덱스를 활용하여 데이터를 찾는 방식

-   **Range Scan**
    -   특정 범위의 값들을 검색할 때 사용
-   **Full Index Scan**
    -   인덱스 전체 스캔
-   **Unique Index Scan**
    -   중복 없는 유니크 키를 사용하여 데이터 찾음
-   **Skip Scan**
    -   특정 조건을 건너뛰며 인덱스 검색

**(2) Full Table Scan**

\- 데이터베이스가 인덱스를 사용하지 않고 테이블의 모든 데이터를 처음부터 끝까지 읽는 방식

\- 데이터의 양이 많을 경우 비용이 높고 느릴 수 있음

#### **8\. 쿼리 최적화 전략**

**(1) 인덱스 사용**

\- 쿼리 속도를 빠르게 하는 첫 번째 전략

**(2) 집계 테이블 사용**

\- 더 적은 데이터를 파싱할 수 있도록 미리 데이터를 집계해놓은 테이블 사용 가능

**(3) 수직 분할**

\- 테이블을 칼럼별로 분할하여 쿼리가 처리해야 하는 데이터 양을 줄일 수 있음

**(4) 수평 분할**

\- 데이터 값을 기준으로 테이블 분할

\- 보통 시간 값을 기준으로 사용

**(5) 비정규화**

\- 여러 테이블을 하나로 합쳐 쿼리 실행 시 필요한 테이블 조인 수 줄일 수 있음

**(6) 서버 튜닝**

\- 서버의 파라미터를 조정하여 하드웨어 자원을 최대한 활용하도록 설정함으로써 쿼리 실행 속도 높임

---

### **3️⃣ Transaction**

#### **1\. 정의**

\- 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위

\- 사용자와 DB가 상호작용하는 최소 단위

#### **2\. 상태**

**(1) Active**

\- 트랜잭션 활동 상태

\- 트랜 잭션이 실행 중이며, 데이터베이스 내에서 활발하게 작업이 이루어지고 있음

\- 데이터베이스 명령을 받고 그 명령을 수행하는 중

**(2) Partially Committed**

\- 트랜잭션의 Commit 명령이 도착한 상태

\- 트랜잭션의 모든 명령이 성공적으로 실행되었고, COMMIT 명령만 남은 상태

\- 모든 SQL 명령이 성공적으로 완료되었지만, 아직 데이터베이스에 영구적으로 기록되기 전

**(3) Aborted**

\- 트랜잭션 취소 상태

\- 트랜잭션이 취소되었고, 트랜잭션 실행 이전의 데이터로 돌아간 상태

\- 오류나 다른이유로 ROLLBACK 명령 실행

**(4) Faild**

\- 트랜잭션 실패 상태

\- 트랜잭션이 정상적으로 진행될 수 없는 상태로, 오류나 예외 상황이 발생하여 더 이상 진행 불가능

**(5) Committed**

\- 트랜잭션 완료 상태

\- 트랜잭션이 성공적으로 완료되었으며, 모든 변경 사항이 데이터베이스에 영구적으로 반영된 상태

> **💡 트랜잭션은 필요한 최소 범위에서 사용하는 것이 가장 좋음**  
> \- 트랜잭션은 실행되는 동안 데이터에 락(lock)을 걸어서 다른 트랜잭션이 그 데이터를 읽거나 수정하지 못하게 막음  
> \- 데이터 베이스 연결수는 제한되어 있기에, 트랜잭션을 오래 유지하면 사용 가능한 커넥션 수가 줄어듦  
> \- 프로그램이 필요한 커넥션을 기다려야 하는 상황이 올 수도 있다  
>   
> 데이터 베이스는 여러 사용자의 요청을 처리하기 위해 커넥션 풀을 만들어두고 사용함  
> 👉🏻 트랜잭션이 시작되면 트랜잭션이 커밋되거나 롤백 될때까지 커넥션 하나를 점유  
> 👉🏻 트랜잭션안에서 불필요하게 느린작업이 포함되어 있으면 트랜잭션이 커넥션 하나를 물고 놓아주지 않음  
> 👉🏻다른 필요한 요청들이 커넥션을 얻지 못해 처리 못하는 상황 발생  
>   
> 트랜잭션은 필요한 최소 범위로 짧게 유지해야 성능 저하와 충돌을 줄일 수 있음

#### **3\. 사용 이유**

\- 데이터베이스의 무결성과 일관성을 보장하고, 여러 작업을 하나의 논리적인 작업 단위로 묶어서 처리하기 위함

#### **4\. ACID** 

**(1) 원자성 (Atomicity)**

\- All or Nothing

\- 트랜잭션이 완벽하게 수행되거나 전혀 수행이 되지 않아야 함

**(2) 일관성 (Consistency)**

\- 트랜잭션의 작업 처리 결과는 항상 일관성과 정합성이 보장되어야 함

👉🏻 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태를 유지해야 함

\- 트랜잭션이 끝난 뒤에도 데이터는 항상 규칙(제약조건)을 만족해야 함

\- 항상 데이터베이스를 유효한 상태에서 유효한 상태로 전이해야 함

> **❓ 데이터 정합성**  
> 데이터가 논리적으로 일관되고 오류 없이 유지되는 상태

**(3) 독립성, 격리성 (Isolation)**

\- 여러 트랜잭션이 동시에 실행될 때 각 트랜잭션은 다른 트랜잭션의 작업에 영향을 받아서는 안된다

\- 격리성이 보장되지 않으면 동시성 문제 발생함

\- 격리 수준(Isolation Lavel)을 통해 독립의 정도를 정의 가능

**(4) 지속성 (Durability)**

\- 한 번 성공(커밋)한 결과는 영원하다

\- 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 함

\- 지속성을 유지하기 위한 변경 내용을 로그로 기록함 (White-Ahead Log)

#### **5\. Isolation Lavel (격리 수준)**

\- 격리 수준이 올라가면 성능 저하를 유발

\- 격리 수준이 낮으면 낮을수록 동시성은 높아짐(성능 향상) -> 데이터 부정합 문제 발생

\- 격리 수준이 높으면 높을수록 정합성은 완벽해지지만 동시성 낮아짐 (성능 저하)

\- 4가지 격리 수준을 정의하고 개발자가 선택

**(1) Read Uncommitted (Level 0)**

\- 가장 낮은 격리 수준

\- 한 트랜잭션이 커밋되거나 롤백되기 전에도 그 결과가 다른 트랜잭션에서 조회 가능

\- 데이터에 Shared Lock이 걸리지 않으므로, 다른 트랜잭션이 아직 확정되지 않은 데이터를 읽을 수 있음

\- 문제: Dirty Read

> **❓ Dirty Read**  
> \- 다른 트랜잭션이 커밋되지 않은 데이터를 읽는 현상  
> \- 트랜잭션이 나중에 롤백되면 문제되는 더러운 데이터를 읽고 작업 처리

**(2) Read committed (Level 1)**

\- 한 트랜잭션의 변경이 커밋된 후에만 다른 트랜잭션에서 그 결과 확인 가능

\- RDBMS의 기본값

\- 기존 정합성 보장하면서 적절한 수준의 동시성 제공

\- 문제: Non-Repeatable Read

> **❓ Non-Repeatable Read**  
> \- 동일 트랜잭션 내에서 동일 데이터를 다시 읽을 때 값이 달라지는 현상  
> \- 데이터의 일관된 조회 불가능 

**(3) Repeatable Read (Level 2)**

\- 트랜잭션이 시작된 시점에 커밋된 데이터만 조회 가능

\- Non-Repeatable Read 발생하지 않음

\- 하나의 트랜잭션 안에서 한 번 조회된 데이터는 트랜잭션이 끝날 때까지 동일한 값 보장

\- 트랜잭션이 완료될 떄까지 모든 조회 데이터에 Read Lock이 유지되므로, 트랜잭션 범위 내에서 조회한 데이터는 항상 동일함

\- MySQL(InnoDB)의 기본 값

\- 하나의 트랜잭션 안에서 일관성이 매우 중요할 때 사용 (여러 단계에 걸쳐서 데이터를 조회하고 계산하는 작업)

\- 문제: Phantom Read

> **❓ Phantom Read**  
> \- 동일 트랜잭션 내에서 동일 조건으로 범위 조회 시 결과 집합이 달라지는 현상

  
**(4) Serializable (Level 3)**

\- 가장 높은 격리 수준

\- 트랜잭션을 순서대로 실행하는 것과 같은 결과물 보장

\- 정합성이 매우 중요할 때 사용

\- 성능 저하 큼
