## **🧠 회고**

오늘 배운 내용도 만만치 않게 어려웠는데... 다들 잘하는데 나만 뒤쳐지는 것 같다 (흑흑) 다들 강의 들으면서 스펀지처럼 쏙하고 이해하시는데 나만 겨우 이해하고...(그마저도 질문받으면 머리가 새하얘짐) 너무 슬프고 기초도 없고 내일 커리어 멘토링, 기술 멘토링 진행하는데 모의 면접이 너무 떨리고 힘들 것 같다... 일단 나는 말을 조리있게도 잘 못하는데 (흑흑흑) 그래도 해야겠지... 아자아자 파이팅 진짜 파이팅

## **🪽 오늘의 다짐**

1\. 최대한 워크스페이스에서 모든 것을 끝내기

2\. 말을 조리있게 하는 법 연습하기

---

## **📝 Today I Learned**

### **1️⃣ NoSQL**

#### **1\. 정의**

\- Not only SQL

\- SQL 만을 사용하지 않는 여러 유형의 데이터베이스

\- 대용량의 데이터를 효과적으로 관리하기 위해 설계되었으며, 다양한 형태의 데이터를 유연하게 처리할 수 있음

\- 테이블 구조에서 벗어나 유연한 데이터 구조를 가짐

👉🏻 유연한 구조가 필요한 이유: 다양한 데이터를 다루기 위함

\- 비정형 데이터 or 반정형 데이터를 다루는데 강력함

#### **2\. 알아야하는 이유**

**(1) 데이터의 다양성**

\- 구조적 데이터, 반구조적 데이터(JSON, XML), 비구조적 데이터(이미지, 동영상)를 유연하게 처리 가능

\- 고정된 스키마 없이 데이터 구조 변경에 유연해 다양한 애플리케이션 요구에 대응 가능

**(2) 대규모 데이터 처리**

\- 분산 저장을 통해 병렬 데이터 처리 가능

\- 읽기/쓰기 작업 속도가 빠름

\- 대규모 실시간 데이터 처리 용이 (절대적으로 많은 양의 데이터를 위함)

**(3) 수평적 확장성**

\- 저렴한 하드웨어를 활용해 서버를 추가하여 성능 및 용량 확장 가능

\- 클라우드 환경에서 실시간으로 자원 확장 가능

\- 기존 RDBMS의 수직 확장 대비 비용 효율성 높음

> **❓ 수직 확장**  
> \- 서버 사양 올리기  
> \- 비용이 기하급수적으로 늘어남  
> \- 하드웨어 한계에 부딪힘

> **❓ 수평 확장**  
> \- 기존 서버와 비슷한 사양의 서버를 여러대 추가해서 처리  
> \- 클라우드 환경에서는 이 과정이 훨씬 더 쉽고 저렴

**(4) 유연한 설계 및 개발 속도**

\- 초기 설계 단계에서 데이터 모델을 간단히 설정 가능

\- 변경 사항에 빠르게 적응 가능

\- 다양한 데이터 모델(키-값, 도큐먼트, 그래프, 칼럼 기반)을 지원해 특정 비즈니스 요구에 맞는 데이터베이스 선택 가능

#### **3\. 동작 방식**

\- 데이터 구조에 따라 키-값, 문서, 컬럼 기반, 그래프 등으로 구분

\- 각 구조에 맞게 데이터 저장, 조회, 분산 처리

**(1) 키-값 저장소**

\- 각 키에 하나의 값이 매핑되는 가장 단순한 형태의 데이터 저장 방식

\- 가장 단순함

\- key-value 구조로 데이터를 저장하고 관리

👉🏻 자바의 해시맵, 파이썬의 딕셔너리와 비슷

\- 내부 동작

👉🏻 해시함수를 이용해서 키를 특정 위치에 매핑

👉🏻 어떤 키를 주더라도 데이터를 찾는 속도가 O(1)

👉🏻 데이터 양에 상관 없이 거의 일정하게 빠름

\- 압도적인 속도

\- 사용 사례

👉🏻 캐시 서버에 주로 사용됨

👉🏻 세션을 저장하고 관리하는 용도

\- Redis

**(2) 문서 지향 데이터베이스**

\- JSON, XML과 같은 문서 형식을 사용하여 데이터 저장

\- 키값 저장소에서 한 단계 발전한 모델

👉🏻 값 부분이 훨씬 더 복잡하고 구조적인 문서를 다룸 (JSON, XML)

\- 각 문서가 고유한 키를 가짐

\- 데이터를 하나의 문서에 함께 저장하고 관리하면, JOIN 없이 한번의 읽기 작업으로 모두 가져올 수 있다

\- MongoDB

\- 실무 사례

👉🏻 SNS, 뉴스기사, 콘텐츠 관리, 상품 카탈로그 => 객체 중심으로 묶이는 데이터

**(3) 컬럼 기반 데이터베이스**

\- 컬럼 단위로 데이터를 저장하고 관리하여, 대량의 데이터를 빠르게 조회하고 분석 가능

\- RDBMS는 행단위로 저장한다면 컬럼기반 데이터베이스는 열 단위로 저장

> **❓ row 기반 저장**  
> \- \[1, ‘김사이다’, ‘20’, ‘서울\], \[2, ‘김감튀’, ‘30’, ‘서울\], \[3, ‘김콜라’, ‘40’, ‘서울\]  
> \- 평균 나이를 계산해줘 → 모든 행을 다 읽어야함

> **❓ 컬럼 기반 저장**  
> \- 나이에 대한 데이터만 읽으면 됨  
> \- 다른 컬럼 데이터 읽을필요 없음  
> \- 하지만 김사이다에 대한 정보를 보여줘  
> 👉🏻 행단위 조회에는 취약 (다시 행으로 조립해야하기 때문)

\- 데이터 분석, 빅데이터 처리, 로그 저장 처리, 대규모 집계 작업에 사용

**(4) 그래프 데이터베이스**

\- 데이터를 노드와 엣지로 표현하여, 객체 간의 관계를 중심으로 데이터를 저장하고 조회함

\- 데이터간 관계에 초점을 맞춤

\- RDB에서도 FK로 관계를 표현할 수 있지만 JOIN을 여러번 해야해서 복잡한 관계를 나타내야 할 때 비효율적

👉🏻 그래프 DB는 각 노드가 자신의 이웃 노드에 대한 직접적인 포인터(주소)를 갖고 있음

\- 실무 사례

👉🏻 SNS 친구 추천, 공통 관심사 찾기, 상품 추천

#### **4\. 유형별 동작 방식**

**(1) 키-값 저장소**

\- 쓰기: 키를 해싱하여 데이터 저장 위치 결정

\- 읽기: 키를 입력받아 데이터를 검색

\- 샤딩: 해시 함수를 사용해 데이터를 여러 노드에 분산 저장

>  **❓ 샤딩**  
> 데이터를 여러 DB에 분산 저장해 성능과 확장성을 높이는 기술

**(2) 문서 저장소**

\- 쓰기: 고유 ID로 문서를 저장

\- 읽기: ID 또는 특정 조건(필드 값)을 기준으로 문서 검색

\- 인덱스: 특정 필드에 대해 인덱스를 생성하여 조회 속도 최적화

**(3) 컬럼 기반 저장소**

\- 쓰기: RowKey와 Column 기준으로 데이터 저장

\- 읽기: 특정 RowKey또는 컬럼 기반으로 데이터 검색

\- 샤딩: RowKey를 기준으로 데이터 분산

**(4) 그래프 데이터베이스**

\- 쓰기: 데이터는 노드와 엣지로 저장

\- 읽기: 노드와 관계를 탐색

\- 인덱스: 노드 및 엣지에 대한 인덱스를 생성하여 탐색 속도 향상

#### **5\. 정리**

**(1) 키-값 저장소**

| 개념 | 키를 사용해 데이터를 검색하며, 값은 비정형일 수 있음 |
| --- | --- |
| 장점 | \- 빠른 읽기/쓰기 속도   \- 간단한 데이터 구조 |
| 단점 | \- 복잡한 데이터 관계 처리 어려움 |
| 사용 사례 | \- 캐시 저장   \- 세션 관리   \- Redis |

**(2) 문서 저장소**

| 개념 | \- 데이터를 JSON, XML 같은 문서 형식으로 저장하며, 각 문서는 고유한 ID를 가짐 |
| --- | --- |
| 장점 | \- 유연한 스키마와 복잡한 데이터 모델링 가능 |
| 단점 | \- 데이터 간 관계성 약함 |
| 사용 사례 | \- 전자상거래 플랫폼, 소셜 미디어   \- MongoDB |

**(3) 컬럼 기반 저장소**

| 개념 | \- 데이터를 행과 열 기반으로 저장하며, 대규모 데이터 처리와 분석에 특화됨 |
| --- | --- |
| 장점 | \- 대규모 데이터 분석과 빠른 처리 가능   \- 확장성 뛰어남 |
| 단점 | \- 단순 조회의 성능 저하 |
| 사용 사례 | \- 로그 데이터 관리, IoT 데이터 분석 |

**(4) 그래프 데이터베이스**

| 개념 | \- 데이터를 노드와 엣지로 저장하며, 데이터 간 관계를 기반으로 탐색 및 분석 수행 |
| --- | --- |
| 장점 | \- 복잡한 데이터 관계를 효율적으로 탐색 가능 |
| 단점 | \- 대규모 데이터를 처리할 때 성능이 저하될 수 있음 |
| 사용 사례 | \- 소셜 네트워크, 추천 시스템 |

#### **6\. Eventual Consistency**

\- 지금 당장은 데이터가 일치하지 않을 수 있지만 결국에는(Eventually) 모든 노드의 데이터가 일관된 상태에 도달할 것이라는 약속

\- 유튜브 조회수

\- 하지만 상품재고같은 경우는 강력한 일관성이 필요함

---

### **2️⃣ 데이터베이스의 확장**

#### **\+ 수직 확장 (스케일업)**

\- 서버 사양 올리기

\- 비용이 기하급수적으로 늘어남

\- 물리적인 하드웨어 한계에 부딪힌다

\- 서버가 한대여서 이 서버에서 장애가 발생하면 서비스 전체가 멈춘다

#### **\+ 수평 확장 (스케일 아웃)**

\- 기존 서버와 비슷한 사양의 서버를 여러대 추가해서 처리

\- 클라우드 환경에서는 이 과정이 훨씬 더 쉽고 저렴해서 거의 수평 확장을 함

\- 초기 설정은 복잡할 수 있지만, 필요할 때마다 서버를 추가할 수 있어서 이론상 거의 무한에 가깝게 확장 가능

\- 여러 서버 중 한 두대 문제 생겨도 다른 서버들이 그 역할을 대신할 수 있음

👉🏻 고가용성 확보 가능

> **❓ 고가용성**  
> 시스템이 장애나 오류가 발생해도 지속적으로 서비스가 가능한 상태를 유지하는 것

\- 데이터베이스의 확장은 스케일 아웃이라는 개념을 DB에 적용하는 것

👉🏻 데이터를 여러 DB에 분산 저장하고 처리하는 구조

#### **1\. 정의**

\- 대규모 데이터베이스 시스템에서 처리 가능한 데이터양과 요청 처리 속도를 높이기 위해 데이터베이스를 물리적 또는 논리적으로 분산시키는 기술

\- 샤딩, 파티셔닝(수직 파티셔닝, 수평 파티셔닝), 복제

#### **2\. 알아야하는 이유**

\- 대규모 데이터베이스 시스템에서 처리 가능한 데이터양과 요청 처리 속도를 높이기 위함

#### **3\. 파티셔닝**

\- 하나의 거대하고 무거운 데이터를 여러 조각으로 쪼개서 나누어 담는 방식

\- 각 조각은 전체 데이터의 일부만을 가진다

\- 쓰기 성능과 데이터 관리 효율성을 높이는데 중점을 둔다

| **수직 파티셔닝** | \- 테이블을 열 기준으로 분리하여 자주 접근하는 데이터와 그렇지 않은 데이터를 나눔 |
| --- | --- |
| **수평 파티셔닝 (샤딩)** | \- 행 단위로 분리하여 처리 부하를 줄이는 방식   \- 각 샤드는 독립적인 데이터베이스 엔티티로서, 다른 샤드와 물리적으로 분리되어 있음      (1) 범위 기반 샤딩   \- 특정 기준에 따라 데이터를 분할함      (2) 해시 기반 샤딩   \- 해시 함수를 사용하여 데이터를 일정한 방식으로 샤드에 분배함      (3) 복합 샤딩   \- 범위 기반과 해시 기반 샤딩을 혼합하여 사용 |

> **❓ 샤드**  
> 샤딩으로 나눈 각각의 데이터베이스 조각

> **❓ 해시**  
> 임의의 데이터를 고정된 길이의 값으로 바꾸는 것(함수)

> **❓ 샤딩**  
> 하나의 거대하고 무거운 데이터(데이터베이스)를 여러 조각(Shard)으로 쪼개어 여러 서버에 분산 저장

#### **4\. 복제**

**(1) 정의**

\- 데이터를 통째로 복사해서 여러개의 똑같은 복사본을 만드는 방식

\- 모든 복사본은 동일한 전체 데이터를 가짐

\- 고가용성 확보

\- 대부분의 웹서비스는 읽기 작업이 압도적으로 많음

👉🏻 읽기 부하를 분산하며 장애 복구 대비

\- 복제된 데이터는 읽기/쓰기 작업을 나누거나 다중 노드에서 데이터 접근을 가능하게 함

**(2) 동작 방식**

**\- Master (주 노드)**

-   데이터를 쓰는 작업을 처리
-   변경 사항이 로그 파일로 기록됨

**\- Slave (복제 노드)**

-   Master의 Binary Log를 읽어 데이터를 동기화함
-   주로 읽기 작업 처리
-   데이터를 실시간으로 복제받음

\- 동기화 이전에 빠르게 유저에게 데이터 보여야 하는 경우 Master에서도 읽기 작업 일정 부분 수행하기도 함

> 전통적인 RDBMS는 분산 환경을 염두에 두지 않아 샤딩을 애플리케이션 레벨에서 직접 구현해야 했지만,  
> NoSQL은 처음부터 분산을 고려해 설계되어 DB 자체적으로 수평 확장과 데이터 분산을 쉽게 지원한다.  
> 대신 NoSQL은 확장성과 유연성을 얻는 대신 강한 일관성과 트랜잭션 보장을 일부 포기한다.
