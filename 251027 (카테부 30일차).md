
## **🧠 회고**

오늘은 감기 몸살 때문에 카테부 출석을 못했지만... 그래도 교재보고 복습하려고 한다.

건강관리를 잘하자

## **🪽 오늘의 다짐**

1\. 건강관리 잘하기

2\. 밀린 내용 복습 다 하기

---

## **📝 Today I Learned**

### **1️⃣ 데이터베이스 동시성 제어**

#### **1\. 정의**

\- 여러 사용자가 동시에 데이터베이스에 접근할 때 생길 수 있는 문제를 방지하고, 데이터의 일관성과 무결성을 유지하기 위한 기술

#### **2\. 알아야하는 이유**

\- 데이터의 일관성과 무결성 유지

\- 동시에 여러 사용자가 데이터에 접근하더라도 신뢰성 보장

> **❓ 일관성**  
> 데이터베이스가 트랜잭션 전후에도 항상 정의된 규칙을 만족하는 상태를 유지하는 것

> **❓ 무결성**  
> 데이터가 정확하고 신뢰할 수 있는 상태를 유지하는 것

#### **3\. 동작 방식**

Locking 매커니즘

\- 데이터를 안전하게 관리하고 다중 사용자가 동시에 데이터에 접근할 때 발생할 수 있는 충돌을 방지하기 위한 기술

**(1) 비관적 락**

\- 충돌이 일어날 가능성을 가정하고, 데이터를 사용하기 전에 락을 걸어 다른 사용자의 접근을 제한하는 방식

\- RDBMS에서 사용됨

\- 데이터의 정확성과 일관성을 유지하기 위한 강력한 도구 

| 장점 | 단점 |
| --- | --- |
| 높은 데이터 무결성 보장 | 동시성이 저하되고 데드락 발생 가능성 |
| 작업 수행 전에 락을 설정해 충돌 방지 | 트랜잭션 대기 시간 길어질 수 있음 |
| 데이터 손상 위험 크게 줄임 | 자원 사용의 효율성 떨어질 수 있음 |
| 충돌 예방을 위한 사전 조치로 신뢰성 제공 | 자원의 과도한 락으로 병목 현상 발생 가능 |

\- 락 설정 방식

-   선락체크 + 후사
    -   데이터를 읽기 전에 락을 설정하고 작업이 완료된 후 락을 해제함
-   읽기와 쓰기 작업 중 쓰기 작업이 많은 경우
    -   충돌 가능성이 높을 때 비관적 락 사용
-   자원 우선 관리
    -   중요 데이터에 우선적으로 락을 설정하여 데이터 손상 방지

\- 락의 유형

| Shared Lock(공유 락, S-Lock) | \- 여러 트랜잭션이 동시에 읽도록 허용   \- 쓰기 작업은 불가능 |
| --- | --- |
| Exclusive Lock(독점 락, X-Lock) | \- 모든 형태의 락을 차단   \- 해당 자원에 대한 독점적 접근 보장 |
| Intent Lock (의도 락) | \- 트랜잭션이 특정 자원을 사용할 의도가 있음을 명시적으로 나타냄 |
| Update Lock (업데이트 락) | \- 읽기와 쓰기 작업 간 충돌의 방지   \- 업데이트 작업을 위한 사전 예약 |

\- 교착 상태(데드락) 발생 상황

-   다수의 트랜잭션이 서로 다른 자원을 순서대로 요청하며 서로를 기다릴 때 발생
-   자원을 사용하기 위한 스레드가 충분하지 않을 때 발생
-   락이 해제되지 않아 자원 회수가 지연될 경우
-   순환 대기 조건이 성립할 때

> **❓ 데드락**  
> \- 두 개 이상의 트랜잭션이 테이블 또는 행의 락을 얻은 뒤,  
> 다른 트랜잭션이 소유하고 있는 락을 요구해 상황이 바뀌지 않는 상태

> **❓ 데드락 방지하는 법**  
> \- 트랜잭션을 자주 COMMIT  
> \- 정해진 순서로 테이블에 접근  
> \- 읽기 잠금 획득의 사용 지양

\- 동시성 제어 방식

| Lock-based Concurrency Control | 트랜잭션들이 데이터베이스 자원을 안전하게 접근하도록 락을 관리하는 방법 |
| --- | --- |
| 2PL (Two Phase Locking) | 모든 트랜잭션이 락을 획득하는 단계와 해제하는 단계를 구분하여 일관성과 격리 수준 보장 |
| Strict 2PL | 트랜잭션이 완료될 때 까지 모든 락을 유지 |
| Deadlock Detection | 데드락 발생 시 이를 탐지하고 해소하기 위한 메커니즘 |

**(2) 낙관적 락**

\- 충돌이 일어나지 않을 것으로 가정하고, 데이터를 먼저 사용한 뒤 최종적으로 업데이트 시 충돌 검사

\- 비관계형 데이터베이스에서 사용

\- 소프트웨어적 Lock

\- 높은 성능과 유연성 제공

\- 추가적인 관리 로직 필요

| 장점 | 단점 |
| --- | --- |
| 높은 동시성 제공 | 데이터 무결성 보장 수준이 낮아짐 |
| 시스템 성능 향상 | 충돌 발생 시 복잡한 예외 처리 로직 필요 |
| 분산 시스템에서 적합 | 버전 관리와 추가 구현 비용 요구 |
| 데이터 읽기 속도가 빨라짐 | 충돌 발생 시 재시도 비용 증가 |

\- 동작 방식

-   데이터 작업 수행(선사)
    -   데이터를 변경한 후 작업 완료
-   최신 버전 확인 (후버전체크)
    -   데이터를 업데이트하기 전에 데이터의 버전을 확인하여 충돌 여부 검사
    -   충돌이 발견되면 OptimisticLockException이 발생하며 작업 롤백

\- 동시성 제어 방식

| Timestamp-based Concurrency Control | 트랜잭션마다 타임스탬프를 부여하여 최신 데이터를 판별하고 충돌 관리 |
| --- | --- |
| Multiversion Concurrency Control (MVCC) | 데이터의 여러 버전을 관리하여 트랜잭션 간 충돌 방지 |

**(3) 요약**

\- 비관적 락: 선락체크 후사용

\- 낙관적 락: 선사용 후버전체크

비관적 락은 충돌을 미리 방지하려는 관점에서,

낙관적 락은 충돌을 예방하기보다는 충돌 발생 후 처리하는데 초점을 맞츰

#### **4\. MVCC**

\- 데이터를 수정할 때 기존 데이터를 덮어쓰는 대신 새로운 버전의 데이터를 만듦

1\. 트랜잭션이 시작되면 고유한 트랜잭션 id를 부여받고 그 시점에 데이터베이스 스냅샷을 기준으로 동작

2\. 어떤 트랜잭션이 데이터를 업데이트하면 원본 데이터는 그대로 두고 변경된 내용으로 새로운 버전의 데이터를 만듦. 원본 데이터는 별도의 공간에 저장(undo log)됨

3\. 다른 트랜잭션이 데이터를 조회하면 현재 진행중인 변경사항이 아니라 트랜잭션이 시작되기 전에 커밋된 마지막 버전의 데이터를 별도의 공간(undo Log)에서 가져와서 보여줌

---

### **2️⃣  ORM (Object Relation Map)**

#### **1\. 정의** 

\- 자바의 객체와 데이터베이스의 테이블을 자동으로 연결하고 변환해, 객체 지향 코드로 데이터를 조작할 수 있게 해주는 기술

\- 개발자는 SQL을 직접 작성하지 않고도, 객체 지향 코드 그대로 데이터베이스 조작

\- 객체는 객체대로 클래스와 필드 중심으로 설계, 데이터베이스는 데이터베이스대로 테이블과 컬럼 중심으로 설계하되, ORM이 중간에서 두 가지를 매끄럽게 연결

#### **2\. 사용 이유**

\- 객체지향과 관계형 데이터베이스 간의 간극을 줄여, 설계의 일관성과 코드의 생산성을 높이기 위함

\- 객체와 관계형 DB 사이의 패러다임 불일치 해결

\- 개발자는 객체 모델링에 집중 가능

\- 데이터베이스 연동은 ORM이 처리

\- 반복되는 SQL 작성 부담이 줄어들고, 설계의 일관성을 지키면서도 생산성과 유지보수성 크게 향상

#### **3\. 사용 방법**

\- JPA와 같은 ORM 표준 구현체를 사용해 객체와 테이블 매핑을 설정하고 데이터 베이스를 조작

**(1) JPA**

\- Java Persistence API

\- ORM 표준을 정의한 인터페이스 집합

\- Hibernate 같은 구현체를 통해 실제로 동작

\- 개발자는 객체와 테이블을 매핑하는 설정을 작성하고, 나머지 SQL 생성, 실행, 결과 매핑 작업은 ORM 프레임워크가 자동으로 처리함

---

### **3️⃣ JPA**

#### **1\. 정의**

\- 자바 객체와 관계형 데이터베이스를 매핑하고, 객체 단위로 데이터를 저장하고 조회할 수 있게 해주는 표준 ORM 인터페이스

\- JPA는 인터페이스의 모음, 즉 표준 명세이기에 스스로 동작하지 않음

-   실제로 동작하려면 이를 구현한 ORM 프레임워크가 필요함
-   대표적인 구현체

| **Hibernate** | \- JPA 표준 명제의 대표적인 구현체   \- 풍부한 기능과 활발한 커뮤니티를 갖춘 ORM 프레임워크   \- JPA vywns wkcprk Hibernate를 기반으로 만들어져 호환성과 안정성 높음 | \- 가장 널리 사용   \- 시장 점유율 압도적 |
| --- | --- | --- |
| EclipseLink | \- Eclipse 재단에서 개발한 JPA 표준 구현체   \- 과거 Oracle TopLink를 기반으로 함   \- 상용 환경 지원과 다양한 데이터베이스 연동 기능 제공 | \- 낮음   \- 특정 기업 환경에서 사용 |
| DataNucleus | \- JPA뿐만 아니라 JDO 표준도 지원하는 범용 데이터 엑세스 프레임워크   \- 관계형 DB뿐 아니라 NoSQL, 파일 기반 저장소 등 다양한 데이터 소스 지원 | \- 낮음   \- 특수한 요구사항에서 선택 |

\- 대부분의 프로젝트에서는 Hibernate 사용

#### **2\. 사용 이유**

\- 자바 진영에서 공식적으로 체택한 ORM 표준 명세로, 안정성과 실용성을 동시에 갖추고 있기 때문

\- 복잡한 데이터 접근 기능을 단순한 메서드 호출만으로 구현 가능

#### **3\. 사용 방법**

\- 엔티티 클래스에 @Entity 선언 후, EntityManager를 통해 객체를 저장, 조회, 수정

---

### **4️⃣ Entity**

#### **1\. 정의**

\- 데이터베이스 테이블과 1:1로 매핑되어 데이터를 객체 형태로 표현하는 자바 클래스

\- JPA에서 클래스가 데이터베이스 테이블과 매핑되려면 @Entity 어노테이션을 선언해야함

\- @Entity 어노테이션이 붙은 클래스는 JPA가 관리하는 엔티티로 인식되며, 영속성 컨텍스트를 통해 데이터베이스와 연결되어 CRUD 작업 수행 가능

#### **2\. 사용 이유**

\- 데이터를 하나의 객체로 묶어 구조와 규칙을 함께 관리하여 코드의 오류를 줄이고, 설계를 일관되게 유지할 수 있기 때문

\- 필드와 함께 해당 데이터가 지켜야 할 제약, 연관 관계, 비즈니스 로직을 한 곳에 모아둘 수 있음

\- 데이터와 관련된 규칙이 코드 전반에 흩어지지 않고, 해당 객체 내부에서만 관리되므로 변경이 발생했을 때 수정 범위가 줄어듦

\- Entity는 데이터베이스의 한 행(row)을 명확하게 표현하므로, 객체 지향적인 설계와 데이터베이스 구조 사이의 연결 고리가 됨

\- JPA를 비롯한 ORM 환경에서는 이 엔티티를 중심으로 매핑, 저장, 조회가 이루어지기에, 설계 단계에서 엔티티를 명확히 정의하면 애플리케이션 전반의 구조가 안정적이고 일관성 있게 유지됨

#### **3\. 사용 방법**

\- 자바 클래스에 @Entity를 선언하고, 각 필드를 칼럼에 매핑하여 JPA가 해당 객체를 데이터베이스 테이블과 연동할 수 있도록 구성

#### **4\. 기본 형식**

```
import jakarta.persistence.*;

@Entity
public class 클래스명 {
	
		// 필드 선언
		// ex) private Long id;
		
		protected 클래스명() {}
}
```

\- jakarta.persistence.\* 패키지를 import하여 JPA에서 제공하는 주요 어노테이션을 사용할 수 있도록 함

\- @Entity는 해당 클래스가 데이터베이스 테이블과 매핑되는 엔티티임을 나타냄

\- 클래스 내부에는 데이터베이스 테이블의 컬럼에 대응하는 필드들을 선언함

---

### **5️⃣ DTO (Data Transfer Object)**

#### **1\. 정의**

\- 계층 간 데이터 전달을 위해 사용하는, 값만 담는 전용 객체

\- 필드와 Getter/Setter, 생성자만을 포함함

\- 비즈니스 로직이나 데이터베이스 접근 기능은 전혀 가지지 않음

\- 로직을 배제하면 데이터 구조가 단순해지고, 전송 대상 데이터의 형태를 명확히 정의할 수 있어 유지보수성과 확장성이 높아짐

#### **2\. 사용 이유**

\- 엔티티의 내부 구조나 민감 정보를 외부에 노출하지 않고, 필요한 데이터만 안전하고 명확하게 전달하기 위함

\- 전달이 필요한 데이터만 선별하여 담음으로써, 외부로 나가는 데이터의 범위를 명확히 제어 가능

\- 데이터 형식고 구조를 상황에 맞게 변환하거나 가공할 수 있어, API 요청/응답 스펙을 유연하게 설계 가능 

\- 계층 간 결합도 낮춤

\- 유지보수성과 확장성 크게 높여줌

#### **3\. 사용 방법**

\- 전달할 필드만 포함된 클래스를 따로 정의하고, 조회 결과를 해당 DTO로 매핑해 데이터를 전달

#### **4\. JSON 순환 참조 오류**

\- JSON 직렬화: 자바 객체를 JSON 문자열로 변환하는 과정

👉🏻 직렬화 대상 객체가 서로를 참조하는 양방향 관계라면 문제가 됨

---

### **6️⃣ @Id**

#### **1\. 정의**

\- 엔티티의 식별자를 지정해주는 기본 키 매핑 어노테이션

\- 기본키는 데이터베이스 테이블에서 각 행을 유일하게 식별하는 값이며, JPA가 엔티티를 영속성 컨텍스트에서 관리하기 위해 반드시 필요

\- 해당 필드를 엔티티의 식별자로 지정하고, 이 값이 없으면 JPA는 해당 엔티티를 저장, 조회, 수정할 수 없음

#### **2\. 기본 키 할당 방식**

**(1) 직접 할당**

\- 개발자가 기본 키 값을 직접 세팅하여 저장하는 방식

\- @Id만 선언하고, 별도의 키 생성 전략을 사용하지 않음

**(2) 자동 생성**

\- JPA가 기본 키를 자동으로 생성하도록 위임하는 방식

\- @GeneratedValue와 함께 전략(strategy)을 지정하면, 데이터베이스나 시퀀스를 활용하여 키 생성

#### **3\. 사용 이유**

\- 엔티티를 고유하게 구분해 JPA가 저장, 수정, 삭제와 같은 데이터 처리를 정확하게 할 수 있도록 하기 위함

\- JPA는 엔티티를 영속성 컨텍스트에서 관리하며, 이때 각 엔티티를 식별하기 위해 기본 키 값이 필요

👉🏻 기본 키가 있어야 동일한 엔티티를 여러 번 조회했을 때 동일한 인스턴스로 인식하고 변경 감지나 1차 캐시 관리, 병합 등의 기능을 정확하게 수행할 수 있음

> **❓ 영속성 컨텍스트**  
> \- JPA가 엔티티를 관리하는 임시 저장소  
> \- 엔티티의 상태 변화를 추적하고 필요할 때 데이터베이스와 동기화함

> **❓ 변경 감지**  
> \- JPA가 관리하는 엔티티의 값이 바뀌었는지 확인하고, 트랜잭션이 끝날 때 자동으로 데이터베이스에 반영하는 기능

> **❓1차 캐시**  
> \- JPA가 관리하는 엔티티를 한 번 저장해 두었다가, 같은 데이터를 다시 요청하면 데이터베이스 대신 저장된 값을 바로 돌려주는 기능

> **❓ 병합**  
> \- JPA가 더 이상 관리하지 않는 엔티티를 다시 불러와, 수정할 수 있는 상태로 되돌리는 기능

#### **4\. 사용 방법**

\- 엔티티 클래스의 기본 키로 사용할 필드 위에 @Id 어노테이션을 선언

#### **5\. 자연키와 대리키**

\- 테이블의 키를 설정하는 과정에서 적용되는 원칙

**(1) 자연키**

\- 비즈니스적으로 의미가 있는 값

\- 회원의 이메일이나 학생의 학번 같은 값을 지정하는 것

**(2) 대리키**

\- 비즈니스와 아무 관련이 없는 시스템이 자동으로 생성해주는 연속된 숫자 값

기본키의 가장 중요한 속성 중 하나는 불변성 

이메일처럼 유일해야하는 값은 unique 제약 조건을 걸어서 관리

---

### **7️⃣ 기본 키 생성 전략**

#### **1\. 정의**

\- 엔티티의 ID 값을 자동으로 만들기 위해 숫자를 직접 넣을지, DB 시퀀스를 사용할지, 자동 증가 컬럼을 쓸지 등을 지정하는 방식

\- 이 선택은 영속성 컨텍스트의 동작과 성능, 그리고 데이터베이스 호환성에 직접적인 영향을 줌

> **❓ 시퀀스**  
> \- 데이터베이스에서 연속적이고 유일한 숫자 값을 생성하는 객체  
> \- 주로 기본 키를 만들 때 사용하며, 1,2,3...처럼 순차적으로 증가함

#### **2\. TABLE 전략**

\- 키 전용 테이블을 두고 시퀀스처럼 동작하는 방식

\- 데이터베이스 종류와 상관없이 적용할 수 있기에 이식성 측면에서는 유리함

\- 키 생성 테이블에 잠금이 발생하고, 조회, 갱신을 위한 추가 I/O가 필요하다는 점에서 성능 저하 발생

\- 실무에서 사용하진 않음

#### **3\. SEQUENCE 전략**

\- 데이터베이스에 존재하는 시퀀스 오브젝트를 이용해 기본 키 값을 생성하는 방식

\- 데이터베이스는 시퀀스라는 독립적인 객체를 제공

👉🏻 이 시퀀스는 명령어를 호출할 때마다 중복되지 않는 유일한 숫자를 순차적으로 반환하는 역할

\- Oracle, PostgreSQL 등 일부 데이터베이스에서 지원

\- INSERT 실행 전 이미 키 값을 확보할 수 있다는 특징

👉🏻 쓰기 지연이나 배치 처리 같은 기능과 잘어울림

\- 성능을 높이기 위해 allocationSize 옵션을 사용하면, 여러 개의 키를 한 번에 미리 가져와 메모리에 저장해 두고 이후에는 데이터베이스와 추가 통신 없이 순차적으로 소모 가능

#### **4\. IDENTIFY 전략**

\- 데이터베이스의 자동 증가 칼럼을 사용하여 기본 키를 생성

\- MySQL의 AUTO\_INCREMENT

\- ID값이 데이터가 데이터베이스 INSERT된 이후에만 결정됨

👉🏻 실제 INSERT 쿼리가 수행이 되어야지만 DB가 새로운 ID를 할당해줌

\- JPA는 영속성 컨텍스트에서 관리하기 위해 반드시 id값이 필요함

👉🏻 그런데 아이덴티파이 전략에서는 persists()를 호출하려는 시점에는 아직 id가 없음

👉🏻 그래서 어쩔 수 없이 persist() 메소드 호출 될 때마다 INSERT SQL를 DB로 보내야 함

👉🏻 쓰기 지연을 못씀

👉🏻 성능상 아쉬운 부분 존재

#### **5\. AUTO 전략**

\- JPA가 데이터베이스 방언을 기준으로 적절한 키 생성 방식을 자동 매핑해 주는 방법

\- 개발자가 별도로 전략을 고민하지 않아도 되고, 데이터베이스를 교체하더라도 엔티티 코드를 그대로 유지할 수 있음

\- 이식성 면에서는 가장 편리한 선택이지만, 성능 최적화가 필요하거나 특정 전략을 강제로 사용해야 하는 경우에는 AUTO 대신 원하는 전략을 명확히 지정하는 편이 안전함

#### **6\. 알아야하는 이유**

\- 기본 키 생성 전략을 잘못 선택하면 운영 중 ID 오류나 성능 이슈가 발생할 수 있기 때문

\- 기본 키는 행을 유일하게 구분하는 기초이자 모든 연관 관계의 기준이므로, 전략 선택이 곧 애플리케이션의 안정성과 수명에 큰 영향을 끼침

\- 전략마다 키가 생성되는 시점이 다르고 이것이 JPA의 동작에 직접 영향을 줌

\- 같은 코드라도 어떤 전략을 쓰느냐에 따라 트랜잭션 내 SQL 패턴과 대역폭 사용량이 크게 달라짐

> **❓ persist()**  
> \- JPA에서 새 엔티티를 영속성 컨텍스트에 저장하고, 이후 데이터베이스에 반영하도록 등록하는 메서드

#### **7\. 사용 방법**

\- @Id와 함께 @GenerateValue(strategy = ...)를 선언하고, IDENTITY, SEQUENCE, AUTO, TABLE 중 원하는 방식을 지정
