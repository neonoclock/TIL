## **🧠 회고**

스프링 부트가 너무 어렵다... 그래도 열심히 해야겠지... 과제 해야하는데 할 수 있을지 모르겠다 ㅠㅠ 뒤쳐진만큼 열심히 해야겠다

## **🪽 오늘의 다짐**

1\. 건강관리 잘하기

2\. 밀린 내용 복습 다 하기

---

## **📝 Today I Learned**

### **1️⃣ 영속성 컨텍스트**

ORM - 기술이고 개념

JPA - ORM이라는 기술과 개념을 명세로 나타낸 것

Hibernate - JPA 구현체

Spring Data JPA - Hibernate, JPA를 추상화해서 사용하기 편하게 만들어준 것

Entity - 우리가 JPA를 사용하기 위한 재료 / 테이블과 1:1로 매핑되는 자바 클래스

@id - 우리가 JPA를 사용하는 과정에서 있는 규칙 / 엔티티가 여러개인데 그 엔티티를 식별하기 위한 것

#### **1\. 정의**

\- JPA가 엔티티 객체를 관리하며, 동일 트랜잭션 내에서 변경 사항을 추적하고 자동으로 데이터베이스와 동기화하는 메모리 상의 저장소

\- 이 저장소는 데이터베이스가 아니라 애플리케이션 내부 메모리에 존재함

\- 트랜잭션이 끝날 때까지 엔티티의 상태를 보관함

\- 트랜잭션이 커밋되는 순간, 영속성 컨텍스트에 기록된 변경 내역이 데이터베이스에 동기화

\- 영속성 컨텍스트는 직접 다루는 대상이 아니고, EntityManager를 통해 접근함

\- EntityManager는 엔티티의 저장, 수정, 삭제, 조회 같은 작업을 담당함 / 내부적으로 영속성 컨텍스트를 생성하고 제어함

\- 영속성 컨텍스트에 포함된 엔티티는 JPA가 상태를 자동 추적하며, 상황에 맞게 데이터베이스와 동기화됨

\- 이 과정에서 1차 캐시, 쓰기 지연, 변경 감지와 같은 기능 동작

| 기능 | 설명 | 동작 시점 | 효과 및 유의사항 |
| --- | --- | --- | --- |
| **1차 캐시** | \- 영속성 컨텍스트 내부에 존재하는 엔티티 저장소   \- PK를 키로 하여 엔티티 인스턴스를 보관함 | \- 엔티티를 조회할 때 먼저 캐시에서 탐색하고, 없을 경우에만 DB를 조사한 뒤 캐시에 저장   \- 동일 트랜잭션 내에서는 같은 엔티티를 재사용 | \- DB 접근 횟수를 줄여 성능 높여줌   \- 트랜잭션 범위를 벗어나면 캐시는 초기화되므로 전역 캐시로 오해하면 안됨 |
| **쓰기 지연** | \- INSERT, UPDATE, DELETE SQL을 즉시 실행하지 않고 내부 큐에 모아둠 | \- 트랜잭션 커밋 직점 플러시 단계에서 모아둔 SQL을 한 번에 실행함 | \- 네트워크 왕복 횟수를 줄여 처리 효율이 높아짐   \- IDENTITY 방식처럼 키를 즉시 확보해야 하는 경우에는 INSERT가 바로 실행될 수 있음 |
| **변경 감지** | \- 로딩 시점의 엔티티 상태를 스냅샷으로 저장해두고, 현재 값과 비교하여 변경 여부 판별 | \- 커밋 시점의 플러시 단계에서 변경된 필드를 찾아 필요한 UPDATE SQL만 생성 | \- 개발자가 직접 update 메서드를 호출하지 않아도 값만 바꾸면 DB에 반영됨   \- 예기치 않은 대량 변경을 막으려면 트랜잭션 범위와 수정 위치 신중히 관리해야 함 |

#### **2\. 엔티티 생명 주기**

**(1) 비영속**

\- 영속성 컨텍스트와 전혀 관계가 없는 상태

\- new로 객체를 생성했지만 EntityManager를 통해 관리되지 않는 경우

**(2) 영속**

\- 엔티티가 영속성 컨텍스트에 등록되어 관리되는 상태

\- em.persist(entity)를 호출하면 이 상태가 되며, 트랜잭션 커밋 시 데이터베이스와 동기화 됨

**(3) 준영속**

\- 한 번 영속이었던 엔티티가 영속성 컨텍스트에서 분리된 상태

\- em.detach(entity) 또는 em.clear()를 호출하거나 em.close()로 EntityManager를 종료하면 해당 상태가 됨

**(4) 삭제**

\- 엔티티가 영속성 컨텍스트에서 삭제된 상태

\- em.remove(entity) 호출 시 이 상태가 됨

\- 트랜잭션 커밋 시 데이터베이스에서도 삭제됨

#### **3\. 알아야 하는 이유**

\- JPA가 언제 데이터를 저장, 변경, 조회하는지 정확히 이해하고, 예측 가능한 데이터 처리와 오류 없는 트랜잭션 관리를 하기 위함

\- SQL 실행 시점을 예측할 수 있어야 함

-   쿼리가 언제 모이고 언제 실행되는지를 알아야 효율적으로 코드 작성하고 문제 확인 후 튜닝 가능

\- 엔티티의 상태 변화를 명확하게 제어할 수 있어야 함

\- 성능 최적화에서 굉장히 중요함

#### **4\. 사용 방법**

\- EntityManager를 통해 엔티티를 저장하거나 조회하면, 해당 엔티티가 컨텍스트에 등록되어 상태 변화를 자동으로 추적, 관리

#### **5\. 1차 캐시**

\- 영속성 컨텍스트 내부의 엔티티 보관소

\- 식별자를 키로 삼아 엔티티 인스턴스를 관리

\- 동일 트랜잭션 안에서 같은 엔티티를 여러번 조회해도 DB 접근은 최초 한 번만 발생하고 이후에는 캐시 결과를 재사용함

👉🏻불필요한 완복 줄여 성능 향상

\- 엔티티 동일성 보장

\- 트랜잭션 범위에만 유효

#### **6\. 쓰기 지연**

\- JPA가 persist()호출이나 엔티티 수정, 삭제 같은 작업을 처리할 때, 즉시 SQL을 실행하지 않고 영속성 컨텍스트 내부의 쓰기 지연 저장소에 SQL을 쌓아 두는 동작

\- 성능 때문에 씀

\- 데이터베이스와 네트워크통신은 어플리케이션에서 비싼작업이므로, 쿼리 10개 하나씩 10번 보내는 것보다 모아서 한 번에 보내는 것이 좋음

#### **7\. 변경 감지**

\- JPA가 영속 상태의 엔티티 변경을 자동으로 감지하고 DB에 반영하는 기능

\- 엔티티를 직접 업데이트하지 않아도 값의 변화가 데이터베이스에 반영됨

\- 엔티티가 영속성 컨텍스트에 들어올 때, JPA는 해당 객체의 당시 상태를 스냅샷으로 기록해 둠

👉🏻 이후 트랜잭션을 커밋하면, JPA는 현재 값과 스냅샷을 대조하여 달라진 부분을 찾아냄

👉🏻 변화가 감지되면 JPA는 수정된 칼럼만 포함한 UPDATE SQL을 생성하여 내부 저장소에 적재해 두었다가, 커밋 시 실제 데이터베이스에 반영함

---

### **2️⃣ Transaction**

#### **1\. 정의**

\- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

\- 단순히 데이터베이스에 명령을 보내는 기능을 넘어, 영속성 컨텍스트의 상태 관리와 변경 감지, 쓰기 지연 같은 내부 동작과 연관되어 있음

\- 트랜잭션이 시작되면 JPA는 그 범위 안에서 이루어진 모든 엔티티 변경 사항을 영속성 컨텍스트에 기록해둠

👉🏻 트랜잭션이 커밋되는 순간, 이 기록을 SQL로 변환하여 데이터베이스에 전달 후 반영

\- 엔티티의 상태 변화 → 영속성 컨텍스트에 기록 → 커밋 시 데이터베이스 반영 이라는 과정을 하나로 묶어 처리하는 장치

#### **2\. 사용 이유**

\- 모든 데이터 변경이 트랜잭션 안에서만 일관되게 처리되기 때문에, 원하는 시점에 정확하게 반영되도록 제어하기 위함

\- JPA는 엔티티 변경을 영속성 컨텍스트에 모아두었다가 트랜잭션이 커밋될 때 한꺼번에 반영하므로, 중간 단계의 불완전한 상태가 저장되지 않음

👉🏻 반영 시점을 명확하게 제어 가능

👉🏻 쓰기 지연, 변경 감지 같은 기능이 안정적으로 동작

#### **3\. 사용 방법**

\- 변경이 일어나는 메서드에 @Transcational을 선언하여 해당 로직이 하나의 작업 단위로 처리되도록  설정

#### **4\. OSIV 전략**

\- Open Sesseion In View

\- 영속성 컨텍스트를 어디까지 열어둘 것인가에대한 전략

\- 클라이언트 요청이 시작될 때 영속성 컨텍스트를 열고, 응답이 끝날 때까지 유지하는 전략

\- OSIV를 켜면, 하나의 요청이 들어와 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션이 함께 열려있는 상태가 유지됨

\- 특별한 일 없으면 false로 해둠 / 비활성화 해둠
