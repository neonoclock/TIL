## **🧠 회고**

오늘 배운 내용들 너무 어려웠지만... 과제 진행하면서 해결해보려고 한다

## **🪽 오늘의 다짐**

1\. 건강관리 잘하기

2\. 밀린 내용 복습 다 하기

---

## **📝 Today I Learned**

### **1️⃣ 연관관계 매핑**

#### **1\. 정의**

\- 엔티티 객체 간의 관계를 설정하여, 객체 지향적으로 연결된 데이터 구조를 정의하고 관리할 수 있도록 해주는 매핑 구조

\- 데이터베이스는 외래 키를 통해 테이블을 연결하고, 조인으로 연관된 데이터를 찾아옴

👉🏻 반대로 객체는 다른 객체의 참조를 필드에 보관하여 직접 연결을 표현함

👉🏻 관계를 표현하는 방식이 전혀 다른 두 영역(객체, 관계형 데이터베이스) 사이에서, JPA의 연관관계 매핑은 객체 모델과 테이블 구조가 일치하도록 보장함

> **❓ 객체 그래프 탐색**  
> \- 엔티티 객체가 가진 참조 필드를 따라가며 연관된 다른 엔티티에 접근하는 것  
> \- 데이터베이스에서는 여러 테이블을 조인해서 관련 데이터를 가져오지만, 객체 세계에서는 참조를 이용해 마치 연결된 그래프를 이동하듯이 접근할 수 있음  
> \- 객체 그래프 탐색을 사용하면 SQL을 직접 작성하지 않아도, 객체 참조만으로 연관 데이터를 조회 가능  
> 👉🏻 코드 간결하고 가독성 높아짐

\- SQL 중심 코드 대신 객체지향적은 코드 유지 가능

\- 관계 데이터의 탐색, 조회, 수정을 더 직관적으로 처리 가능

#### **2\. 사용 이유**

\- 객체 간의 관계를 관계형 데이터베이스의 외래 키와 정확히 연결하여, 데이터 정합성과 설계 일관성을 유지하기 위함

\- 연관관계 매핑을 사용하면 객체의 참조와 데이터베이스의 외래 키를 정확히 연결 가능

👉🏻 반대로 조회할 때도 FK로 조인한 결과를 다시 객체 참조로 복원하므로, 객체 세계와 관계형 세계 사이의 간극을 최소화함

\- 설계의 의도와 규칙이 코드에 드러남

#### **3\. 사용 방법**

\- 엔티티 필드에 @ManyToOne, @OneToMany, @OneToOne, @ManyToMany의 어노테이션을 선언하고, 외래 키를 기준으로 객체 간 관계를 설정함

---

### **2️⃣ 연관관계 매핑 - 단방향 연관관계**

#### **1\. 정의**

\- 한 엔티티에서만 다른 엔티티를 참조해 관계를 맺는 매핑 방식

\- 참조를 가진 쪽에서는 반대편 엔티티에 접근할 수 있지만, 반대편에서는 이 관계를 알 수 없음

\- 데이터베이스의 외래 키는 한쪽 테이블에만 존재하더라도 양쪽 방향의 조인이 가능하지만, 객체 세계에서는 참조 필드가 있는 쪽만 탐색이 가능함

#### **2\. 사용 이유**

\- 필요한 방향으로만 관계를 맺어 설계를 단순화하고 불필요한 의존성을 줄이기 위함

\- 객체 지향 모델에서 양방향 참조를 만들면 두 엔티티가 서로를 모두 알아야 하고, 생성수정 시점마다 양쪽 참조를 항상 일치시켜야 함

👉🏻 코드 복잡, 연관관계 편의 메서드 작성이나 참조 동기화 규칙 관리가 필수

👉🏻 단방향 연관 관계는 업데이트 포인트를 한 곳으로 제한

👉🏻 불필요한 의존성 줄임, 도메인 경계 더 명확히 가능

\- JPA에서도 단방향 매핑은 외래 키를 가진 주인 쪽만 관리하면 됨

👉🏻 관계 동기화 부담이 줄고 일관성 높아짐

👉🏻 반대방향 참조가 필요해지면, 스키마 변경 없이 mappedBy를 이용해 읽기 전용 컬렉션을 추가하면 됨

> **❓ mappedBy**  
> \- 양방향 연관관계에서 반대편이 외래 키를 관리하지 않는 읽기 전용 측임을 표시하는 설정

#### **3\. 사용 방법**

\- 연관을 가진 엔티티의 필드에 @ManyToOne 또는 @OneToOne과 @JoinColum을 선언해 참조 대상을 매핑

#### **4\. 핵심 규칙**

\- 외래 키를 가지는 쪽이 연관관계의 주인

\- 연관관계의 주인은 @JoinColumn을 사용

---

### **3️⃣  연관관계 매핑 - 양방향 연관관계**

#### **1\. 정의**

\- 두 엔티티가 서로를 참조해 양쪽에서 모두 관계를 탐색할 수 있도록 매핑한 방식

\- 한쪽에서 다른 쪽을 참조할 뿐 아니라, 반대편에서도 다시 참조를 가질 수 있음

\- 객체 그래프 탐색만으로도 SQL 조인을 자동으로 수행하여, 관계 데이터 조회가 훨씬 직관적

#### **2\. 연관관계의 주인**

\- 외래 키를 실제로 다루는 엔티티

\- 양방향 매핑에서는 두 엔티티가 서로 참조하더라도, 데이터 베이스에는 외래키가 하나만 생성됨

👉🏻 JPA 입장에서는 어느 쪽이 외래키를 관리할지 명확히 알아야 함

👉🏻 외래 키와 직접 연결된 테이블과 매핑되며, 수정 권한을 갖는 쪽을 연관관계의 주인으로 지정

👉🏻 반대편은 단순히 읽기 전용 역할만 수행함, 실제 데이터 베이스의 외래 키 변경 불가능

#### **3\. 사용 이유**

\- 연관된 엔티티를 양쪽에서 조회해 조회 편의성과 탐색 범위를 넓히기 위함

\- 객체 그래프 탐색만으로 필요한 데이터 가져올 수 있음

\- 화면이나 서비스 로직에서 양쪽 참조가 모두 필요한 경우 유용

\- 연관관계의 주인만 수정이 가능 / 반대편은 mappedBy로 읽기 전용임을 명시 해야함

\- 설계 초기에는 단방향으로 시작하고, 양방향 조회가 필요해졌을 때 추가하는 것이 안전

#### **4\. 사용 방법**

\- 연관 주인 쪽에 @ManyToOne과 @JoinColumn을, 반대쪽에 @OneToMany(mappedBy="연관필드명")를 선언해 서로 참조하도록 매핑 

👉🏻 JPA에서 양방향 연관 관계는 외래 키를 가진 쪽(주인)이 관계를 관리하고, 반대편은 이를 참조하는 구조

#### **5\. N+1 문제**

\- 엔티티를 한 번(1) 조회하고, 그에 연관된 데이터들을 N번 따로 조회하는 바람에 총 N+1개의 쿼리가 실행되는 비효율적인 현상

\- 양방향 매핑에서 발생함

\- Fetch Join으로 해결 가능

---

### **4️⃣ 연관관계 매핑 - ManyToOne (N:1)**

#### **1\. 정의**

\- JPA에서 여러 엔티티가 하나의 엔티티와 관계를 맺도록 하는 매핑 구조

\- N(많은 쪽) -> 1(하나의 쪽) 참조

\- 데이터베이스

👉🏻 N쪽 테이블이 외래키(FK)를 가지로 1쪽의 기본 키(PK)를 참조하는 구조

\- JPA

👉🏻 N쪽 엔티티의 참조 필드가 연관관계의 주인이 되며, 이 필드에 @ManyToOne과 @JoinColumn을 선언해 외래 키 컬럼을 매핑

👉🏻 반대편은 선택적으로 컬렉션을 두어 탐색을 돕게 할 수 있지만, 외래 키를 관리하지는 않

#### **2\. 다대일(N:1) 단방향 매핑**

\- N쪽 엔티티에서만 1쪽 엔티티를 참조하는 구조

\- 데이터베이스 구조

👉🏻 외래 키(FK)가 항상 N쪽 테이블에 위치하며, 이 외래 키를 통해 1쪽 레코드와 연결됨

\- 객체 모델

👉🏻 N쪽 엔티티가 1쪽 엔티티를 필드로 가지고 있어 참조가 가능하지만, 반대로 1쪽에서는 N쪽을 알 수 없음

#### **3\. 다대일(N:1) 양방향 매핑**

\- N쪽과 1쪽 엔티티가 서로를 참조할 수 있도록 연결한 구조

\- 데이터베이스 구조

👉🏻 단방향 매핑과 동일하게, 외래 키는 여전히 N쪽 테이블에 위치

\- 객체 모델

👉🏻 양쪽 모두에서 상대방을 참조할 수 있으므로, 어느 쪽에서든 관계를 탐색할 수 있음

\- 객체 그래프 탐색 범위가 넓어짐

\- JPA는 객체 탐색 시점에 필요한 SQL을 자동으로 생성함

👉🏻 개발자는 SQL 작성 없이 객체 참조를 이용해 양방향 관계 자연스럽게 활용할 수 있음

\- 항상 두 엔티티의 참조 상태를 일관성 있게 유지해야 함

#### **4\. 사용 이유**

\- 여러 엔티티에서 공유하는 상위 엔티티 정보를 한 곳에 모아 중복을 줄임

\- 연관 데이터를 필요한 시점에 조인으로 함께 조회하기 위함

\- 무결성 유지 가능, 상황에 맞게 성능 최적화 가능

#### **5\. 사용 방법**

```
@ManyToOne()
@JoinColumn(name = "user_id") // FK(post.user_id) -> user.user_id
private User author;
```

\- 다수 엔티티가 참조할 대상 엔티티 필드에 @ManyToOne과 @JoinColumn을 선언해 매핑을 지정

\- 엔티티 필드에 @ManyToOne을 선언하고, 외래 키를 지정하기 위해 @JoinColumn을 함께 사용

\- JPA가 외래 키를 기준으로 두 엔티티를 연결해주며, 실제 SQL 조인 없이도 객체 참조를 통해 연관된 엔티티에 접근 가능

---

### **5️⃣ 연관관계 매핑 - OneToMany (1:N)**

#### **1\. 정의**

\- 한 엔티티가 여러 개의 다른 엔티티와 관계를 맺는 매핑 구조

\- 객체 관점

👉🏻 List, Set과 같은 컬렉션 타입을 사용해 관계를 표현

👉🏻 컬렉션에 포함된 각 엔티티가 "다(N)"에 해당

\- 데이터베이스 관점

👉🏻 N쪽 테이블이 외래 키를 가지며 1쪽과 연결됨

👉🏻 하나의 레코드가 여러 레코드와 연결될 수 있지만, 각각의 N쪽 레코드는 하나의 1쪽 레코드만 참조

#### **2\. 1:N 단방향 매핑**

\- 1쪽 엔티티에서만 N쪽 엔티티를 참조

\- 반대로 N쪽에서는 1쪽을 참조하지 않는 구조

\- @JoinColumn을 반드시 지정해야함

👉🏻지정하지 않으면 불필요한 테이블(중간 조인 테이블)과 조인이 발생해 성능 떨어짐

> **❓ 중간 조인 테이블**  
> \- 두 테이블을 직접 외래 키에 연결하지 않고, 관계 정보만 저장하는 별도의 테이블  
> \- 단방향 @OneToMany 매핑에서 @JounColumn을 생략하면 JPA는 기본적으로 이 중간 조인 테이블을 생성해서 User-Post 관계 관리  
> \- 쿼리 실행 시 한 번 더 조인이 필요해 조회, 저장 성능 떨어짐  
> \- SQL 복잡

#### **3\. 1:N 양방향 매핑**

\- 대부분의 경우에는 다대일 매핑을 사용하는 편이 더 적절함  
👉🏻외래 키가 N쪽에 위치하는 데이터 베이스 구조와 자연스럽게 맞아떨어짐  
👉🏻INSERT 한 번으로 관계 정리 / 불필요한 UPDATE가 추가로 발생하지 않음  
👉🏻 SQL 실행 흐름 단순해지고, 성능 예측도 훨씬 쉬워짐

#### **4\. 사용 이유**

\- 하나의 엔티티가 관리하는 다수의 하위 엔티티를 객체 그래프에서 직접 조회, 관리해 관련 데이터를 일관되게 처리하기 위함

> **❓ fetch join**  
> \- JPQL에서 조인을 수행하면서 연관된 엔티티를 한 번에 함께 가져오는 기능  
> \- N+1 문제를 줄이고 성능 개선

> **❓ @EntityGraph**  
> \- JPA 쿼리 실행 시 연관된 엔티티를 미리 로딩할 경로를 어노테이션으로 지정하는 방법  
> \- 코드 변경 없이 로딩 전략 제어 가능 

#### **5\. 사용 방법**

\- 다수의 연관 엔티티를 담는 필드에 @OneToMany를 선언하고, mappedBy나 @JoinColumn으로 매핑 정보를 지정해 관리

```
@OneToMany(mappedBy = "author")
private List<Post> posts = new ArrayList<>();
```

\- @OneToMany(mappedBy = "author")  
👉🏻 User 한 명이 여러 Post를 가지고 있고, 그 Post들이 ‘author’라는 필드를 통해 User를 참조한다

#### **6\. Cascade (영속성 전이)**

\- 한 엔티티를 저장하거나 삭제할 때, 그와 연관된 다른 엔티티에도 동일한 작업을 자동으로 적용하는 기능

\- 부모 엔티티에 한 번만 명령을 내려도 자식 엔티티가 함께 저장되거나 삭제됨

(1) 종류

| CascadeType.PERSIST | 부모를 저장할 때 연관된 자식도 함께 저장함 |
| --- | --- |
| CascadeType.REMOVE | 부모를 삭제할 때 연관된 자식도 함께 삭제함 |
| CascadeType.MERGE | 부모를 병합할 때 연관된 자식도 함께 병합함 |
| CascadeType.DETACH | 부모를 준영속 상태로 만들 때 연관된 자식도 함께 준영속 상태로 전환함 |
| CascadeType.REFRESH | 부모를 새로 고칠 때 연관된 자식도 함께 새로 고침 |
| CascadeType.ALL | 위의 모든 전이 작업 포함 |

(2) 주의할 점

\- 엔티티가 부모와 완전히 같은 생명주기를 가질 때만 설정하는 것을 권장

\- 부모가 없어지면 자식도 함께 제거되어야 하는 강한 종속 관계에서만 사용해야 안전

#### 7\. Orphan Removal (고아 객체 제거)

\- 부모 엔티티와의 관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능

\- @OneToMany 또는 @OneToOne 관계에 orphanRemoval = true를 설정

👉🏻 JPA는 해당 자식이 "고아 객체"로 판단되는 순간 DELETE 쿼리 실행

\- 자식 엔티티를 오직 한 부모만 소유하는 경우에 사용해야 안전

---

### **6️⃣ 연관관계 매핑 - OneToOne (1:1)**

#### **1.  정의**

\- 하나의 엔티티가 다른 하나의 엔티티와 1:1로 매핑되는 구조

\- 데이터베이스에서도 외래 키가 한쪽에만 존재하며, 해당 외래 키 컬럼은 UNIQUE 제약 조건이 걸림

#### **2\. 1:1 단방향 매핑 (주 테이블에 외래 키)**

\- 외래키를 주 테이블 쪽에 두고, 주 엔티티가 대상 엔티티를 직접 참조하는 방식

\- 외래키에 유니크 제약 조건 추가됨

\- 주 엔티티 한 건이 항상 대상 엔티티 한 건과만 연결되며, 결과적으로 일대일 관계가 보장됨

#### **3\. 1:1 양방향 매핑 (주 테이블에 외래 키)**

\- 양방향으로 만들면 대상 엔티티에서도 주 엔티티를 참조할 수 있음

\- 외래 키가 있는 주 엔티티가 연관 관계의 주인이 됨

#### **4\. 1:1 양방향 매핑 (대상 테이블에 외래 키)**

\- JPA가 프록시를 이용한 지연 로딩을 제대로 지원하기 어려움

\- 쿼리 최적화에도 여러 제약 다름

\- 실무에서 잘 안씀

#### **5\. 사용 이유**

\- 두 엔티티 간에 고유하게 1:1로 매칭되는 데이터를 명확히 연결해, 조인 없이도 필요한 정보를 빠르게 조회하고 데이터 정합성을 보장하기 위함

\- 데이터베이스 차원에서 유일성 강제 가능

👉🏻 외래 키에 UNIQUE 제약을 걸어두면, 애플리케이션에서 별도의 검증 로직을 작성하지 않아도 한 엔티티에 대응되는 다른 엔티티는 정확히 하나뿐임을 보장 가능

\- 도메인 모델의 의도를 명확히 드러낼 수 있음

\- 하지만 실무에서 잘 쓰이지 않음

👉🏻 실무 데이터 패턴과의 불일치

👉🏻 테이블 구조 변경의 어려움

👉🏻 지연 로딩 제약

👉🏻 쿼리 최적화의 난이도

#### **6\. 사용 방법**

\- 연관 대상 엔티티를 참조하는 필드에 @OneToOne 과 @JoinColumn을 선언해 매핑 정보를 지정

---

\+ ManyToMany 는 실무에서 실질적으로 사용하지 않음!
