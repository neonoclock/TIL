## **🧠 회고**

스프링부트 내용이 너무 어렵다... 이론은 어렵지만 과제를 진행하면서 더 익혀나가야겠다.

## **🪽 오늘의 다짐**

1\. 5주차 과제 피드백 완성하기

2\. SQL 연결하기

---

## **📝 Today I Learned**

### **1️⃣ 연관관계 매핑 - OneToMany(1:N)**

#### **1\. 정의**

\- 한 엔티티가 여러 개의 다른 엔티티와 관계를 맺는 매핑 구조

\- 객체 관점

👉🏻 List, Set과 같은 컬렉션 타입을 사용해 관계를 표현함

👉🏻 컬렉션에 포함된 각 엔티티가 "다(N)"에 해당

\- 데이터베이스 관점

👉🏻 1:N관계는 N쪽 테이블이 외래 키를 가지며 1쪽과 연결됨

👉🏻 하나의 레코드가 여러 레코드와 연결될 수 있지만, 각각의 N쪽 레코드는 1쪽 레코드만 참조함

#### **2\. 1:N 단방향 매핑**

\- 1쪽 엔티티에서만 N쪽 엔티티를 참조하고, 반대로 N쪽에서는 1쪽을 참조하지 않는 구조

> **❓ 중간 조인 테이블**  
> \- 두 테이블을 직접 외래 키로 연결하지 않고, 관계 정보만 저장하는 별도의 테이블

\- 설계 자체에 한계 존재

👉🏻 불필요한 SQL 호출이 늘어나면서 성능 저하

👉🏻 실무: 1:N 단방향을 그대로 사용하지 않고, 다대일 양방향 매핑(@ManyToOne + @OneToMany)으로 풀어내는 방식 선호

👉🏻 이때 연관관계의 주인을 외래키가 있는 쪽으로 설정함

#### **3\. 1:N 양방향 매핑**

\- 대부분의 경우에는 다대일 양방향 매핑을 사용하는 편이 더 적절함

\- 외래 키가 N쪽에 위치하는 데이터베이스 구조와 자연스럽게 맞아떨어지고, 구현방식 단순

👉🏻 안정적으로 동작

\- JSON 순환참조 문제

@OneToOne 관계에서 양방향 매핑을 하면 두 엔티티가 서로를 참조하기 때문에 JSON으로 직렬화할 때 무한 순환 참조(Infinite Recursion) 문제가 발생합니다.

#### **4\. 사용 이유**

\- 하나의 엔티티가 관리하는 다수의 하위 엔티티를 객체 그래프에서 직접 조회, 관리해 관련 데이터를 일관되게 처리하기 위함

\- 서비스 로직에서 하위 엔티티를 개별적으로 쿼리하거나, 식별자를 일일이 전달해 조회하는 번거로움 줄이기 가능

\- 상위 엔티티를 통해 하위 엔티티를 추가, 삭제, 변경할 수 있으므로, 데이터의 라이프사이클을 한 곳에서 관리 가능

> **❓ fetch join**  
> \- JPQL에서 조인을 수행하면서 연관된 엔티티를 한 번에 함께 가져오는 기능  
> \- N+1 문제 줄이고 성능 개선 

> **❓ @EntityGraph**  
> \- JPA 쿼리 실행 시 연관된 엔티티를 미리 로딩할 경로를 어노테이션으로 지정하는 방법  
> \- 코드 변경 없이 로딩 전략 제어 가능

#### **5\. 사용 방법**

\- 다수의 연관 엔티티를 담는 필드에 @OneToMany를 선언하고, mappedBy나 @JoinColumn으로 매핑 정보를 지정해 관리함

---

### **2️⃣ Proxy**

#### **1\. 정의**

\- JPA에서 지연 로딩을 사용할 때 실제 엔티티 대신 먼저 생성되어, 데이터가 필요한 순간에 실제 조회를 지연시키는 가짜 객체

\- 실제 엔티티를 즉시 데이터베이스에서 조회하지 않고, 엔티티와 동일한 모양의 프록시 클래스를 먼저 생성해 반환

\- 프록시 객체는 실제 엔티티의 참조를 내부에 보관할 수 있는 구조를 가짐

\- 필드 접근 시점까지 조회를 지연시키는 역할

\- 프록시는 한 번 초기화되면 계속 실제 엔티티에 위임

👉🏻 원본 엔티티로 변환되지 않고 끝까지 프록시 객체로 남음

\- 진짜를 대신하는 껍데기

👉🏻 생성 지점에는 DB 조회를 하지 않고 실제 값이 필요한 시점에만 조회를 수행하며, 내부적으로는 원본 엔티티를 참조해 메서드를 위임하는 방식으로 동작

#### **2\. 사용 이유**

\- 연관된 엔티티를 실제로 사용할 떄까지 조회를 미뤄, 초기 쿼리 수를 줄이고 성능을 최적화하기 위함

\- 데이터베이스에서 모든 연관 데이터를 즉시 불러오면 사용하지 않는 데이터까지 미리 가져오게 됨

👉🏻 불필요한 SQL 실행과 네트워크 전송 발생

👉🏻 프록시는 최소한의 식별자만 가진 가짜 객체를 먼저 반환하고, 실제 데이터가 필요한 시점에만 데이터베이스를 조회

👉🏻 초기 로딩 시 필요한 엔티티만 조회하고, 나머지는 실제 접근 시점까지 지연함으로써 메모리 사용과 네트워크 부하 줄임

#### **3\. 사용 방법**

\- 연관 관계에 FetchType.LAZY를 설정하여, JPA가 실제 엔티티 대신 프록시 객체를 생성하도록 지정

\- Proxy는 연관관계에 FetchType.LAZY를 설정했을 떄 동작하며, 즉시 연관 엔티티를 불러오지 않고 프록시 객체를 반환

👉🏻 프록시는 실제 엔티티를 상속받은 가짜 객체로, 필요한 시점에만 DB 조회해 데이터를 초기화함

👉🏻 불필요한 SQL 실행을 줄여 성능 최적화

👉🏻 초기화 시점을 명확히 이해하지 못하면 예상치 못한 쿼리 발생

#### **4\. 타입 비교 시 주의 사항**

\- 프록시 객체는 원본 엔티티를 상속받아 생성되므로, 겉보기에는 같은 타입처럼 보이지만 getClass()로 비교하면 차이가 날 수 있음

\- 타입 비교시 ==연산자 사용하지 않음

\- instanceof 를 활용하면 프록시 여부와 관계없이 동일하게 엔티티 타입 판별 가능

👉🏻 프록시 객체든, 실제 엔티티든 모두 true 반환

👉🏻 비즈니스 로직에서 타입 차이로 인한 예기치 못한 오류를 막을 수 있음

👉🏻 프록시를 안전하게 다룰 수 있음

#### **5\. 준영속 상태에서 프록시 초기화 시 주의점**

\- 프록시는 생성되는 순간 실제 데이터를 가지고 있지 않음

👉🏻 엔티티의 값이 필요할 때마다 영속성 컨텍스트를 통해 데이터베이스를 조회하여 초기화가 이루어짐

👉🏻 이 동작은 영속성 컨텍스트가 열려 있을때만 가능하다는 제약 존재

👉🏻 프록시가 영속성 컨텍스트와 연결되지 않은 상태(준영속 상태)로 전환되었거나, 컨텍스트 자체가 닫힌 상황이라면 초기화 요청을 처리할 수 없음

👉🏻 따라서 프록시는 트랜잭션 범위 안에서 초기화하도록 관리해야 함

👉🏻 웹 애플리케이션에서는 트랜잭션이 종료된 뒤 컨트롤러나 뷰에서 프록시에 접근하지 않도록 설계하는 것이 중요

---

### **3️⃣ JPQL**

#### **1\. 정의**

\- 엔티티 객체를 대상으로 데이터를 조회하거나 조작할 수 있도록 제공되는 객체지향 쿼리 언어

\- JPA를 이용해 데이터를 다룰 때 단순히 find() 메서드를 호출하거나 연관 엔티티를 객체 그래프로 탐색하는 것만으로는 필요한 데이터를 모두 가져오기 어려움

👉🏻 애플리케이션에서 조건을 지정해 원하는 데이터만 조회하려면 결국 쿼리가 필요함

👉🏻 이때 JPQL은 엔티티 객체와 그 속성을 대상으로 작성하는 객체지향 쿼리 언어 제공

\- 기존 SQL

👉🏻 데이터베이스 테이블과 컬럼을 직접 다룸

\- JPQL

👉🏻 엔티티 모델을 기준으로 작성

👉🏻 실행 시 JPA 구현체가 이를 실제 데이터베이스에 맞는 SQL로 변환함

👉🏻 특정 데이터베이스 문법에 종속되지 않음

👉🏻 동일한 JPQL 문장은 데이터베이스 종류가 바뀌어도 같은 동작을 보장할 수 있음

👉🏻 객체 지향 설계와 관계형 데이터베이스를 매끄럽게 연결

\- SQL을 직접 작성하지 않고도 객체 중심 개발 방식을 유지하면서 필요한 데이터를 데이터베이스에서 직접 가져올 수 있음

#### **2\. 사용 이유**

\- 엔티티를 기준으로 쿼리를 작성해 객체 지향 설계를 유지하면서, 데이터베이스에 독립적이고 유지보수하기 쉬운 코드를 작성할 수 있기 때문

\- JPQL을 사용하면 테이블과 칼럼이 아닌 엔티티와 필드를 기준으로 쿼리 작성 가능

👉🏻 쿼리에 사용하는 이름과 구조가 도메인 모델과 동일하므로, 설계와 코드가 자연스럽게 맞물림

\- 특정 데이터베이스의 문법에 의존하지 않음

👉🏻 JPA가 JPQL을 각 데이터베이스에 맞는 SQL로 변환해 실행하므로, 데이터베이스를 바꾸더라도 쿼리를 그대로 사용할 수 있음

👉🏻 코드 변경 범위가 줄어들고 유지보수 쉬워짐

\- 필요한 데이터만 데이터베이스에서 조회

👉🏻 조건 검색, 조인, 정렬, 프로젝션 등을 지원하므로, 메모리에 불필요한 데이터를 올리지 않고 결과를 가져올 수 있음

\- 엔티티 연관 관계를 활용해 객체 그래프를 유지한 채로 복잡한 조회 처리 가능

\=> JPQL은 객체 지향 설계를 유지하면서, 데이터베이스에 독립적이고, 성능과 유지보수성을 모두 확보할 수 있는 객체 지향 쿼리 언어

#### **3\. 사용 방법**

\- EntityManager의 createQuery() 메스드에 엔티티 기준의 쿼리 문자열을 작성하고, 실행하여 결과 조회

\- JPQL에서 쿼리를 작성할 때는 엔티티에 반드시 별칭을 부여해야 함

👉🏻 쿼리 대상은 데이터베이스 테이블이 아니라 엔티티 이름

👉🏻 엔티티 이름과 속성명은 대소문자 구분하지 않음

**(1) SELET**

```
select 별칭
from 엔티티명 별칭
where 조건식
group by 그룹핑기준
having 그룹핑조건
order by 정렬기준
```

\- 엔티티를 대상으로 검색 수행

\- 테이블이 아니라 엔티티 이름과 별칭을 기준으로 작성해야함

\- WHERE 절

👉🏻 조건을 지정해 데이터만 필터링 가능

\- GROUP BY, HAVING

👉🏻특정 속성을 기준으로 집계된 결과 다룰 수 있음

\- ORDER BY절

👉🏻 결과 정렬 가능

**(2) UPDATE**

```
update 엔티티명 별칭
set 컬럼 = 값
where 조건식
```

\- 엔티티의 특정 속성 값을 일괄적으로 변경할 때 사용

\- SET절

👉🏻 변경할 필드와 새로운 값 지정

\- WHERE절

👉🏻 변경 대상이 될 조건 명시

\- 벌크 연산으로 동작

> **❓ 벌크 연산**  
> \- 다수의 데이터를 한 번의 SQL로 수정, 삭제하는 연산  
> \- 성능은 빠르지만 영속성 컨텍스트와 동기화되지 않아 주의 필요

**(3) DELETE**

```
delete from 엔티티명 별칭
where 조건식
```

\- 특정 조건에 해당하는 엔티티 데이터를 데이터베이스에서 제거할 때 사용함

\- WHERE절

👉🏻 삭제할 대상 지정

👉🏻 조건을 생략하면 해당 엔티티의 모든 데이터가 삭제됨

#### **4\. 파라미터 바인딩**

\- JPQL에서는 조건절에 직접 값을 넣기보다는 파라미터 바인딩을 사용해 안전하게 값을 전달

> **❓ 파라미터 바인딩**  
> 쿼리에 들어갈 값을 직접 문자열로 붙이지 않고 ‘변수(파라미터)’로 전달해서 안전하게 처리하는 방법

**(1) 이름 기반 바인딩**

\- 콜론(:)뒤에 이름을 붙여 사용하는 방식

\- 이후 setParameter("username", 값) 형태로 값 지정

\- 순서와 관계없이 명확한 이름을 기준으로 값을 바인딩

👉🏻 코드 안정성이 높고 유지보수 훨씬 용이

**(2) 위치 기반 바인딩**

\- 물음표 뒤에 숫자를 붙여 사용하는 방식-

\- setParameter(1, 값) 처럼 순번을 지정해 값을 전달

\- 쿼리 중간에 파라미터가 추가되거나 순서가 바뀌면 전체 쿼리를 다시 수정

\- 버그나 장애 발생할 가능성 높음

#### **5\. JPQL에서 자주 사용하는 타입과 연산자**

**(1) 타입**

\- 숫자, 불리언, 문자, 열거형

**(2) 연산자**

\- SQL과 거의 동일하게 제공

\- 비교 연산자 (=,<>,<,<=,>,>=)

\- 조건 연산자 (AND, OR, NOT)

\- BETWEEN: 특정 값이 일정 범위 안에 있는지 확인

\- LIKE: 문자열 패턴 검사

\- ISNULL: 값이 비어 있는지 확인

\- IN: 여러 값 중 하나와 일치하는지 검사

#### **6\. 조건식**

**(1) NULLIF**

\- 두 값이 동일하면 null 반환

\- 다르면 첫 번째 값 반환

**(2) COALESCE**

\- 여러 값을 차례대로 학인하다가 null이 아닌 첫 번째 값을 반환

**(3) CASE**

\- 조건을 순서대로 검사하여 일치하는 경우 해당 결과 돌려줌

\- 일치하는 조건이 없으면 ELSE 절의 값 반환

#### **7\. 집합과 정렬**

**(1) 집계 함수**

\- 데이터를 요약하거나 통계적으로 분석하는 집계함수

\- COUNT, SUM, AVG, MAX, MIN

**(2) 그룹핑과 조건지정**

\- GROUP BY: 집계 함수를 단일 결과가 아니라 특정 속성별로 나누어 보고 싶을 때 사용

\- HAVING 결합: 그룹화된 결과에 조건 줄 수 있음

**(3) 정렬 기능**

\- ORDER BY: 결과 정렬

#### **8\. JPQL 기본 함수**

**(1) 문자열 함수**

\- LOWER / UPPER

👉🏻 소문자 또는 대문자로 변환

\- CONCAT

👉🏻 문자열을 이어 붙임

\- SUBSTRING

👉🏻문자열의 일부를 잘라냄

\- TRIM  
👉🏻문자열 앞뒤의 공백 제거

\- LENGTH

👉🏻 문자열의 길이 반환

\- LOCATE  
👉🏻 특정 문자가 나타나는 위치 찾음

**(2) 수치 함수**

\- ABS

👉🏻 절대값 반환

\- MOD

👉🏻 나머지 구함

\- SQRT

👉🏻 제곱근 계산

**(3) 컬렉션 함수**

\- SIZE

👉🏻 컬렉션의 원소 개수 반환

\- INDEX

👉🏻 순서가 있는 컬렉션에서 인덱스 반환

---

### **4️⃣ 경로 표현식**

#### **1\. 정의**

\- JPQL에서 엔티티의 필드나 연관된 엔티티의 속성에 접근할 때 사용하는 점(.)

\- 연산 기반의 참조 방식

\- 엔티티 참조 뒤에 점을 찍어 필드나 연관 관계를 따라가면 JPA가 이를 SQL로 변환해 실행함

#### **2\. 경로 표현식 참조 대상 유형**

**(1) 상태 필드**

\- 단순 값을 저장하는 필드

\- 탐색의 끝

**(2) 단일 값 연관 필드**

\- 다른 엔티티와의 연관 관계를 나타내는 필드

\- 탐색 가능

**(3) 컬렉션 값 연관 필드**

\- 컬렉션 타입으로 연관된 엔티티 집합을 나타냄

\- 점 연산으로 바로 탐색할 수 없고 별칭을 통해 접근해야 함

\=> 단일 값 연관 필드나 컬렉션 값 연관 필드를 경로 표현식으로 참조하면, JPQL은 해당 연관 관계에 대해 묵시적 내부 조인 발생시킴

👉🏻 SQL로 변환될 때 자동으로 조인 구문 추가된다는 뜻

#### **3\. 묵시적 조인**

**(1) 정의**

\- join 키워드를 직접 작성하지 않아도, 경로 표현식이 포함되면 JPA가 내부적으로 필요한 SQL 조인을 자동으로 생성하는 방식

**(2) 특징**

\- 항상 내부 조인

👉🏻 묵시적 조인으로는 LEFT JOIN 같은 외부 조인을 생성할 수 없음

\- 컬렉션 값 연관 필드는 탐색 불가

\- SELET, WHERE 절의 경로 표현식이 FROM절에 영향을 줌

👉🏻 개발자가 FROM 절에 조인을 작성하지 않아도, 경로 표현식이 있으면 JPA가 내부적으로 FROM 절에 조인 추가

**(3) 장점**

\- 쿼리 문법 간단해지고 길이 줄일 수 있음

**(4) 단점**

\- 실제 어떤 조인이 수행되는지 JPQL만 보고는 명확히 알기 어려움

\- 대규모 프로젝트나 성능 최적화가 중요한 환경에서는 문제됨

\- 의도하지 않은 내부 조인이 자동으로 발생

👉🏻 불필요한 데이터 조회 늘어남

👉🏻 성능 저하로 이어짐

\- 내부 조인으로만 동작

👉🏻 외부 조인이 필요한 상황에서는 사용할 수 없음

#### **4\. 명시적 조인**

**(1) 정의**

\- JPQL에서 join 키워드를 사용하여 조인을 직접 선언

\- 조인 대상, 별칭, 조인 조건을 개발자가 명확하게 작성하므로 쿼리 구조 직관적으로 파악 가능

**(2) 특징**

\- 조인 구조 명확

👉🏻조인 대상과 조건을 직접 작성하므로, 쿼리만 보고도 조인 관계 쉽게 파악 가능

\- 다양한 조인 방식 지원

👉🏻 INNER JOIN뿐만 아니라, LEFT JOIN, RIGHT JOIN 등 다양한 조인 방식 사용 가능

\- 컬렉션 탐색 가능

👉🏻별칭을 부여하면 컬렉션 내부의 필드까지 안전하게 탐색 가능

\- 성능 최적화 용이

👉🏻 불필요한 조인을 방지하고, 필요한 경우 조인 조건 세밀하게 조정 가능

\=> 명시적 조인은 JOIN 구문을 직접 작성

\=> 어떤 테이블이 어떻게 연결되는지 쿼리 단계에서 바로 드러남

\=> 필요한 경우 조건을 추가하거나 필터링을 세밀하게 걸 수 있어, 성능 조정에도 유리

\=> 특히 컬렉션 필드를 탐색해야 하는 경우, 별칭을 부여한 명시적 조인을 사용해야 내부 속성에 안전하게 접근 가능

\=> 이 과정이 없으면 SQL 변환 시 불필요한 제약이나 예외 발생하기 쉬움

#### **5\. 사용 이유**

\- JPQL에서 엔티티 내부의 필드나 연관된 객체의 속성까지 접근해 원하는 데이터를 정확하게 조회하기 위함

\- 객체 지향 설계의 장점을 그대로 살린 채로 필요한 데이터가 어디에 있든 동일한 방식으로 접근 가능

\- 코드 가독성 높아짐

\- 데이터 조회 범위와 경로가 쿼리에서 명확히 드러나 유지보수에 용이

#### **6\. 사용 방법**

\- JPQL에서 엔티티의 필드나 연관 객체의 속성을 점(.)을 이용해 계층적으로 참조

---

### **5️⃣ fetch join**

#### **1\. 정의**

\- 지연 로딩된 연관 엔티티를 한 번의 쿼리로 함께 조회하기 위해 사용하는 조인 방식

\- 일반 조인

👉🏻 연관된 엔티티를 즉시 조회하지 않고, 지정된 엔티티만 SELECT 절에 포함함

👉🏻 연관된 데이터가 필요한 시점에 지연 로딩으로 추가 SQL 발생

\- fetch join

👉🏻 join fetch 구문을 사용하여 연관된 엔티티나 컬렉션을 함께 SELECT 절에 포함시킴

👉🏻 연관 관계에 있는 데이터를 미리 모두 가져오기 때문에, 엔티티를 탐색할 때 추가 쿼리 발생하지 않음

\- 지연 로딩으로 인한 N+1 문제 예방

\- 한 번의 쿼리로 필요한 데이터 전체를 가져올 수 있음

#### **2**. **사용 이유**

\- 지연 로딩된 연관 엔티티를 한 번의 쿼리로 함께 조회하여 N+1 문제를 해결하고 성능을 최적화하기 위함

\- 주 엔티티와 그와 연관된 엔티티를 처음 조회할 때부터 한 번의 조인 쿼리로 전부 가져옴

👉🏻 한 번의 SELECT로 화면이나 API에서 필요한 모든 데이터를 메모리에 올려두는 것

👉🏻 지연 로딩에서 흔히 발생하는 N+1 문제가 사라짐

\- 이 쿼리에서만 필요한 연관 데이터를 미리 당겨오는 쿼리 단위의 fetch 계획을 세울 수 있음

👉🏻 동일한 코드가 상황에 다라 갑자기 추가 쿼리를 발생시키는 변동성을 줄일 수 있음

#### **3\. N+1이 발생하는 이유**

\- N+1 문제는 한 번의 조회(1) 후에 연관된 데이터를 가져오기 위해 N번의 추가 쿼리가 실행되어, 총 N+1개의 쿼리가 발생하는 현상

#### **4\. fetch join이 어떻게 해결하는지?**

\- Fetch Join은 N+1 문제를 해결하기 위해 연관된 엔티티를 한 번의 쿼리로 함께 조회하는 방법

\- Fetch Join은 JPQL에서 JOIN FETCH 문법을 사용해 연관된 엔티티를 한 번의 SQL로 미리 로딩하여, 루프마다 추가 쿼리가 발생하는 N+1 문제를 근본적으로 해결

#### **5\. 사용 방법**

\- JPQL에서 join 키워드 뒤에 fetch를 추가하여 연관 엔티티를 함께 조회하도록 작성

#### **6\. 일반조인 vs fetch join**

| **구분** | **일반 조인** | **fetch join** |
| --- | --- | --- |
| **SELECT 절** | 지정된 엔티티만 조회 | 연관된 엔티티까지 함께 조회 |
| **연관 엔티티 로딩** | 지연 로딩 시점에 별도 쿼리 실행 | 조회 시점에 함께 로딩 |
| **성능 영향** | N+1 문제 발생 가능 | 한 번의 쿼리로 해결 |
| **사용 목적** | 조인 조건으로 대상 필터링 | \- 연관 데이터 즉시 로딩   \- 객체 그래프 완성 |

#### **7\. 컬렉션 페치 조인**

**(1) 정의**

\- 일대다, 다대다 관계에서 연관된 컬렉션을 지연 로딩 없이 한 번의 쿼리로 함께 조회하는 기능

\- N+1 문제 방지

**(2) 제약과 주의 사항**

\- 여러 컬렉션을 한꺼번에 페치 조인할 수 없음

👉🏻 두 개 이상 컬렉션을 동시에 조인하면 결과 집합이 곱셈 구조로 불어나 중복 데이터가 발생하거나 결과 자체가 왜곡될 수 있음

\- 페이징과의 충돌

👉🏻 조인으로 인해 결과 행이 늘어나기에 데이터베이스에서 안전한 페이징 처리가 불가능 

👉🏻 하이버네이트는 이 상황에서 전체 결과를 메모리에 불러온 뒤 잘라내는데, 데이터 양이 많으면 메모리 사용량이 폭증하여 OOM 오류로 이어질 수 있음

\- 대량 데이터 조회상황

👉🏻 일대다 관계의 '다'쪽에 데이터가 많으면 조인 결과가 폭발적으로 증가해, 네트워크 전송량과 애플리케이션 메모리 사용량이 동시에 커지고 처리 속도도 느려짐

**(3) 결론**

\- 컬렉션 페치 조인은 조건이 맞을 때만 제한적으로 사용해야 함

\- 페이징이 필요한 경우에는 DTO 전용 쿼리나 @BatchSize 방법 고려

\- 컬렉션 페치는 주로 N+1 문제가 드러난 특정 화면에서, 데이터 규모가 크지 않고 페이징이 필요 없는 경우에 한정해 사용됨

#### **8\. @BatchSize**

**(1) 정의**

\- 하이버네이트가 제공하는 배치 로딩 기능

\- 지연 로딩 시 N+1 문제를 완화하기 위해 한 번의 SQL로 여러 개의 연관 데이터를 묶어서 조회할 수 있도록 하는 설정

\- 기본적으로 지연 로딩은 연관 데이터에 접근할 때마다 추가 SQL을 실행

👉🏻 이때 @BatchSize를 사용하면, JPA가 한 번의 쿼리에서 지정된 개수만큼의 연관 데이터를 미리 로딩

👉🏻 같은 범위 안의 엔티티들은 추가 쿼리 없이 메모리에서 데이터를 읽음

\- fetch join처럼 한번의 거대한 JOIN 쿼리 날리는 대신 지연 로딩하되 N개의 쿼리를 몇개의 묶음(batch)으로 줄여주는 방식

---

### **6️⃣  Spring Data JPA**

#### **1\. 정의**

\- JPA 기반의 데이터 처리를 자동화 해 인터페이스만으로 리포지토리를 쉽게 구현할 수 있도록 도와주는 Spring 모듈

\- JpaRepository는 Spring Data JPA에서 제공하는 핵심 인터페이스

👉🏻 JPA 엔티티를 대상으로 하는 표준 CRUD 메서드와 페이징, 정렬 기능을 모두 포함함

👉🏻 findAll(), findById(), save(), delete() 같은 기본 메서드가 이미 구현되어 있으므로, 이 인터페이스를 상속하기만 해도 데이터 접근 계층의 기본 동작을 바로 사용 가능

👉🏻 쿼리 메서드 기능을 통해 메서드 이름만으로 조건이 포함된 쿼리 자동 생성 가능

\=> Spring Data JPA는 JPA를 한 단계 더 추상화하여, 복잡한 DAO 코드나 쿼리 없이 메서드 이름만으로도 데이터베이스 접근(CRUD)을 자동으로 처리해주는 Spring 기반 ORM 프레임워크

#### **2\. Repository 공통 인터페이스 계층 구조**

\- Spring Data JPA repo들은 계층 구조를 갖고 있음

**(1) Repository**

\- 가장 상위 인터페이스

\- 스프링 데이터 저장소 계층의 공통 부모 역할 함

**(2) CrudRepository**

\- CRUD(Create, Read, Update, Delete) 기능을 기본적으로 제공하는 인터페이스

**(3) PagingAndSortingRepository**

\- CrudRepository를 확장해, 페이징(Pageable)과 정렬(Sort) 기능을 추가로 제공

**(4) JpaRepository**

\- PagingAndSortingRepository를 확장하며, JPA에 특화된 flush, batch, 쿼리 메서드 기능 등을 제공

#### **3\. 사용 이유**

\- 반복적인 CRUD코드 없이 인터페잉스만으로 리포지토리를 구현해 개발 생산성과 유지보수 효율을 높이기 위함

\- 리포지토리 인터페이스를 선언하고 JpaRepository를 상속

👉🏻 기본 CRUD와 페이징, 정렬 기능이 즉시 제공되며, findByEmail, findByTitleContaining처럼 메서드 이름만으로도 쿼리 자동 생성 가능

\- 감사 로그, 쿼리 메서드, 커스텀 구현 병합 등 실무에서 자주 쓰이는 기능들이 기본 포함

👉🏻 반복 코드 최소화, 핵심 비즈니스 로직과 도메인 설계에 집중할 수 있는 환경 제공

> **❓ 감사 로그**  
> \- 엔티티의 생성, 수정 시각과 작성자, 수정자를 자동으로 기록하는 기능

#### **4\. 사용 방법**

\- 리포지토리 인터페이스에 JpaRepository를 상속하고, 메서드 이름이나 @Query로 원하는 쿼리 정의
