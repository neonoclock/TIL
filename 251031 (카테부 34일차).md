## **🧠 회고**

오늘 정말 많은 일이 있었지만... 부족한 만큼 더 잘하고 열심히 하면 된다 다 할 수 있다... 마음 다잡기

## **🪽 오늘의 다짐**

1\. 복습 열심히 하고 할 거 열심히 하기

2\. 면접 상황에 적응하기 (긴장되는 상황에서 긴장을 받아들일 줄 아는 사람 되기)

---

## **📝 Today I Learned**

### **1️⃣ Query Method**

#### **1\. 정의**

\- 리포지토리 인터페이스의 메서드 이름을 기반으로 JPQL 쿼리를 자동으로 생성해주는 기능  
\- Spring Data JPA에서 쿼리를 직접 작성하지 않고, 메서드 이름만으로 SQL을 자동 생성해주는 기능

\- 메서드 명에 포함된 키워드와 엔티티의 필드명을 분석해 WHERE절, 조건 연산자, 정렬, 페이징 등의 쿼리 요소를 조립함

👉🏻 이렇게 메서드 이름만으로도 검색 조건과 연산자를 지정할 수 있어, 별도의 JPQL 문자열을 작성할 필요 없이 직관적으로 데이터 조회 로직을 구현할 수 있음

👉🏻 엔티티 필드명이 변경되면 컴파일 아니라 애플리케이션 로딩 시점에서 오류를 감지하므로, 잘못된 쿼리를 서비스 배포 전에 발견할 수 있음

👉🏻 메서드 이름으로 조회, 개수 조회, 존재 여부 확인, 삭제, 중복 제거, 조회 개수 제한 등 다양한 작업 표현 가능

#### **2\. 사용 이유**

\- 메서드 이름만으로 다양한 조건의 쿼리를 자동 생성해 반복 코드를 줄이고 구현 없이도 일관된 데이터 처리를 가능하게 하기 위함

\- 메서드 선언만으로 쿼리가 만들어지므로, 매번 find, count, exits와 같은 기본 조회 로직을 직접 작성할 필요 없음

\- Spring Data JPA는 애플리케이션 시작 시 메서드 이름을 해석해 JPQL을 자동으로 생성

👉🏻 저장소 코드를 간결하고 균일하게 유지 가능

\- 팀원 누구나 동일한 패턴으로 리포지토리를 작성하고 읽을 수 있어, 코드 스타일이 일정하게 유지됨

\- 메서드 시그니처 자체가 쿼리 의도를 설명하므로 가독성이 높고, 동작을 쉽게 이해할 수 있음

\- 문자열 기반 쿼리를 해석할 필요가 없어 코드 리뷰 수월

\- 필드명이 변경되면 메서드 이름 리팩토링만으로 함께 추적이 가능해 IDE 자동완성과 리네이밍 기능 온전히 활용 가능

\- 잘못된 구문은 애플리케이션 기동 시 즉시 오류로 드러나 안정성이 높음

#### **3\. 사용 방법**

\- 리포지토리 인터페이스에 메서드 이름을 조건에 맞게 작성하면, Spring Data JPA가 해당 이름을 분석해 쿼리를 자동 생성

**(1) 기본 형식**

\- 메서드 이름 = 조건식 규칙(접두사+속성+연결자 And/Or+정렬 OrderBy...)을 따라 JPQL을 자동 생성

\- 중첩 속성 Author\_Nickname처럼 프로퍼티 탐색으로 표현 가능

\- 메서드 파라미터는 시그니처 순서대로 바인딩되며, 정렬 페이징은 Sort/Pageable 인자 추가

> **❓ 프로퍼티 탐색**  
> \- 엔티티 안에서 연관된 객체의 속성을 점(.)으로 따라가며 조건을 지정하는 방식  
> \- Query Method에서는 점(.)을 메서드 이름에 그대로 쓸 수 없으므로 언더스코어(\_)로 바꿔 표현

**(2) 주요 규칙**

| **findBy...** | 조건에 맞는 엔티티 조회 |
| --- | --- |
| **existBy...** | 존재 여부만 반환 (boolean) |
| **countBy...** | 조건에 맞는 행 수 반환 |
| **deletBy...** | 조건에 맞는 데이터 삭제 |
| **...And... / ...Or...** | 여러 조건 조합 |
| **Between** | 범위 조건 |
| **LessThan / GreaterThan** | 비교 조건 |
| **In** | IN 조건 |
| **IsNull / IsNotNull** | NULL 여부 검사 |
| **Containing / Like / StartingWith / EndingWith** | 부분 문자열 검색 |
| **Top / First (숫자)** | 상위 N개만 조회 |
| **OrderBy...Asc / Desc** | 정렬 조건 |

\- 중첩 속성은 . 대신 \_ 로 표현  
  
  

---

### **2️⃣ @Query**

Query Method : 정해진 메뉴판에서 쉐프에게 주문하는 방식 

@Query : 쉐프에게 직접 레시피 전달해서 원하는 요리 만들어달라고 하는것 

#### **1\. 정의**

\- 리포지토리 메서드에 JPQL이나 SQL 쿼리를 직접 작성해 실행할 수 있도록 해주는 어노테이션  
\- 메서드 이름을 해석해서 쿼리를 만드는 방식과 달리, 개발자가 JPQL을 직접 문자열로 지정하면 Spring Data가 애플리케이션 기동 시 그 쿼리를 파싱, 검증하고, 메서드가 호출될 때 해당 쿼리 실행

\- 기본값은 JPQL

\- 메서드 이름으로 표현하기 어려운 복잡한 쿼리를 JPQL로 직접 작성해 실행할 수 있도록 하는 Spring Data JPA의 어노테이션

#### **2\. 사용 이유**

\- 메서드 이름으로 표현하기 어려운 복잡한 조건, 조인, 집계 쿼리를 명확하고 유연하게 작성하기 위함

👉🏻 조건이 여러 개 겹치거나, 다중 조인과 서브쿼리, DTO 매핑이 필요한 상황에서는 메서드 이름이 지나치게 길어져 가독성이 유지보수도 어려워짐

\- 쿼리를 직접 작성하면 성능 제어 측면에서 유리

👉🏻 조회 컬럼을 최소화하거나, 조인 구조를 조정하고, 페이징 시 countQuery를 별도로 최적화하는 등 실행 계획을 예측하며 튜닝 가능

\- 반환 형태 자유롭게 지정 가능

👉🏻 엔티티 전체가 아닌 특정 필드만 가져오거나, DTO 생성자 표현식으로 필요한 데이터 구조를 바로 만들 수 있으며, 집계 결과나 스칼라 값을 그대로 반환하는 것도 가능함

#### **3\. 사용 방법**

\- 리포지토리 메서드에 JPQL 쿼리를 직접 작성하고, @Param을 이용해 파라미터를 바인딩

---

### **3️⃣ @EntityGraph**

#### **1\. 정의**

\- 특정 엔티티를 조회할 때 함께 로딩할 연관 엔티티를 사전에 지정하여, N+1 문제를 해결할 수 있게 해주는 어노테이션

\- 특정 엔티티를 조회할 때 함께 불러올 연관 속성의 조회 계획을 선언적으로 지정하여, 그 쿼리 범위에서 지연 로딩 설정을 일시적으로 덮어씀

👉🏻 전역 매핑을 바꾸지 않고도 그래프를 미리 정의해 두는 방식  
\- JPQL을 수정하지 않고도 연관 엔티티를 한 번의 쿼리로 함께 조회할 수 있게 해주는 기능으로, Fetch Join과 달리 페이징이 가능하고 N+1 문제를 효과적으로 해결할 수 있음

\- 데이터 필터링이나 정렬을 바꾸는 기능이 아니라, 조회 시점에 어떤 연관을 즉시 로딩할지 결정하는 로딩 계획을 기술

\- 구현체(하이버네이트)는 이 계획에 따라 페치 조인이나 배치 로딩을 생성하여 한 번의 질의로 필요한 객체 그래프를 구성함

> **❓ fetch join과 다른점**  
> \- fetch join: JPQL 구문 안에서 직접 조인을 지정해 연관 엔티티를 한 번에 가져오는 방법  
> \- @EntityGraph: JPQL을 수정하지 않고, 리포지토리 메서드에 애노테이션으로 로딩 계획을 선언하는 방식  
>   
> \=> fetch join은 쿼리 자체를 바꾸는 것이고, @EntityGraph는 기존 쿼리에 로딩 전략을 덧입힘

#### **2\. 사용 이유**

\- 반복적인 쿼리가 발생하는 N+1 문제를 방지하고 연관 데이터를 한 번에 조회하기 위함

\- 리포지토리 메서드에 @EntityGraph만 붙여주면, 주 엔티티와 지정한 연관 엔티티를 한 번의 SQL로 같이 가져올 수 있음

\- JPQL에 일일이 fetch join 문법을 추가하지 않아도 되므로 코드가 간결해짐

\- 메서드 선언만 봐도 의도가 드러나 가독성도 좋아짐

\- 쿼리 로직이 코드 속에 숨겨져 있지 않고, 선언적으로 표현된다는 점에서 협업과 유지보수에도 유리

#### **3\. 사용 방법**

\- 리포지토리 메서드에 어노테이션을 붙이고 attribute 속성에 함께 조회할 연관 엔티티의 필드명 지정

#### **4\. @EntityGraph vs fetch join**

|   | **@EntityGraph** | **fetch join** |
| --- | --- | --- |
| **개념** | 리포지토리 메서드에 "함께 로딩할 연관"을 어노테이션 | JPQL 문장 안에서 join fetch로 즉시 로딩을 강제하는 쿼리 문법 |
| **선언 위치** | 리포지토리 메서드 | JPQL 문자열 내부 |
| **적용 방식** | 쿼리 생성 시 로딩 그래프를 붙여 JPA 구현체가 필요한 조인 생성 | JPQL이 직접 조인을 포함하므로 SQL이 그에 맞게 생성됨 |
| **재사용성** | 메서드 단위로 간단히 반복 사용 가능 | 동일 로딩이 필요할 때마다 JPQL을 반복 작성 |
| **가독성** | "무엇을 함께 로딩하는가"가 선언적으로 드러남 | 쿼리 본문이 길어질수록 가독성 저하 가능성 있음 |
| **이식성** | Spring Data 의존 | JPA 표준 문법 |
| **페이징과 궁합** | ToOne에는 안전, ToMany는 행 중복으로 주의 필요 | ToMany 관계에서 fetch join은 DB 레벨 페이징 불가 |

---

### **4️⃣ 딥다이브 - 즉시 로딩(Eager)과 지연 로딩(Lazy)의 차이점 및 성능 영향에 대해 서술하시오.**

#### **1\. 내가 만든 정의**

**즉시 로딩**

-   엔티티를 조회할 때 연관된 엔티티까지 한 번에 함께 조회하는 방식

**지연 로딩**

-   엔티티를 실제로 사용할 때 쿼리를 실행해서 조회하는 방식

#### **2\. 세부 내용**

**(1) 즉시 로딩**

**\- 정의**

-   엔티티를 조회할 때 연관된 엔티티까지 한 번에 함께 조회하는 방식
-   JPA가 JOIN을 자동으로 사용해서 관련 데이터를 전부 불러옴

**\- 장점**

-   연관 데이터 즉시 함께 가져오므로 코드가 간단하고 직관적

**\- 단점**

-   불필요한 조인으로 성능 저하 가능
    -   모든 연관 데이터를 한 번에 불러오므로, 사용하지 않는 데이터까지 함께 조회함
-   실무에서 거의 비추천
    -   대부분 지연 로딩을 기본으로 두고, fetch join이나 @EntityGraph를 사용해 제어함

**(2) 지연 로딩**

**\- 정의**

-   연관된 엔티티는 프록시로 먼저 채워두고, 실제로 접근하는 시점에 쿼리를 실행하여 데이터를 조회함
-   처음에는 실제 데이터가 아닌 프록시만 존재하고, getter 호출 시 Hibernate가 DB에 접근함

**\- 장점**

-   필요한 시점에만 쿼리를 실행하여 불필요한 데이터 조회를 방지하고 성능 최적화에 유리함
-   실무에서 기본 설정으로 권장

**\- 단점**

-   LazyInitializationException 발생 가능
-   N+1 문제 발생 가능
    -   연관된 엔티티를 실제 사용할 때 쿼리를 실행하기 때문에, 반복문 등에서 연관 데이터를 여러 번 접근하면 매번 쿼리가 발생함

> **❓ LazyInitializationException**  
> 영속성 컨텍스트가 닫힌 후에, 지연 로딩된 프록시 객체에 접근할 때 발생하는 예외  
> 즉, 세션이 닫혀 있어서 Hibernate가 DB에서 데이터를 가져올 수 없을 때 생기는 예외

**(3) N+1 문제**

**\- 정의**

-   한 번의 조회 이후, 연관된 엔티티를 조회하기 위해 추가로 N번의 쿼리가 실행되는 비효율적인 상황
-   한 번(1)의 메인 쿼리로 게시글을 가져오고, 이후 각 게시글의 댓글을 조회하기 위해 N번의 추가 쿼리가 실행되는 것

**\- 원인**

-   JPA가 연관 데이터를 한 번에 가져오지 않고, 엔티티마다 따로 SELECT를 실행하기 때문에 발생함

**\- 즉시 로딩도 N+1 문제 발생 가능**

-   JPA는 “즉시 함께 가져와야 한다”는 규칙만 정의하고, 실제 JOIN으로 가져올지, 별도의 SELECT로 가져올지는 구현체(Hibernate)가 결정함
-   Hibernate는 @ManyToOne 같은 단일 관계는 JOIN으로 처리하지만, @OneToMany 같은 컬렉션 관계는 중복을 피하기 위해 각 엔티티마다 별도의 SELECT를 실행

**(4) N+1 문제 해결 방법**

**\- Fetch Join**

-   정의
    -   JPQL에서 join fetch 키워드를 사용하여 연관된 엔티티를 한 번의 쿼리로 함께 조회하는 방식
    -   JPA의 지연 로딩을 우회하여 즉시 조인으로 모든 데이터를 미리 가져옴
-   장점
    -   쿼리 1번으로 모든 연관 데이터 조회 가능하여 N+1 완전 해결
    -   SQL 조인을 사용하므로 DB 접근 횟수가 최소화됨
-   단점
    -   컬렉션((@OneToMany) 페이징 불가
        -   데이터 중복으로 인해 JPA가 페이지 계산을 하지 못함
    -   복잡한 엔티티 구조에서 여러 Fetch Join을 쓰면 데이터 중복, 카테시안 곱 발생 가능

**\- @EntityGraph**

-   정의
    -   Spring Data JPA에서 제공하는 어노테이션으로, JPQL을 수정하지 않고도 Fetch Join과 동일하게 연관된 엔티티를 한 번의 쿼리로 함께 조회할 수 있는 방식
    -   내부적으로는 Fetch Join처럼 동작하지만, JPQL 대신 코드(어노테이션) 수준에서 조회 범위를 지정함
-   장점
    -   JPQL 변경 없이 깔끔하게 사용 가능
    -   코드 가독성 높고 유지보수 쉬움
    -   한 번의 쿼리로 N+1 해결 가능
-   단점
    -   여러 관계를 한 번에 가져오는 복잡한 조합은 어려움
    -   동적 쿼리에는 사용이 까다로움

**\- @BatchSize**

-   정의
    -   Hibernate 전용 기능
    -   지연 로딩(Lazy Loading) 시 여러 엔티티의 연관 데이터를 한 번의 쿼리에서 IN 절로 묶어(batch) 조회하는 방식
    -   한 번에 여러 건을 묶어서 로딩해 N+1 문제를 완화함
-   장점
    -   IN 절을 활용하여 여러 엔티티의 연관 데이터를 한 번에 로딩
        -   N+1 문제를 크게 줄임 (예: 10건씩 묶어서 1쿼리로 처리)
    -   Fetch Join처럼 중복 데이터 문제 없음
    -   페이징과 함께 사용 가능 (Fetch Join의 단점을 보완)
-   단점
    -   여러 번의 배치 쿼리로 처리
    -   여전히 DB와 네트워크 간 왕복은 발생 가능
    -   Hibernate 전용 기능이라 JPA 표준 아님

**(5) Fetch Join VS 일반 Join**

**일반 Join**

-   단순히 조건 필터링용 조인

**Fetch Join**

-   연관 엔티티를 함께 로딩하는 조인
-   한 번의 쿼리로 모든 데이터를 가져와 N+1 문제를 해결
-   컬렉션 페이징이 불가능
