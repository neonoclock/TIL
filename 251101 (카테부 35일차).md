## **🧠 회고**

11월 첫 시작

프론트엔드 강의 첫 시작

자바스크립트 오랜만에 하려니까 너무 어렵다... 그래도 열심히 해야한다! 마음을 다잡아야지

## **🪽 오늘의 다짐**

1\. 하면 된다 

2\. 모른다는 것을 인지했으니 그 모름을 앎으로 채우면 된다 파이팅

---

## **📝 Today I Learned**

### **1️⃣ 객체**

#### **1\. 정의**

\- 프로그래밍에서 속성과 기능을 가진 독립적인 데이터 단위

\- 원시 타입(숫자, 문자열, 불리언, null, undefiend, Symbol)을 제외한 나머지 값들

\- key와 value로 구성된 property(속성)의 집합

> **❓ 원시 타입**  
> \- 더 이상 나눌 수 없는 가장 기본적인 데이터 타입  
> \- 값 자체를 저장  
> \- 불변성을 가짐

> **❓ 불변성**  
> \- 한 번 생성된 값(데이터)이 변경되지 않고, 변경이 필요할 경우 새로운 값을 생성하는 성질

#### **2\. 사용 이유**

\- 데이터와 그 데이터 관련 연산을 묶어 관리하기 위함

#### **3\. 사용 방법**

\- 키-값 쌍을 사용해 데이터를 저장하고, 점 표기법이나 대괄호 표기법으로 해당 데이터에 접근하거나 수정

**(1) 객체 리터럴 사용**

\- 가장 간단하고 직관적

\- {}를 사용해 객체 생성

\- 내부에 프로퍼티와 메서드 정의

> **❓ property**  
> \- 객체의 고유한 속성으로, 이름(key)와 값(value)으로 구성되어 데이터를 표현하는 요소  
> \- 객체 내부에서 값을 저장하는 변수  
> \- 객체의 상태나 속성 나타냄

```
const person = {
  name: "혜원",
  age: 22,
  hobby: "코딩"
};
```

\-> person : 객체 (object)

\-> name, age, hobby : 프로퍼티 이름(key)

\-> "혜원", 22, "코딩" : 프로퍼티 값(value)

> **❓ Method**  
> \- 객체에 속한 함수로, 해당 객체의 프로퍼티(데이터)를 사용하거나 조작하는 동작(기능)을 수행함  
> \- 객체 내부에서 함수를 값으로 가지는 프로퍼티를 의미  
> \- 객체의 동작이나 기능 정의

```
const person = {
  name: "혜원",
  age: 22,
  // 👇 이게 바로 메서드!
  sayHello: function() {
    console.log("안녕! 나는 " + this.name + "이야!");
  }
};

person.sayHello(); // 안녕! 나는 혜원이야!
```

\-> sayHello : 객체의 행동 (메서드)

👉🏻 프로퍼티는 데이터, 메서드는 행동

**(2) 생성자 함수 사용**

\- 생성자 함수

-   new 키워드와 함께 호출되어 객체를 생성하고, 그 객체의 초기 상태(프로퍼티)와 행동(메서드)를 설정하기 위한 함수
-   객체를 생성하기 위한 특별한 함수
-   이름을 대문자로 시작하는 것이 관례
-   주로 비슷한 구조를 가진 객체를 여러 번 생성할 때 사용함
-   객체를 생성할 때는 반드시 new 키워드 사용

```
function 생성자이름(매개변수) {
    this.프로퍼티명 = 매개변수;
    this.메서드명 = function() {
        // 메서드 동작 정의
    };
}

const 객체 = new 생성자이름(인자);
```

```
function Person(name, age) {
  this.name = name; // 새 객체의 name 프로퍼티
  this.age = age;   // 새 객체의 age 프로퍼티
  this.sayHello = function() {
    console.log(`안녕! 나는 ${this.name}이야.`);
  };
}

const person1 = new Person("혜원", 22);
const person2 = new Person("민수", 25);

person1.sayHello(); // 안녕! 나는 혜원이야.
person2.sayHello(); // 안녕! 나는 민수야.
```

\- new 키워드 사용

\-> 새로운 객체가 자동으로 만들어짐

\-> this가 그 새 객체를 가리킴

\-> 그 객체에 속성과 메서드가 붙음

**(3) 클래스 사용**

\- 객체 지향 문법

\- 객체를 생성하기 위한 설계도로, 공통된 속성(프로퍼티)과 동작(메서드)를 정의하며 new 키워드로 인스턴스를 만들어 낼 수 있다.

\- 생성자 함수를 더 명확하고 간결하게 사용할 수 있도록 해줌

\- 클래스 선언 후 객체를 생성할 때는 마찬가지로 new 키워드 사용

```
class 클래스명 {
    constructor(매개변수) {
        this.프로퍼티명 = 매개변수;
    }

    메서드명() {
        // 메서드 동작 정의
    }
}

const 객체 = new 클래스명(인자);
```

```
class Person {
  constructor(name, age) {
    this.name = name; // 프로퍼티
    this.age = age;
  }

  sayHello() { // 메서드
    console.log(`안녕! 나는 ${this.name}이야.`);
  }
}

const person1 = new Person("혜원", 22);
person1.sayHello(); // 안녕! 나는 혜원이야.
```

| **생성 방법** | **장점** | **단점** | **사용 시점** |
| --- | --- | --- | --- |
| **객체 리터럴** | \- 가장 간단하고 직관적   \- 단일 객체 빠른 생성 및 초기화 가능 | \- 코드 중복 가능성   \- 프로토타입 상속 설정 어려움 | \- 단순한 구조의 단일 객체가 필요할 때 |
| **생성자 함수** | \- 유사 객체 여러 개 생성 가능 | \- 문법적으로 복잡하고 구식일 수 있음   \- new 키워드 누락 시 버그 발생 가능 | \- 유사한 객체를 여러 개 생성해야 할 때 |
| **클래스**  | \- 객체 지향 프로그래밍 지원   \- 클래스 상속 간단 및 명확   \- 구조적이고 명확한 문법 제공 | \- 이전 자바스크립트 버전에서 사용 어려움 | \- 객체 지향 프로그래밍 활용 시   \- 큰 규모의 프로젝트나 팀 작업 시 |

#### **4.  Function 동적 추가하는 법**

\- 이미 만들어진 객체나 함수에 나중에 기능(함수)을 더 붙이는 방법

👉🏻 객체가 생성된 후 속성이 추가되거나 삭제되면 엔진은 객체 모양이 바뀌었다고 판단하고 코드를 다시 분석하고 최적화

👉🏻 성능 저하

\- 객체는 하나의 생성 시점에 모든 속성을 정의하고 구조를 바꾸지 않는 것이 좋음

\- 객체의 상태를 변경해야 한다면, 원본을 직접 수정하기보단 새로운 객체를 만듦 

👉🏻 불변성을 유지하기 위함

#### **5\. getter/setter, Private 변수**

\-  외부 스코프에서 내부 스코프의 변수에 접근하지 못하도록 함

\- 데이터의 안전한 관리 목적

\- 잘못된 참조 차단

\- # 붙으면 프라이빗 필드

👉🏻 클래스 내부에서만 접근, 외부에서는 접근 불가

👉🏻 캡슐화

---

### **2️⃣  네임스페이스**

#### **1\. 정의**

\- 프로그래밍에서 변수, 함수, 클래스 등의 식별자(이름)가 충돌하지 않도록 그룹화하는 방법

\- 전역 공간에서 이름이 충돌하는 것을 방지하기 위해, 관련된 변수와 함수들을 하나의 객체 안에 묶어 관리하는 방법

#### **2\. 사용 이유**

**(1) 변수명 충돌 방지**

\- 대규모 프로그램이나 여러 라이브러리와 함께 작업할 때, 같은 이름의 변수나 함수가 중복되어 충돌하는 것을 막아줌

**(2) 코드 구조화**

\- 관련된 기능과 데이터를 함께 그룹화하여 코드를 더욱 체계적으로 구성 가능

\- 유지보수성 향상

**(3) 가독성 및 유지보수성 향상**

\- 코드의 어떤 부분이 어떤 모듈에 속하는지 명확하게 구분할 수 있어, 코드를 이해하고 관리하기 쉬워짐

#### **3\. 사용 방법**

\- 객체를 선언함으로써, 엔티티를 포함하는 네임스페이스를 생성

```
const Game = {
  player: {
    name: "혜원",
    level: 10
  },
  start: function() {
    console.log("게임 시작!");
  },
  end: function() {
    console.log("게임 종료!");
  }
};

Game.start(); // 게임 시작!
```

\- Game.player , Game.start(), Game.end()

👉🏻Game이라는 공간 안에서 안전하게 관리됨

---

### **3️⃣ 프로그래밍 패러다임**

#### **1\. 정의**

\- 프로그램을 구축하는데 사용되는 기본적인 접근 방식

#### **2\. 사용 이유**

\- 코드를 체계적이고 재사용에 있어 효율적으로 작성할 수 있도록 하기 위함

#### **3\. 사용 방법**

\- 문제와 특성에 맞게 적합한 패러다임(객체지향, 함수형 등)을 선택해 코드를 구조화

**(1) 절차 지향 프로그래밍**

\- 초기 프로그래밍의 패러다임

\- 명령어의 연속적인 실행으로 프로그램 구성

\- 명령어의 순서에 따라 데이터 조작, 변형하는 방식으로 코드 작성

\- C언어

**(2) 객체 지향 프로그래밍**

\- 객체라는 독립적인 단위를 이용해 프로그래밍을 구성하는 패러다임

\- 데이터와 해당 데이터를 처리하는 메서드를 묶어서 객체로 만들고, 이 객체들 간 상호작용으로 프로그래밍을 구현

\- Java, C++, Python

**(3) 함수형 프로그래밍**

\- 함수를 일급 객체로 취급하고, 상태와 가변 데이터를 피하며, 순수 함수를 중심으로 프로그램을 작성하는 패러다임

\- 부작용을 최소화

\- 데이터 불변성 유지

\- 예측 가능한 안정적인 코드 작성

\- JavaScript

-   절차 지향: 컴퓨터가 수행 할 작업 시간 순서대로 나열
-   객체 지향: 데이터와 기능을 객체라고 하는 하나의 단위로 묶어서 관리
-   함수형: 부수 효과가 없는 순수 함수들을 조합해서 프로그램을 만드는 방식

\=> 자바스크립트는 멀티 패러다임 언어

---

### **4️⃣ 함수형 패러다임 - 함수**

#### **1\. 정의**

\- 재활용하기 위해 묶어놓은 코드들의 집합

\- 어떤 일을 수행하는 명령들을 하나로 묶어서 이름을 부여하고, 필요할 때마다 그 함수를 호출해서 사용

#### **2\. 사용 이유**

\- 반복되는 코드 또는 여러 곳에서 사용하는 코드를 하나의 기능으로서 묶어 필요한 곳에 재사용하기 위함

#### **3\. 사용 방법**

\- 특정 작업을 수행하는 코드 블록을 함수로서 정의하고, 필요할 때 해당 함수를 호출하여 사용

**(1) 함수 선언문**

\- function 키워드를 사용하여 이름이 있는 함수를 정의

\- 호이스팅으로 함수를 코드의 선언 위치와 상관없이 호출 가능

> **❓ 호이스팅**  
> \- 함수 전체를 스코프의 최상위로 끌어올려지는 것  
> \- 자바스크립트 엔진이 코드를 실행하기 전에, 변수와 함수 선언을 스코프 최상단으로 끌어올린 것처럼 인식하는 현상  
> \- 자바스크립트가 코드를 읽기 전에 변수나 함수를 미리 알고 있는 것

> **❓ 스코프**  
> \- 변수나 함수에 접근할 수 있는 범위(영역)  
> \- 변수가 살아 있고, 쓸 수 있는 공간  
> \- 전역 스코프, 지역 스코프, 블록 스코프

```
sayHello(); // ✅ 가능! (호이스팅 때문에 위에서도 호출됨)

function sayHello() {
  console.log("안녕!");
}
```

**(2) 함수 표현식**

\- 함수를 하나의 값처럼 변수에 할당하는 방식

\- 변수에 함수를 담아 사용할 수 있으며, 호이스팅 시 선언만 끌어올려져 선언 이후에만 호출 가능

\- 함수를 변수에 할당하는 방식으로 정의

\- 함수는 변수에 할당되기 전에는 사용 불가능

\- 변수 호이스팅이 발생하지만, 실제 함수가 할당되기 전까지는 undefined 상태

> **❓ 변수 호이스팅**  
> \- 자바스크립트 엔진이 코드를 실행하기 전에 변수 선언을 스코프의 최상단으로 끌어올린 것처럼 인식하는 현상  
> \- 자바스크립트가 코드를 실행하기 전에 변수의 존재를 미리 알고 있는 현상

> **❓ undefined 상태**  
> \- 변수가 선언되었지만 아직 값이 할당되지 않은 상태  
> \- 자바스크립트 엔진이 자동으로 부여하는 초기값  
> \- 변수는 만들어졌지만, 아직 아무 값도 들어가지 않은 상태

```
const sayHello = function() {
  console.log("안녕!");
};

sayHello(); // 안녕!
```

**(3) 화살표 함수**

\- this 바인딩을 가지지 않아 외부 스코프의 this를 그대로 사용하며, 주로 짧고 단순한 함수 작성에 사용됨

\- function 키워드 없이 => 기호를 사용하여 함수를 더욱 간결하게 표현할 수 있음

\- 화살표 함수는 중괄호{} 와 return 키워드를 생략할 수 있어, 코드를 더욱 간단하게 작성 가능

\- 자신만의 this를 가지지 않아, 외부 스코프의 this를 그대로 사용하게 됨

```
// 기존 함수
const sayHello = function(name) {
  return "안녕, " + name + "!";
};

// 화살표 함수
const sayHello = name => `안녕, ${name}!`;

console.log(sayHello("혜원")); // 안녕, 혜원!
```

**(4) 함수의 정의 방식**

\- 인자 전달

-   함수를 호출할 때 기본적인 인자를 전달하는 방식
-   함수는 ,로 구분된 여러 인자를 받을 수 있음
-   이 인자들은 기본 자료형이나 객체, 배열 등 어떤 타입의 값이든 받을 수 있음

\- 객체 전달

-   객체를 인자로 전달할 수 있음
-   함수 내부에서는 객체의 속성을 사용하여 작업 수행 가능
-   전달해야할 인자값이 많을 때 유용하게 사용 가능

\- 객체 반환

-   함수가 여러 값을 한 번에 반환해야 할때 반환되는 객체 내에서 필요한 데이터를 그룹화
-   이를 통해 함수의 결과를 편리하게 처리 가능

\- 배열 반환

-   함수가 여러 값을 반환해야 할 때 배열 사용 가능

#### **4\. 구조 분해 할당**

**(1) 정의**

\- 배열이나 객체의 속성을 분해하여 그 값을 개별 변수에 담을 수 있게하는 JS 문법

\- 데이터 구조에서 필요한 항목만 빠르게 추출하고, 코드를 간결하게 작성할 수 있도록 도움

**(2) 사용 이유**

\- 가독성 향상: 필요한 데이터만 명시적으로 추출하여 코드 이해 쉬움

\- 코드 간결성: 복잡한 데이터 접근을 단순화하여 한 줄로 표현 가능

\- 오류 감소: 데이터 경로 오류를 줄이며, 중첩된 구조에서 유용

\- 기본값 설정: 존재하지 않는 속성에 대해 기본값을 설정, 코드의 안정성 향상

#### **5\. useCallback**

**(1) 정의** 

\- 리액트의 훅 중 하나

\- 함수를 메모이제이션 하여 컴포넌트가 다시 렌더링될 때 불필요하게 새 함수가 만들어지는 것을 방지

**(2) 사용 이유**

\- 리액트 컴포넌트는 state나 props가 바뀌면 다시 렌더링 됨

👉🏻 컴포넌트 안에 있던 함수도 새로 만들어짐

👉🏻 불필요한 렌더링과 성능 저하

👉🏻useCallback으로 이전 함수 그대로 재사용 가능

---

### **5️⃣ 함수형 패러다임 - 순수 함수**

#### **1\. 정의**

\- 주어진 입력이 동일하다면 항상 같은 값을 리턴하는 함수

\- 함수가 입력 파라미터와 내부 로직, 반환 값으로만 구성되어야 함

#### **2\. 특징**

**(1) 동일한 입력에 대해 항상 동일한 출력을 반환해야함**

\- Deterministic

\- 예측 가능

\- 몇 번을 계산해도 똑같음

**(2) 함수 외부에 어떠한 영향도 주어서는 안됨**

\- No Side Effexts

> **❓ 함수 외부**  
> \- 함수 스코프 바깥의 모든 세상  
> \- 전역 변수, DOM, 서버, 데이터베이스, console.log로 찍는 행위까지 모두 사이드 이펙트에 해당

> **❓ Side-Effects (부수 효과)**  
> \- 함수가 실행될 때 함수 외부의 상태를 변경하거나 외부 상태에 의존하여 결과를 산출하는 것  
> \- 전역 변수의 값을 수정하거나, 입력 파라미터가 아닌 외부 값을 읽는 행위  
> \- 함수의 예측 가능성을 떨어뜨리고 디버깅을 어렵게 만듦

> **❓ 부수 효과 문제점**  
> \- 디버깅의 어려움  
> \- 코드 재사용성 저하  
> \- 병렬 처리의 제한  
> \- 유지 보수의 복잡성 증가

#### **3\. 사용 이유**

**(1) 결정적 동작**

\- 주어진 입력에 대해 항상 동일한 출력을 반환하기 때문에, 주어진 입력이 동일하다면 동일한 결과 값 보장 가능

\- 어떠한 외부 상태에도 의존하지 않고, 외부 변수나 상태의 변경에 의존적이지 않음

**(2) 부작용이 없는 동작**

\- 오직 입력값에만 의존해 작업을 진행해 연쇄적으로 발생할 수 있는 부작용을 원칙적으로 차단함

#### **4\. 사용 방법**

\- 외부 상태에 의존하지 않고, 주어진 입력에 대해 항상 동일한 출력을 반환하는 함수를 정의하여 사용

---

### **6️⃣ 함수형 패러다임 - 일급 함수**

-   함수 -> 함수의 기본적인 개념
-   순수 함수 -> 좋은 함수의 조건
-   일급 함수 -> 자바스크립트에서 함수를 얼마나 특별하게 다루는지

#### **1\. 정의**

\- 일급 함수는 프로그래밍 언어에서 함수를 일급 시민으로 취급하여, 다른 변수처럼 사용할 수 있게 함

\- 자바스크립트에서 함수가 값처럼 취급될 수 있는 특성

\- 함수를 변수에 저장하거나, 인자로 전달하거나, 다른 함수의 반환값으로 사용할 수 있음을 뜻함

#### **2\. 사용 이유**

**(1) 코드의 재사용성 향상**

\- 함수를 변수에 저장하거나 다른 함수로 전달

\- 중복 코드를 줄이고, 프로젝트의 일관성 유지

**(2) 고차 함수 사용**

\- 함수를 다른 함수의 인자로 전달하거나 결과로 반환

\- 데이터 처리와 이벤트 처리에서 유용

> **❓ 고차 함수**  
> \- 함수를 인자로 받거나, 함수를 반환하는 함수  
> \- 함수를 다루는 함수

**(3) 유연한 함수 처리**

\- 함수를 데이터 구조에 저장하고 필요할 때 사용

\- 이벤트 리스너나 콜백 함수 관리에 유용

**(4) 추상화와 캡슐화 용이**

\- 세부 구현을 숨기고 필요한 인터페이스만 제공

\- 복잡한 간단한 함수 호출로 처리 가능

#### **3\. 사용 방법**

**(1) 함수를 변수에 할당 (함수 표현식)**

\- 함수를 일반 변수에 할당함으로써, 그 함수를 값처럼 다룰 수 있음

**(2) 함수를 다른 함수의 인자로 전달**

\- 함수를 다른 함수의 인자로 전달하여, 그 함수 내에서 호출 가능

**(3) 함수에서 다른 함수를 반환**

\- 함수가 다른 함수를 반환하도록 함으로써, 동적으로 함수를 생성하고 조작 가능

**(4) 고차 함수를 사용한 간단한 컴포지션**

\- 함수를 조합하여 더 복잡한 동작 구성 가능
