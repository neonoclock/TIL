## **🧠 회고**

프로젝트(과제)를 진행하다보니 복습에 소홀했던 것 같다. 가장 기초적인 부분인 만큼 열심히 해야겠다.

JS 기초강의도 듣고 카테부 들어왔을 때 다짐했던 기초부터 탄탄한 개발자가 되기 위해 열심히 해야겠다... 진짜로!

## **🪽 오늘의 다짐**

1\. 복습을 열심히 하자

2\. 체력을 기르자

---

## **📝 Today I Learned**

### **1️⃣ 비동기 - 콜백 (Callback) 함수**

#### **1\. 정의**

\- 다른 함수에 인자로 전달되어, 그 함수의 내부에서 실행되는 함수

👉🏻 A함수의 파라미터로 넘겨지고, A 함수가 원하는 시점에 실행시키는 함수

\- 내가 지금 바로 실행하는 함수가 아니라, 다른 함수에게 맡겨 놓고, 그 함수가 원하는 시점에 불러주는 함수

(1) 동기적 콜백 함수

\- 즉시 실행되는 콜백

\- 함수가 호출되는 순간 바로 콜백도 실행됨

(2) 비동기적 콜백 함수

\- 나중에 실행되는 콜백

\- 결과가 준비됐을 때 Web API / Node API가 실행해주는 콜백

\- 콜백은 비동기가 아님

\- 단지 특정 시점에 호출되는 함수 (어떤 콜백은 바로 실행, 어떤 콜백은 나중에 실행)

\- JS의 비동기 작업을 콜백을 사용해서 결과 처리

#### **2\. 사용 이유**

(1) 비동기 작업의 순서를 제어하기 위함

\- 데이터가 준비된 후에만 특정코드가 실행되도록 만들기 위해

(2) 블로킹 없이 비동기 작업을 처리하기 위함

\- JS는 싱글스레드라 멈추면 UI가 다 멈추기 때문에

\- 비동기로 맡기고 콜백으로 결과만 받아 처리

#### **3\. 사용 방법**

\- 비동기 작업을 처리하는 함수에 결과를 처리할 함수(콜백)을 인자로 전달

👉🏻 비동기 작업이 끝난 시점에 콜백을 실행하여 결과를 다루는 방식

**(1) 기본 콜백 함수**

\- 비동기 작업을 수행하는 함수 정의

👉🏻 비동기 작업 완료 후 결과를 처리할 콜백 함수 작성

👉🏻 비동기 함수 호출 시 콜백 함수를 인자로 전달

👉🏻 비동기 작업이 완료되면 Web API가 콜백을 큐에 등록

👉🏻 이벤트 루프가 콜스택으로 올려 콜백 실행

#### **4\. 콜백 함수 종류**

**(1) 배열 메서드에서 사용하는 콜백함수**

\- 배열의 각 요소를 처리할 때, 요소마다 수행할 로직을 콜백으로 전달하는 방식

\- map(), filter(), reduce(), forEach()

\- 배열 요소를 반복하며 콜백 실행

\- 요소 변형, 필터링, 누산 등 다양한 기능 제공

\- 동기 콜백 -> 즉시 실행됨

**(2) 함수를 반환하는 함수**

\-함수 안에서 새로운 함수를 반환하고, 그 내부 상태를 클로저로 유지하는 형태

\- 내부 데이터를 감춘 상태로 유지 (캡슐화)

\- 미리 설정된 로직 재사용

\- 독립적인 실행 흐름 구성 가능

**(3) 함수 컴포지션**

\- 여러 개의 작은 함수를 콜백처럼 연결해서, 하나의 큰 로직을 만드는 방식

\- 함수를 콜백으로 전달하여 순차적으로 결합해 새로운 흐름을 만드는 것

\- 로직을 단순하고 모듈화된 상태로 유지

\- 복잡한 처리 과정을 간결하게 조합 가능

\- 함수형 프로그래밍에서 매우 빈번히 사용

#### **5\. 콜백 지옥**

\- 비동기 콜백을 계속 중첩해서 사용하면서 코드 구조가 계단식으로 깊어지는 현상

**(1) 콜백 지옥이 발생하는 상황**

\- 비동기 작업의 결과가 다음 비동기 작업의 입력으로 필요할 때

\- 콜백 안에서 또 콜백 또 콜백 ... 식으로 계속 중첩될 때

**(2) 문제점**

\- 코드 가독성 저하

\- 유지보수 어려움

\- 흐름 제어 난이도 증가

[##_Image|kage@cpWPLB/dJMcacuE5au/AAAAAAAAAAAAAAAAAAAAAN7NxCxMO3xMVPNfZxg5KdCdcj3-FMZJ7w8fdyBlJNu2/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1764514799&amp;allow_ip=&amp;allow_referer=&amp;signature=UCrRZKDo1sqEL2J0LH%2BgP3bm6iQ%3D|CDM|1.3|{"originWidth":962,"originHeight":674,"style":"alignCenter"}_##]

 (ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ)

---

### **2️⃣ 비동기 - 프로미스(Promise)**

#### **1\. 정의**

\- 비동기 작업의 성공 또는 실패 결과를 처리하기 위한 객체

\- 비동기 연산이 완료된 이후의 결과를 명확하게 처리할 수 있도록 도와주는 객체

\- 대기, 성공, 실패 상태 가짐

👉🏻 비동기 작업의 결과에 따라 상태 결정

\- .then(), .catch() 등을 통해 결과 명확히 처리 가능

\- 콜백 지옥 방지 

👉🏻 코드의 가독성, 유지보수성 높임

\- 여러 비동기 작업을 체인 형태로 연결하거나 병렬로 효율적 관리 가능

\- 콜백을 대체하여 보다 깔끔하고 효율적인 비동기 처리 가능

#### **2\. 사용 이유**

(1) 콜백 지옥 문제 해결

\- 중첩된 콜백 함수로 인해 발생하는 콜백 지옥을 방지

\- 코드의 가독성과 유지보수성 높임

(2) 명확한 예외 처리 방식 제공

\- .then(), .catch()를 이용하여 명확하게 성공과 실패를 구분하여 처리 가능

\- 오류 처리의 명확성이 높아짐

(3) 비동기 작업의 체이닝 용이성

\- 여러 비동기 작업을 연속적으로 연결할 수 있음

\- 비동기 코드 흐름을 더욱 직관적이고 간단하게 관리 가능

(4) 병렬 비동기 작업 처리 가능

\- Promise.all()등을 통해 서로 독립적인 비동기 작업을 동시에 처리

\- 전체 결과 편하게 관리 가능

#### **3\. 사용 방법**

\- 생산자 - 소비자 패턴

👉🏻 생성자 역할: new Promise((resolve, reject) => {...})는 비동기적으로 데이터 로드 작업을 생산

👉🏻 소비자 역할: 생성된 프로미스 객체의 결과는 .then(), .catch(), .finally() 메서드를 통해 소비됨

**(1) 생성방식**

**\- 선언 방식**

-   프로미스 객체를 미리 한 번 생성해 놓고 여러 번 재사용할 때 사용
-   초기 설정이나 한 번만 수행되는 비동기 작업에 적함
-   resolve
    -   비동기 작업이 성공적으로 완료된 경우 호출됨
    -   프로미스 상태를 성공(fullfilled)으로 변경
-   reject
    -   비동기 작업이 실패했을 때 호출됨
    -   프로미스 상태를 실패(rejected)로 변경

**\- 함수 형식**

-   호출할 때마다 새로운 프로미스 객체를 생성하여 독립적인 비동기 작업 수행할 때 사용
-   반복적으로 수행해야 하는 비동기 작업에 적합

| **구분** | **선언 즉시 생성하는 방식** | **함수로 생성하는 방식** |
| --- | --- | --- |
| **프로미스 생성 시점** | 선언 즉시 1회만 생성 | 호출할 때마다 매번 새로 생성 |
| **프로미스 재사용** | 같은 프로미스를 여러 번 재사용 | 호출 시마다 새로운 프로미스 생성 |
| **활용 사례** | 초기 설정이나 한 번만 실행되는 작업 | 반복적으로 호출되는 작업 |
| **결과** | 항상 같은 결과 반환 | 호출마다 독립적 결과 반환 |

#### **4\. Promise 상태**

**(1) 대기 (pending)**

\- 프로미스가 생성되어 비동기 처리가 아직 완료되지 않은 상태

\- 프로미스가 결과를 기다리고 있음

\- 프로미스는 작업이 완료되기 전까지 이 상태에 머무름

\- 작업이 진행중임을 의미

  
**(2) 성공 (fullfilled)**

\- 비동기 처리가 성공적으로 완료되어, 프로미스가 결과 값을 반환한 상태

\- 비동기 작업이 성공적으로 마무리되었을 때 발생함

\- resolve 함수가 호출되면 프로미스는 성공상태 됨

👉🏻 이 함수를 통해 전달된 값이 프로미스의 결과가 됨

**(3) 실패 (rejected)**

\- 비동기 처리 중 오류가 발생하거나 실패하여 프로미스가 에러 원인을 반환한 상태

\- '실패' 상태는 비동기 작업 중 문제가 발생했을 때 나타남

\- reject 함수가 호출되면 프로미스는 실패 상태됨

👉🏻 reject에 전달된 값이 실패의 원인으로 처리됨

> 풀필드나 리젝트 상태가 되면 그 상태가 절대 변하지 않음  
> \-> 불변성, 비동기 코드의 안정석

#### **5\. Promise Chain**

**(1) 정의**

\- 비동기 작업을 순차적으로 연결하여 실행하는 방식

**(2) 특징**

\- 이전 작업의 결과가 다음 작업의 입력으로 필요한 경우 사용

\- .then() 체인을 사용하여 흐름을 수직으로 평탄하게(flat) 작성

\- 하나의 .catch()로 전체 에러 처리 가능

**(3) then 동작 규칙**

\- 일반값을 반환하면 다음 then이 즉시 그 값을 받음

\- 또 다른 프로미스를 반환하면 다음 then이 그 프로미스가 끝날때까지 기다렸다가 그 프로미스를 결과값으로 받음

#### **6\. Promise.all()**

\- 여러 비동기 작업(프로미스)를 병렬로 실행하고 모든 프로미스가 성공했을 때 한 번에 결과 처리할 수 있게 해주는 방식

**(1) 특징**

\- 모든 프로미스가 fulfilled 되어야 성공

\- 하나라도 reject되면 즉시 reject

\- 결과는 모든 결과를 배열로 반환

**(2) 언제 사용**

\- 모든 데이터가 필요하고, 하나라도 빠지면 안되는 상황

\- 쇼핑몰 메인 페이지

#### **7\. Promise.allSettled()**

\- 모든 프로미스가 완료될 때까지 기다린 후, 성공/실패를 포함해 모든 결과 반환

**(1) 특징**

\- 실패하거나 성공해도 상관없이 모든 작업이 끝나면 resolve

\- 절대 reject되지 않음

**(2) 언제 사용**

\- 일부 실패해도 되고, 개별 성공/실패 여부를 처리해야 하는 경우

#### **8\. Promise.any()**

\- 여러 프로미스 중 하나라도 가장 먼저 성공하면 성공으로 처리

**(1) 특징**

\- 가장 빨리 fulfilled 된 primise의 결과 반환

\- 모든 프로미스가 reject되면 AggregateError로 실패

**(2) 언제 사용?**

\- 여러 서버 중 가장 빠른 응답을 받고 싶을 때

---

### **3️⃣ 비동기 - Async / Await**

#### **1\. 정의**

**(1) Async**

\- 비동기 처리를 위해 항상 프로미스를 반환하는 함수 선언 키워드

\- async 키워드를 사용한 함수는 항상 프로미스를 반환하며, 반환 값이 프로미스가 아닐 경우 자동으로 프로미스 객체로 매핑되어 반환됨

\- async 함수로 선언된 함수는 내부 코드의 작업을 처리하기 위해 기본적으로 Promise 객체 반환

👉🏻 호출 시 비동기 작업을 처리한 후에 then, catch등을 사용하여 처리 흐름 연결 가능

👉🏻 함수 내부에서 반환된 값이 프로미스가 아닐 경우에는 자동으로 프로미스로 래핑되어 반환됨

**(2) Await**

\- 프로미스가 완료될 때까지 비동기 함수의 실행을 일시 중단 하고, 완료된 Promise의 결과를 반환하는 키워드

\- Await 키워드는 async 함수 내부에서만 사용할 수 있음

\- 프로미스 객체의 완료를 기다린 후 그 결과를 반환함

\- async 함수 내부에서만 사용할 수 있는 키워드

\- 프로미스 객체 완료를 기다려 그 결과를 반환

\- 프로미스가 완료될 때까지 함수의 실행을 멈춤

\- 완료된 프로미스의 결과를 반환함

👉🏻 비동기 함수의 실행 흐름을 동기적 방식으로 작성 가능

#### **2\. 사용 이유**

**(1) Async**

\- 비동기 작업을 더 직관적이고 동기적인 코드 흐름으로 작성하기 위함

\- 함수를 프로미스로 반환하는 비동기 함수로 만들어주는 문법

**(2) Await**

\- 코드가 프로미스의 완료를 기다리는 동안 다른 작업을 차단하지 않으면서 비동기 작업의 결과를 동기 코드처럼 처리하기 위함

\- 그 함수 안에서 프로미스의 결과가 나올때가지 동기 코드처럼 자연스럽게 기다리게 해줌

#### **3\. 사용 방법**

**(1) Async**

\- 함수 선언 앞에 async 키워드를 붙여 비동기 함수로 만듦

**(2) Await**

\- async 함수 내에서 프로미스 앞에 await 키워드 작성

> **Async는 반드시 Promise를 반환**  
> \- 함수 앞에 async를 붙이면, 함수는 무엇을 반환하든 ‘항상 Promise를 반환하는 함수’가 된다  
> \- 반환값이 처음부터 Promise라면 그대로 반환  
> \- Promise가 아닌 일반 값이라면 자동으로 Promise로 감싸서 반환
