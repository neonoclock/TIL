## **🧠 회고**
​
오늘은 딥다이브를 진행하고, 카카오 멘토분들이 오셔서 도구에 대한 강의와 멘토링(이력서)을 해주셨다.
​
보잘 것 없는 이력서지만 이 과정을 진행하며 차근 차근 채워나가 보려고 한다!
​
그리고 현업에서 사용하는 협업 도구들을 알아보고 직접 실습해보니 더 취업하고 싶다는 마음이 간절하게 드는 하루였다...
​
우선 사람들 앞에 나서서 차분하게, 그리고 논리적으로 당당하게 내가 하고 싶은 이야기들을 할 수 있도록 해야겠다는 생각이 들었다.
​
그리고 그 자신감은 아는 것만큼에서 나온다는 것을 절실하게 느꼈다... 
​
파이팅!
​
## **🪽 오늘의 다짐**
​
기초 복습부터 차근차근 다지는 믿을 수 있는, 믿고 맡길 수 있는 개발자가 되기 위해 더욱 노력해야겠다.
​
할 수 있다 파이팅
​
---
​
## **📝 Today I Learned**
​
**\* 멘토링 내용은 개인 노션에 따로 정리해두었다.** 
​
### **1️⃣ 딥다이브**
​
> **동기와 비동기의 차이, 그리고 블로킹과 논블로킹의 차이에 대해 설명해주세요.**
​
## **내가 만든 정의**
​
**동기**
​
-   작업 완료를 기다리고 다음 작업을 실행하는 순차 처리 방식
-   호출 순서 = 완료 순서
​
**비동기**
​
-   작업 완료를 기다리지 않고 다음 작업을 진행
-   결과는 콜백/Promise/이벤트로 나중에 전달받는 방식
​
**블로킹**
​
-   호출한 함수가 자기 일을 끝낼 때까지 제어권을 반환하지 않아 호출 측의 흐름을 멈추게 하는 방식
​
**논블로킹**
​
-   호출한 함수가 요청만 접수하고 즉시 제어권을 돌려줘서 호출 측의 흐름이 멈추지 않는 방식
​
**핵심 구분**
​
-   동기/비동기
    -   결과를 기다리나 / 나중에 통지 받나
-   블로킹 / 논블로킹
    -   **제어권**을 붙잡나 / 바로 돌려주나
​
---
​
## **세부 설명 (질문에 맞게 변형합니다)**
​
### **관점 정리**
​
-   동기 / 비동기
    -   순서와 결과 처리의 관점
    -   어떤 함수에게 일을 시켰을 때, 그 일이 끝나는 순서와 내 코드의 실행 순서가 일치하는지, 그리고 그 결과를 어떻게 처리하는지
-   블로킹 / 논블로킹
    -   제어권의 관점
        -   제어권: 코드를 실행할 수 있는 권리
    -   내가 어떤 함수를 호출했을 때 그 함수가 자기 일을 다 마칠 때까지 제어권을 돌려주지 않으면 블로킹
    -   요청만 받고 제어권을 즉시 돌려주면 논블로킹
​
### **동기**
​
(1) 정의
​
-   작업의 시작과 끝이 호출 순서와 일치하는 방식
-   앞의 작업이 끝나야만 다음 작업을 실행할 수 있음
​
(2) 특징
​
-   코드가 위에서 아래로 순서대로(직렬) 실행됨
-   결과가 반드시 준비되어야 다음 단계로 이동함
-   대부분의 프로그래밍 언어가 기본적으로 동기 방식
​
(3) 장점
​
-   흐름을 이해하기 쉽고 디버깅이 단순
-   예측 가능한 순서로 동작하여 사고하기 편함
-   의존 관계가 있는 로직(순차 작업)에 적합
​
(4) 단점
​
-   오래 걸리는 작업이 있으면 전체 흐름이 멈춤
-   I/O 중심 작업에서 비효율적
-   UI가 멈추거나 프리징 발생 가능
​
### **비동기**
​
(1) 정의
​
-   작업을 시켜놓고 기다리지 않고 다음 코드 실행
-   작업이 끝나면 콜백/Promise/Event로 결과를 알려줌
​
(2) 특징
​
-   작업 완료 시점이 호출 순서와 일치하지 않아도 됨
-   WebAPI, 이벤트 루프 등과 함께 동작함
-   병렬적 흐름으로 보이지만 실제로는 싱글스레드 + 비동기 시스템
​
(3) 장점
​
-   시간이 오래 걸리는 작업(I/O)에도 흐름이 멈추지 않음
-   자원 활용이 효율적
-   웹 UI가 부드럽고 반응성이 뛰어남
-   고성능 서버 개발 가능 (Node.js 모델)
​
(4) 단점
​
-   코드 흐름이 직관적이지 않을 수 있음
-   콜백 지옥 문제
-   동기식 에러 처리 방식과 다르고 디버깅이 어려울 때가 있음
​
### **블로킹**
​
(1) 정의
​
-   호출된 함수가 작업을 끝낼 때까지 제어권을 반환하지 않아 현재 흐름이 멈추는 방식
​
(2) 특징
​
-   제어권이 함수 내부에 머물러 있음
-   CPU 연산이 빠른 작업에서는 문제 없지만 네트워크, 파일 I/O 이슈가 큼
-   JS에서 블로킹은 UI 프리징을 유발
​
> ❓ UI 프리징  
> 
> -   메인 스레드가 오래 블로킹되어 입력·스크롤·애니메이션 같은 화면 반응이 멈추거나 버벅거리는 현상
​
(3) 장점
​
-   처리 과정이 단순하고 순차적
-   결과가 준비되면 바로 다음 코드로 넘어가므로 흐름 관리가 쉬움
​
(4) 단점
​
-   작업이 오래 걸리면 전체 프로그램이 멈춤
-   싱글 스레드 환경에서는 치명적 (JS UI멈춤)
-   사용자 경험 저하
​
### **논블로킹**
​
(1) 정의
​
-   함수를 호출할 때 작업을 끝내지 않아도 즉시 제어권이 호출부로 반환되는 방식
-   흐름이 멈추지 않음
​
(2) 특징
​
-   코드 흐름이 계속 이어짐
-   작업 완료 후 콜백/Promise를 통해 결과 전달
​
(3) 장점
​
-   흐름이 멈추지 않아 프로그램이 부드럽게 동작
-   I/O 작업을 효율적으로 처리
-   처리량 증가
-   Node.js 서버처럼 많은 요청을 동시에 처리할 수 있음
​
(4) 단점
​
-   동기 코드보다 이해하기 어려울 수 있음
-   콜백/Promise/async 흐름을 제대로 알아야 함
-   결과가 바로 오지 않기 떄문에 코드 구조가 복잡해질 수 있음
​
**블로킹 논블로킹**
​
| **동기** | 동기·블로킹호출 → 결과 나올 때까지 내 코드 멈춤 → 결과 받자마자 다음 줄 실행 | 동기·논블로킹호출 → 바로 반환되지만, 내가 직접 결과 준비 됐는지 계속 확인 후 다음 줄 실행 |
| --- | --- | --- |
| **비동기** | 비동기·블로킹비동기로 요청은 했는데, 곧바로 future.get()/join() 같은 대기로 막아버림(사실상 동기처럼 사용) | 비동기·논블로킹요청 후 즉시 반환, 결과는 콜백/Promise/이벤트로 나중 통지, 호출부는 계속 진행 |
​
### **동기·블로킹**
​
-   사례: 파일 동기 읽기, DB 동기 쿼리, CPU 연산 함수 호출
-   장점: 이해/디버깅 간단, 순서 보장
-   단점: I/O 대기 시간 동안 실행 흐름 정지
​
### **동기·논블로킹**
​
-   사례: read() → “당장 읽을 게 없으면 0/에러로 바로 반환”, 호출부가 루프에서 반복 확인
-   장점: 호출 즉시 돌아오므로 한 번 호출에선 안 막힘
-   단점: 논블로킹 루프가 CPU 낭비, 타이밍 제어 복잡 → 보통 백오프(sleep, 지수 증가) 필요
​
### **비동기·블로킹**
​
-   사례: 비동기 요청 직후 future.get() / promise.join()로 즉시 기다림
-   의미: 비동기를 “형식상” 썼지만, 실제로는 동기처럼 막는다
-   언제?: 인터페이스가 비동기뿐인데, 특정 지점에서 결과가 꼭 필요할 때. 구조가 건강한지는 재검토 권장
​
### **비동기·논블로킹**
​
-   사례: 콜백/Promise/이벤트 기반 I/O, async/await(호출부는 즉시 진행, 완료되면 처리)
-   장점: 반응성↑, 처리량↑, 쓰레드 낭비↓
-   주의: 제어 흐름 분산 → 오류 처리/취소/타임아웃 설계 필요
​
## **자바스크립트는 싱글스레드인데 비동기가 어떻게 가능한가?**
​
자바스크립트는 싱글스레드 기반으로 동작함
​
하나의 콜 스택만을 사용하며, 한 번에 하나의 작업만 실행 가능
​
그럼에도 비동기 처리가 가능한 이유?
​
→ 자바스크립트 엔진 외부의 런타임 환경이 비동기 기능을 제공하기 때문
​
### **자바스크립트 런타임 환경의 구성요소**
​
1.  **JS 엔진 (싱글스레드)**
​
-   하나의 콜 스택을 통해 동기 코드를 처리
-   콜 스택이 차지되어 있는 동안 다른 작업이 실행될 수 없음
​
1.  **Web APIs / Node.js 바인딩**
​
-   타이머(setTimeout), 네트워크 요청(fetch), 파일 I/O 등은 엔진이 직접 처리하지 않음
-   해당 작업은 브라우저(Web APIs) 또는 Node.js가 제공하는 별도의 시스템 스레드나 기능으로 위임됨
-   위임된 작업은 엔진의 콜 스택과 독립적으로 진행됨
​
1.  **태스크 큐(매크로태스크 큐)**
​
-   Web APIs에서 완료된 작업의 콜백이 저장되는 큐
-   대표적인 매크로태스크: setTimeout, setInterval, DOM 이벤트, 일부 I/O 콜백
​
1.  **마이크로태스크 큐**
​
-   Promise의 .then / .catch / .finally, queueMicrotask 등에서 발생하는 태스크가 저장되는 큐
-   마이크로태스크는 매크로태스크보다 우선순위가 높음
-   콜 스택이 비는 즉시, 마이크로태스크 큐가 완전히 빌 때까지 가장 먼저 처리됨
​
1.  **이벤트 루프**
​
-   콜 스택과 두 종류의 태스크 큐를 감시하여 실행 순서를 결정하는 메커니즘
-   다음과 같은 순서로 동작함
​
**이벤트 루프 규칙**
​
1.  콜 스택이 비어 있는지 확인
2.  비어 있다면 마이크로태스크 큐의 모든 작업을 먼저 처리
3.  마이크로태스크가 모두 소진되면 매크로태스크 큐에서 작업을 하나 가져와 처리
4.  필요 시 렌더링을 수행
5.  위 과정 반복
​
---
​
## **어떻게 말하는게 좋을까?**
​
---
​
#### **1) 블로킹 / 논블로킹 개념 질문**
​
**블로킹과 논블로킹의 차이를 설명해주세요.**
​
블로킹은 함수가 제어권을 호출자에게 돌려주지 않고, 작업이 끝날 때까지 호출자가 기다리는 방식입니다.
​
반대로 논블로킹은 함수가 작업을 ‘요청만 하고’ 바로 제어권을 반환해서 호출자가 다른 작업을 계속할 수 있는 방식입니다.
​
### 꼬리 질문
​
-   블로킹과 동기의 차이는 무엇인가요?
-   논블로킹인데 동기일 수도 있나요?
-   실제로 경험한 블로킹 이슈가 있나요?
​
---
​
#### **2) 동기 / 비동기 질문**
​
**동기와 비동기는 무엇이 다른가요?**
​
동기는 호출한 함수의 **결과를 바로 받아야만** 다음 작업을 진행할 수 있는 방식이고,
​
비동기는 호출한 함수의 **결과를 나중에 통지받고** 처리하는 방식입니다.
​
그래서 동기는 순서가 보장되고, 비동기는 순서가 보장되지 않습니다.
​
### 꼬리 질문
​
-   비동기를 쓰면 항상 성능이 좋아지나요?
-   비동기인데 블로킹일 수도 있나요?
​
---
​
#### 3) 2×2 매트릭스 질문
​
**동기/비동기와 블로킹/논블로킹의 조합 4가지 모두 설명해주세요.**
​
두 개념은 서로 다른 기준입니다.
​
-   **동기·블로킹**: 파일 동기 읽기처럼 결과를 기다리며 흐름이 멈추는 방식
-   **동기·논블로킹**: 논블로킹 소켓처럼 호출은 바로 끝나지만, 호출자가 직접 폴링하며 결과를 확인하는 방식
-   **비동기·블로킹**: 비동기 요청 직후 future.get()으로 다시 기다려버리는 방식
-   **비동기·논블로킹**: Promise, 콜백처럼 요청 후 바로 진행하고, 나중에 결과 통지받는 방식
​
### 꼬리 질문
​
-   동기·논블로킹이 실제로 왜 필요한가요?
-   비동기·블로킹은 어떤 상황에서 발생하나요?
​
---
​
#### **4) “JS는 싱글스레드인데 비동기 가능한 이유?**
​
**자바스크립트는 싱글스레드인데, 어떻게 비동기를 처리하나요?**
​
자바스크립트 엔진은 싱글스레드이지만, 실제 비동기 처리는
​
브라우저의 Web API나 Node.js 런타임(libuv)가 담당합니다.
​
이 작업이 끝나면 이벤트 루프가 태스크 큐에서 콜백을 가져와 실행하기 때문에
​
싱글스레드에서도 비동기 처리가 가능합니다.
​
### 꼬리 질문
​
-   Web API/Web worker 차이는 무엇인가요?
-   Node.js의 libuv는 어떤 역할을 하나요?
​
---
​
#### **5) 이벤트 루프 질문**
​
**이벤트 루프가 어떻게 동작하는지 설명해 주세요.**
​
자바스크립트는 콜 스택이 비어있을 때 이벤트 루프가 태스크 큐에서 작업을 가져옵니다
​
우선 마이크로태스크 큐(Promise)를 먼저 비우고,
​
그 다음 매크로태스크 큐(setTimeout 등)에서 하나를 가져와 실행합니다.
​
이 과정을 계속 반복하면서 비동기 코드를 실행합니다.
​
### 꼬리 질문
​
-   Promise then이 setTimeout보다 먼저 실행되는 이유는?
-   마이크로태스크 큐는 왜 우선순위가 높은가?
​
---
​
#### **6) setTimeout과 Promise 순서 질문**
​
**왜 Promise.then이 setTimeout보다 먼저 실행되나요?**
​
Promise의 후속 작업은 **마이크로태스크 큐**에 들어가고,
​
setTimeout은 **매크로태스크 큐**에 들어갑니다.
​
이벤트 루프는 콜 스택이 비면 **마이크로태스크 큐를 먼저 모두 비운 뒤**,
​
그 다음 매크로태스크를 실행하기 때문에 Promise가 먼저 실행됩니다.
​
### 꼬리 질문
​
-   queueMicrotask는 어디에서 실행되나요?
-   nextTick(Node.js)은 어떤 큐를 사용하나요?
​
---
​
#### **7) 비동기 코드의 장단점**
​
**비동기를 쓰면 무엇이 좋아지고, 무엇이 어려워지나요?**
​
좋은 점은 I/O 대기 시간을 없애서 **반응성**과 **처리량**을 높일 수 있다는 점입니다.
​
어려운 점은 제어 흐름이 분산되고,
​
오류 처리·타임아웃·취소 같은 구조를 직접 설계해야 한다는 점입니다.
​
---
​
#### **8) 꼬리 질문 총정리**
​
추가 질문들:
​
-   콜 스택과 큐의 차이가 뭐죠?
-   Web API와 JS 엔진의 역할은 어떻게 다르죠?
-   async/await은 Promise와 어떤 관계인가요?
-   이벤트 루프가 없다면 비동기는 어떻게 될까요?
-   논블로킹이 왜 중요하다고 생각하나요?
-   CPU 작업이 많은 경우 JS 비동기는 어떤 문제가 생기나요?
-   Node.js가 싱글스레드라고 할 때 정확히 무엇이 싱글스레드인가요?
