## **🧠 회고**

오늘은 자바스크립트에서 정말 핵심적인 주제인 this와 클로저를 학습한 하루였다. 처음 들으면 헷갈리지만, 한 번 정확히 이해하면 프론트엔드 전반에서 계속 쓰이는 개념들이라서 꼭 짚고 넘어가야 하는 부분이었다.

학습을 진행하면서, 단순히 문법만 익히는 게 아니라  
“왜 이렇게 동작하는가?”, “이 개념을 실무에서 어떻게 사용할 수 있는가?”를 이해하는 것이 중요하다는 걸 다시 한 번 느꼈다.

케빈이 해주신 조언대로 열심히 복습하고 회고해나가야겠다는 생각을 했다.

## **🪽 오늘의 다짐**

오늘 배운 개념을 절대 흘려보내지 않고, 내 손으로 다시 정리하고 직접 써보며 확실히 내 것으로 만들겠다.

헷갈리는 부분이 있어도 조급해하지 않고, “왜 이렇게 동작하는지”를 끝까지 파고드는 개발자가 되겠다.

조금씩이라도 성장하면 스스로를 칭찬하고, 실패하더라도 포기하지 않고 다시 시도하며 꾸준함으로 나를 증명하겠다.

오늘의 작은 이해가 내일의 더 큰 자신감이 될 거라 믿는다.

---

## **📝 Today I Learned**

### **1️⃣  this**

#### **1\. 정의**

\- 함수 실행 시 함수 내에서의 실행 컨텍스트를 참조하는 자동으로 할당되는 지역 변수

\- 고정된 값이 아닌 코드가 실행되는 상황에 따라서 가리키는 대상이 동적으로 결정되는 키워드

\- this는 함수가 선언될 때 결정되지 않고, 호출되는 시점에 결정이 됨 -> 어떻게 호출되었는가에 따라 this가 가리키는 대상이 달라짐

👉🏻 동적 바인딩

#### 2\. 사용 이유

\- 함수 내에서 내가 원하는 변수를 찾기 위함

\- 객체를 만들고 객체의 속성과 그 속성을 다루는 메소드를 가지고 있음

\- 이때 메소드가 자기 자신이 속한 객체의 데이터에 접근해야할 때 this 사용

```
const user1 = {
  name: '토르',
  greet: function() {
    console.log(`안녕하세요. ${this.name}입니다`);
  }
};

const user2 = {
  name: '로키',
  greet: function() {
    console.log(`안녕하세요. ${this.name}입니다`);
  }
};

user1.greet(); // 안녕하세요. 토르입니다
user2.greet(); // 안녕하세요. 로키입니다
```

\-> greet 함수 하나를 재사용 가능한 템플릿처럼 활용하여 각기 다른 객체의 컨텍스트에 맞게 동작시킬 수 있다.

#### 3\. 사용 방법

\- 전역 this, 함수 this, arrow 함수 this, method this, callback, 생성자 함수 (new 바인딩)

| 종류 | 바인딩되는 주체 (가리키는 주체) |
| --- | --- |
| 전역 this | 전역 객체 |
| 함수 this | 전역 객체 |
| arrow 함수 this | \- this를 바인딩하지 않음   \- 스코프체이닝(가까운 this)상의 this |
| method this | \- 메서드를 호출한 대상에 대한 객체   \- js에서 메서드란? 어떤 객체와 관련된 기능이면 메서드라고 부름 |
| callback | \- 기본적으로 함수 내부에서와 동일   \- 하지만 apply, call, bind에 따라 달라질 수 있음 |
| 생성자 함수 (new 바인딩) | 새로 생성한 객체에 자동으로 bind |

> ❓ 바인딩  
> \- 프로그래밍에서 어떤 값을 특정 이름(변수, 상수 등)에 연결하는 과정  
> \- 변수나 상수에 값을 할당하는 것

> ❓ JS의 this 바인팅  
> \- 함수나 메서드가 실행될 때 그 함수나 메서드가 어떤 객체를 참조해야 하는지를 결정하는 과정  
> \- 함수의 실행 방식에 따라 this가 가리키는 대상(객체)이 결정됨  
> \- 함수가 어디서, 어떻게 호출되었는지에 기반하여 값이 달라짐

**(1) 전역 공간에서의 this (Global This)**

\- 전역객체 (host) 객체

\- 웹 브라우저 환경에서는 window, node.js 환경에서는 global rorcp

\- var 키워드 이용해서 전역에 변수 선언하면 window 객체의 property가 됨

```
var a = 1;


console.log(a); // 1
console.log(this.a); // 1
```

**(2) 함수 호출시의 this (Func This)**

\- this는 부르는 상황마다 다르게 동작

-   **기본 바인딩**
    -   함수 단독 호출 시에는 Global Binding

-   **암시적 바인딩**
    -   함수가 특정 객체의 메소드로 호출될 때 this는 그 메소드를 호출한 객체를 가리킴
    -   암시적이라는 이름이 붙은 이유는 우리가 this는 obj다라고 말해주지 않아도 호출하는 형태를 보고 자바스크립트 엔진이 알아서 this를 obj에 바인딩
    -   객체가 점(.)으로 함수를 호출하면 this는 그 객체가 된다

```
const obj = {
	name : 'Kim',
	getName(){
		return this.name;
	}
}

console.log(obj.getName()); //Kim
```

-   **Callback일때, 명시적 바인딩**
    -   this가 가리키는 것을 내가 바꾸고 싶다! 가끔 this를 우리가 원하는 객체로 강제로 지정하고 싶을 때가 있다
        -   call, apply, bind 메소드를 사용할 수 있음 (모든 함수가 갖고 있는 기존 내장 매소드)
        -   call / apply
            -   함수 호출시 첫 번째 인자로 this로 사용할 객체를 전달
            -   함수를 호출하면서 this가 될 객체를 첫 번째 인자로 넘겨주면 됨
            -   즉시 함수를 실행시킨다라는 공통점
            -   call: this로 사용할 객체, 함수에 전달할 인자를 쉼표로 구분한다.
            -   apply: this로 사용할 객체, 함수에 전달할 인자를 배열 형태로 묶어서 넘긴다.
        -   bind
            -   첫 번째 인자값으로 전달된 객체에 this를 고정한 새로운 함수(영구적)를 반환
            -   함수를 즉시 실행하지 않고, this가 영구적으로 고정된 새로운 함수를 반환함
            -   콜백함수에서 this 컨텍스트를 잃어버리는 문제를 해결할 때 쓸 수 있다

```
function introduce(name, interest) {
  console.log(`Hello! My name is ${name} and I like ${interest}.`);
  console.log(`Hello! My name is ${this.name} and I like ${this.interest}.`);
  console.log(`this: ${JSON.stringify(this)}`); // user를 가리키고 있음
  console.log(`-----------------------------`);
}

const user = {
  name: 'Alice',
  interest: 'JavaScript',
};

// call 사용  
introduce.call(
  user,            // 1) this가 될 객체
  user.name,       // 2) 함수의 첫 번째 매개변수(name)
  user.interest    // 3) 함수의 두 번째 매개변수(interest)
);


// apply 사용
introduce.apply(user, [user.name, user.interest]);
```



```
function greet() {
  console.log(`Hi, I am ${this.name}.`);
}

const user = {
  name: 'Bob',
};

const userGreet = greet.bind(user);
userGreet();  // → "Hi, I am Bob."
```

| **call** | 즉시 this 설정 | 바로 실행됨 | 하나씩 전달 |
| --- | --- | --- | --- |
| **apply** | 즉시 this 설정 | 바로 실행됨 | 배열로 전달 |
| **bind** | this 영구 설정 | ❌ 바로 실행 X | 새 함수로 저장 |

-   new 바인딩
    -   생성자 함수를 사용하여 새로운 객체를 생성 시 발생하는 형태
    -   새로 생성한 객체에 자동으로 bind

```
function Person(name, age) {
  this.name = name;
  this.age = age;
}


const alice = new Person('Alice', 30);  // 'new' 키워드를 사용하여 'Person' 생성자로 새 객체 생성

// 생성된 객체를 출력
console.log(alice);
// 결과: Person { name: 'Alice', age: 30 }
```

-   이벤트 리스너에서의 this
    -   여기서 this의 동작은 콜백 함수를 어떻게 정의했느냐에 따라 달라진다

```
///  html
<button id="myButton">click</button>


/// js
const button = document.getElementById('myButton');

// 일반 함수
button.addEventListener('click', function(event) {
	console.log(this); // event.currentTarget을 가리킨다. 이벤트처리할떄 해당 요소를 직접 조작.
	console.log(this === event.currentTarget); // true
	this.textContext = 'Clicked';
});

// arrow func
button.addEventListener('click', (event) => {
	console.log(this); // window 객체. 화살표 함수는 자신만의 this가 없다. 
	// 이벤트가 발생한 요소를 참조하고 싶다면 화살표 함수 안에서는 event.currentTarget을 명시적으로 사용해야한다.
});
```

(3) Arrow Func This

\- 함수가 호출되는 방식에 따라 this가 결정됨

\- 선언될 당시의 상위 스코프가 this를  참조

\- this 바인딩 자체가 없기 때문에 call, apply, bind 모두 사용 불가능

\- 화살표 함수는 자신만의 this를 가지지 않음

👉🏻 자신을 감싸고 있는 가장 가까운 상위 스코프의 this를 그대로 물려받아서 사용함

👉🏻 this가 동적으로 결정되는게 아니라 함수가 선언된 위치에서 정적으로 결정됨

```
const obj = {
	name : 'Kim',
	getName: () => {
		// obj가 아닌 Global 을 가르킴.
		return this.name;
	}
}

console.log(obj.getName());
```

(4) 변수에 this를 할당

```
function Person(name) {
	  this.name = name;
	  var self = this;
	  setTimeout(function() { // 일반 함수이기 때문에 전역 객체를 가리키겠지만, self 로 인해 함수 내부를 가리키게 됨
		    console.log(self.name); // 'John'
	  }, 1000);
}

const person = new Person('John');
```

\- 함수 내에서 this를 변수에 할당하여, 다른 함수 내에서 사용할 수 있도록 함

\- self, that과 같은 변수 사용

\- 변수에 this를 할당하는 방법은 변수가 바인딩되기 때문에 가능한 방식

#### 4\. this의 우선순위

(1) new 바인딩

\- new 키워드로 호출했을 때 우선순위가 가장 높음

(2) 명시적 바인딩

\- call, apply, bind로 this를 지정했을 때

(3) 암시적 바인딩

\- 객체의 메소드로 호출했을 때

(4) 기본 바인딩

\- 위 세가지에 해당되지 않을 때

화살표 함수는 이 규칙에서 제외

\-> 무조건 자신의 상위 스코프의 this 를 참조함

#### 5\. 정리

\- this는 함수 호출될 때 결정된다. 어떻게 호출되었는지에 따라서 가리키는 대상이 달라진다

\- 바인딩 우선 순위가 존재한다

\- 화살표 함수는 상위 스코프 this 그대로 사용한다

\- 이벤트 리스너에서 일반 함수의 this는 이벤트 대상 event.currentTarget을 가리킨다.

\- 다만 react에서는 함수형 컴포넌트와 hooks를 주로 사용하면서 this를 다룰일이 많이 줄었다. 하지만 그렇다고해서 this를 몰라도되는 것은 아님

---

### 2️⃣ 클로저

#### 1\. 정의

\- 일급 객체 함수의 개념을 이용해 스코프에 묶인 변수를 바인딩하기 위한 일종의 기술

> ❓ 일급 객체 함수  
> \- JS의 함수 변수에 할당할 수 있음  
> \- 다른 함수의 인자로 전달할 수 있음  
> \- 함수에서 함수로 반환할 수도 있음  
> 👉🏻 클로저는 함수에서 함수를 반환하는 특징을 사용

> ❓ 스코프에 묶인 변수  
> \- 함수가 선언될 때의 환경, 그 함수를 둘러싸고 있는 변수  
> \- 렉시컬 스코프

> ❓ 바인딩  
> \- 특정 값이나 변수를 서로 연결하는 것

\- 어떤 함수가 자신이 선언될 때의 환경(스코프)를 기억하고 있다가, 나중에 다른 곳에서 다시 호출되더라도 그 기억해둔 환경에 접근할 수 있는 기술, 현상

\- 함수가 태어난 자기의 고향의 환경을 잊지 않음

#### 2\. 사용 이유

\- 캡슐화

👉🏻 전역 변수의 과도한 사용을 방지하고 변수의 값을 은밀하게 보호하기 위해서

\- 불변성

👉🏻 클로저 외부에서 접근할 수 없는 내부만의 비공개적인 공간을 만들고, 그 공간을 통해서 상태값을 안전하게 유지하고 관리 가능

\=> 상태를 안전하게 관리하기 위함

#### 3\. 사용 방법

\- 외부 함수에서 내부 함수를 반환하고, 이 내부 함수가 외부 함수의 변수에 접근하여 그 상태를 유지하도록 하는 것

```
function createCounter() {
  let count = 0;
  
  function increment() {
    console.log(count);
  };
  
  return increment;
};

const counter = createCounter(); // increment 함수를 반환합니다.
counter(); // '0'을 출력합니다.
```

\- createCounter 함수는 increment 함수를 반환함

\- counter 변수는 increment 함수를 참조하게되며, counter를 호출하면 count 변수의 값을 콘솔에 출력함  
\=> increment 함수는 createCounter 방 안에서 보고 기억한 count(0)를 방 밖에서도 꺼내서 쓸 수 있기 때문에 0이 출력된다.
