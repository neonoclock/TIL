## **🧠 회고**

오늘은 일급 함수, 익명함수, 즉시 실행함수에 대하여 학습하였다.

그리고 1:N멘토링 시간을 가지고, 카카오 아지트 투어도 갔다!

동기 부여 너무 되었다! 열심히 해야겠다... 내 목표를 위해!

## **🪽 오늘의 다짐**

1\. 진짜 열심히 해야겠다.......

---

## **📝 Today I Learned**

### **1️⃣  들어가기 전**

**(1) useCallback**

\- 함수를 기억해두는 도구

\- React에서 컴포넌트는 리렌더링될 때마다 내부의 함수가 새로 만들어짐

👉🏻 그래서 이 함수를 props로 전달하면, 자식 컴포넌트가 'props가 바뀌었다'고 인식해서 불필요하게 다시 렌더링 됨

👉🏻 useCallback

\- 함수를 메모이제이션(기억)해서, 의존성 배열이 바뀌지 않는 한 같은 함수 객체를 재사용하도록 함

\- 주로 React.memo와 함께 사용해서 성능 최적화

(2) 훅

\- 함수형 컴포넌트에서 React의 기능을 사용할 수 있게 해주는 함수

\- 항상 컴포넌트의 최상단에서만 호출

\- 조건문, 반복문 안에서는 사용 못함

\- useState, useEffect, useCallback ...

(2) useMemo

\- 값의 계산 결과를 메모이제이션하는 훅

\- 의존성 배열의 값이 바뀌지 않는 한 이전 계산 값을 재사용해서 불필요한 연산을 줄이고 성능 최적화

\=> useMemo가 값을 기억하는 훅이라면, useCallback은 함수를 기억하는 훅

---

### 2️⃣ 함수형 패러다임  - 일급 함수

#### 1\. 정의

\- 프로그래밍 언어에서 함수를 일급 시민으로 취급하여, 다른 변수처럼 사용할 수 있게 하는 특성을 가진 함수

#### 2\. 사용 이유

(1) 코드의 재사용성 향상

\- 함수를 변수에 저장하거나, 다른 함수로 전달

\- 중복 코드를 줄이고, 프로젝트의 일관성 유지

(2) 고차 함수 사용

\- 함수를 다른 함수의 인자로 전달하거나 결과로 반환

\- 데이터 처리와 이벤트 처리에서 유용함

(3) 유연한 함수 처리

\- 함수를 데이터 구조에 저장하고 필요할 때 사용

\- 이벤트 리스너나 콜백 함수 관리에 유용

(4) 추상화와 캡슐화 용이

\- 세부 구현을 숨기고 필요한 인터페이스만 제공

\- 복잡한 로직을 간단한 함수 호출로 처리 가능

#### 3\. 사용 방법

(1) 함수를 변수에 할당 (함수 표현식)

```
const sayHello = function() {
  console.log("안녕!");
};

sayHello(); // "안녕!"
```

(2) 함수를 다른 함수의 인자로 전달

```
function greet(fn) {
  fn(); // 전달받은 함수를 실행
}

const sayHi = function() {
  console.log("안녕하세요!");
};

greet(sayHi); // "안녕하세요!"
```

(3) 함수에서 다른 함수를 반환

```
function makeMultiplier(x) {
  return function(y) {
    return x * y;
  };
}

const double = makeMultiplier(2);
console.log(double(5)); // 10
```

(4) 고차 함수를 사용한 간단한 컴포지션

```
const double = (x) => x * 2;
const addThree = (x) => x + 3;

// 컴포지션: 여러 함수를 합쳐서 하나의 함수로
function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

const doubleThenAddThree = compose(addThree, double);

console.log(doubleThenAddThree(5)); // (5*2) + 3 = 13
```

#### 4\. 일급 함수의 개념이 프론트엔드에서 어떻게 활용되는가?

자바스크립트에서 함수는 일급 객체이기 때문에 함수를 변수에 저장하거나, 인자로 전달하거나, 반환할 수 있다.

이런 개념은 React 설계 철학과 패턴 전반에 녹아 있다.

(1) 리액트 고차 컴포넌트 (HOC)

\- 컴포넌트를 인자로 받아서 새로운 기능이 추가된 컴포넌트를 반환하는 함수

\-> 함수를 인자로 받고 함수를 반환한다는 점에서 고차함수의 정의와 비슷

  
(2) Render Props

\- props를 통해서 컴포넌트에 함수를 전달하고 그 함수를 통해서 UI를 렌더링하는 방식

\-> 함수를 인자로 전달한다는 일급 함수의 성질을 그대로 이용

#### 5\. 함수 컴포지션

\- 여러 개의 함수를 조합해서 새로운 함수를 만드는 것

\- 각 함수가 하나의 책임만 가지도록 분리할 수 있어 테스트와 디버깅이 쉬워지고, 재사용성이 높아짐

---

### 3️⃣ 함수형 패러다임 - 익명 함수

#### 1\. 정의

\- 재활용하기 위해 묶어 놓은 이름이 없는 코드들의 집합

#### 2\. 사용 이유

(1) 코드 간결성

\- 익명함수는 코드를 보다 간결하게 만듦

\- 특히 콜백 함수로 사용할 때 코드의 가독성을 향상 시킴

(2) 임시 함수의 사용

\- 특정 함수가 한 번만 사용되거나, 직접 함수명의 정의할 필요가 없는 경우 익명 함수를 사용하여 코드 중독 피할 수 있음

(3) 클로저 생성

\- 클로저를 생성하는 용도

\- 함수 외부의 변수에 접근하거나 내부 상태 유지 가능

> ❓ 클로저  
> \- 함수가 자신이 선언될 때의 환경(스코프)를 기억하는 기능  
> \- 그 함수가 실행될 때 그 스코프 안의 변수에 접근할 수 있는 구조  
> \- 외부 함수의 실행이 끝나도 내부 함수가 변수를 참조하면 그 변수는 메모리에서 유지됨  
> \- 데이터 은닉, 상태 유지, 캡슐화 등 구현 가능

(4) 이벤트 핸들러와 콜백

\- 콜백: 다른 함수에 인자로 전달되어, 그 함수 안에서 나중에 호출되는 함수

\- 이벤트 핸들러: 이벤트가 발생했을 때 자동으로 호출되는 콜백 함수

\=> 콜백 함수는 다른 함수에 인자로 전달되어 나중에 호출되는 함수

\=> 이벤트 핸들러는 이벤트 발생 시 호출되는 콜백 함수의 한 형태

#### 3\. 사용 방법

(1) 함수 표현식

```
// 익명 함수 표현식
const sayHello = function() {
  console.log("안녕!");
};

sayHello(); // 실행 → "안녕!"
```

> ❓ 함수 선언문 vs 함수 표현식  
> \- 함수 선언문은 전체가 호이스팅돼서 어디서든 호출 가능 (재사용이 필요한 전역 함수)  
> \- 함수 표현식은 변수에 저장되는 형태라 변수의 호이스팅 규칙 따름  (콜백 함수, 일회성 로직)  
> 👉🏻 표현식은 선언 이후에만 사용 가능

> ❓ 호이스팅  
> \- 자바스크립트가 실행 전에 변수와 함수 선언을 미리 메모리에 올려두는 동작  
> \- const, let, ver에 따라 호이스팅 동작과 에러 발생 다름  
> 👉🏻 var 변수: undefined로 초기화되어 접근  
> 👉🏻 let, const: TDZ에 묶여 있어 선언 전에 접근 불가  
> \- 함수 선언문: 전체 호이스팅  
> \- 함수 표현식: 변수만 호이스팅

(2) 다른 함수의 인자로 전달

```
// setTimeout에 익명 함수 전달
setTimeout(function() {
  console.log("3초 후에 실행됩니다!");
}, 3000);
```

\- 익명 함수는 직접 실행하지 않고, 다른 함수가 나중에 대신 실행하도록 넘길 수 있음

---

### 4️⃣ 함수형 패러다임 - 즉시 실행 함수

#### 1\. 정의

\- 정의되자마자 즉시 실행되는 함수

#### 2\. 사용 이유

(1) 변수와 함수의 스코프 제한

\- 전역 스코프 오염을 막기 위해 씀

> ❓ 전역 스코프 오염  
> \- 프로그램 전체에 접근 가능한 공용 공간에 변수나 함수가 너무 많아져서 이름이 충돌하고 코드를 예측하기 어렵게 만드는 문제  
> \- 모듈 시스템으로 해결하면 됨 (굳이 즉시 실행 함수 쓸 필요는 없음)

\- 자기만의 지역 스코프를 만들기에 전역 변수를 더럽히지 않고 코드 실행 가능

(2) 즉시 실행

\- IIFE는 정의되자마자 바로 실행됨

\- 초기화 로직이나 설정을 웹 페이지 로드 즉시 수행해야 할 때 유용

\- 이벤트 리스너 설정, 초기 데이터 로딩, UI설정 등 페이지 준비를 위한 코드를 즉시 실행하고 완료할 수 있음

(3) 코드의 캡슐화와 관리

\- 관련 코드를 그룹화하고, 모듈처럼 관리할 수 있게 해줌

\- 유지보수와 코드 관리를 용이하게 함

\- 코드의 가독성을 높임

#### 3\. 사용 방법

\- 함수를 ()로 감싸서 함수 선언

```
(function() {
		// 여기에 코드를 작성합니다.
})();
```

#### 4\. async / await

\- Promise 기반의 비동기 처리 문법

\- async: 항상 Promise를 반환

\- await: 그 Promise가 해결될 때까지 함수의 실행을 일시 중단

\- 기존 .then() 체인보다 가독성이 좋고 예외 처리도 try/catch로 깔끔하게 가능

> ❓ Promise  
> \- 비동기 작업의 결과를 약속하는 객체  
> \- 작업이 완료되면 resolve나 reject를 통해 성공 또는 실패 상태를 전달  
> \- 성공 시 then, 실패 시 catch를 통해 결과를 처리

---

### 5️⃣ 모듈 시스템

#### 1\. 정의

\- 재사용 가능한 코드 조각

\- 함수, 변수, 클래스를 하나의 파일로 묶어놓은 것

\- 자신만의 독립적인 영역을 갖음

-   모듈 내부에 선언된 변수나 함수는 외부에서 직접 접근할 수 없게 됨
-   전역 스코프 오염 문제 근본적 해결 가능

#### 2\. 사용 이유

\- 복잡한 프로그램을 작은 부분으로 나누어 재사용과 유지보수를 용이하게 하기 위함

#### 3\. 사용 방법

\- 필요한 기능 별로 코드를 분리해 파일 단위로 작성

\- 큰 프로그램을 여러 파일로 나누어서 관리하는 방법

(1) CJS (CommonJS) = module.exports

\- 동기적으로 동작

👉🏻 파일을 불러올 때 다 불러오기 전까지 다음 코드로 못 넘어감

\- 원래 브라우저가 아닌 서버 환경을 위해 만들어진 모듈 시스템 (Node.js)

(2) ESM (ECMAScript Modules)

\- 비동기적으로 동작

👉🏻 모듈을 불러올 때 네트워크 요청을 보내두고, 나머지 코드를 동시에 실행할 수 있음

\- 브라우저와 Node.js 둘 다 사용 가능 

\- Named Export / import

-   여러 값을 내보낼 때 각각의 고유한 이름으로 내보내기 사용
-   하나의 모듈에서 여러 함수, 변수 클래스 등을 내보내기 할 때 사용

\- Default Export / import

-   모듈당 하나의 값을 내보낼 때 사용
-   모듈 전체가 하나의 클래스나 객체일 때 유용
-   import 시 명칭 변경 가능

\=> named: 보통 여러 개의 유틸 함수 모아둔 파일

\=> default: 하나의 클래스, 하나의 주된 객체를 정의하는 파일

#### 4\. 모듈화, 유지보수성, 가독성, 테스트 용이성

\- 코드를 기능별로 잘 쪼개서 모듈로 만들면 (모듈화)

\- 파일 이름만 봐도 어떤 코드인지 짐작할 수 있게 되고(가독성)

\- 버그가 발생했을 떄 거대한 하나의 파일을 뒤져보는 대신, 관련한 모듈만 집중해서 보면되니 디버깅 쉬워짐 (유지보수성)

\- 모듈로 나뉘어져 있는 순수 함수는 다른 부분과 독립적으로 테스트할 수 있어서 코드 안정성 높아짐 (테스트 용이성)
