## **🧠 회고**

과제를 하려다보니 복습이 밀리고 있는 것 같다. 프론트엔드 구간이라 더 열심히 하고 싶었는데, 시간 관리를 소홀히 한 내 잘못인 것 같다.

시간관리와 체력관리의 중요성을 느끼고 있는 요즘이다.

그래도 프론트엔드 구간에 와서 궁금했던 JS에 대해 공부하니 재밌는 것 같다! ㅎㅎ

## **🪽 오늘의 다짐**

내가 원하는 직무의 가장 기초적인 부분인만큼 더욱 더 열심히하자.

---

## **📝 Today I Learned**

### **1️⃣ 복습**

#### **1\. 모듈화, 유지보수성, 가독성, 테스트 용이성**

\- 코드를 기능별로 잘 쪼개서 모듈로 만들면 (모듈화)

\- 파일 이름만 봐도 어떤 코드인지 짐작할 수 있다 (가독성)

\- 버그가 발생했을 때 하나의 파일을 뒤져보는 대신 관련한 모듈만 집중해서 보면 되니 디버깅이 쉬워진다 (유지보수성)

\- 모듈로 나뉘어져 있는 순수함수는 다른 부분과 독립적으로 테스트할 수 있기에 코드 안정성이 높아진다 (테스트 용이성)

#### **2\. Tree-shaking**

**(1) 정의**

\- 사용하지 않는 코드를 자동으로 제거하는 최적화 기술

\- 웹팩, 비트, 롤업 같은 모듈 번들러가 수행

\- 결과: 최종 번들 크기가 감소하여 로딩 속도가 빨라짐

> ❓ **번들**  
> \- 여러 개의 파일을 하나로 묶어 만든 최종 배포용 묶음 파일  
> \- 모듈 번들러가 모든 파일을 분석해서 하나 또는 몇 개의 큰 파일로 묶어주는 것

> **❓ 번들러**  
> \- webpack, Vite, Rollup, Parcel  
>   
> 1\. import/export 관계 분석  
> 2\. 사용된 코드만 추적  
> 3\. 사용되지 않는 코드 제거 (트리셰이킹)  
> 4\. 코드 압축  
> 5\. 여러 파일을 하나 또는 몇개로 묶음  
> 6\. 브라우저가 이해하기 쉬운 형태로 변환

  
**(2) 사용 이유**

\- lodash처럼 수백 개 함수를 가진 라이브러리에서 실제로 필요한 건 debounce 하나일 수 있음

👉🏻 트리셰이킹이 없으면?

👉🏻 debounce 하나 때문에 lodash 전체를 다운해야 함

👉🏻 파일 커짐 + 로딩 느려짐 + 낭비

👉🏻 트리셰이킹은 실제로 사용한 코드만 남기고 나머지는 제거

**(3) 트리셰이킹 동작 원리**

\- 번들러가 프로젝트 전체의 import/export 관계 분석

\- 코드 분석 후 필요한 코드만 포함된 가벼운 번들 파일 생성

**(4) ESM (ES Modules)구조가 중요한 이유**

\- 트리셰이킹이 잘 되려면 정적 분석(코드 실행 없이 분석)이 가능해야 함

\- ESM은 정적

👉🏻 파일 상단에 고정된 구조

👉🏻 실행 전부터 무엇을 가져오는지 명확함

👉🏻 번들러가 안전하게 트리 셰이킹 가능

\- 현대 프론트엔드는 ESM 선호

👉🏻 트리셰이킹 효과 극대화

👉🏻 성능 최적화

---

### **2️⃣ 블로킹, 논블로킹, 동기, 비동기**

#### **1\. 정의**

**(1) 블로킹**

\- 현재 실행 중인 작업이 완료될 때까지 다음 작업을 기다리는 방식

\- 호출된 함수가 작업을 끝낼 때까지 제어권을 반환하지 않아 현재 흐름이 멈추는 방식

**(2) 논블로킹**

\- 현재 실행중인 작업의 완료를 기다리지 않고 다음 작업을 실행하는 방식

\- 함수를 호출할 때 작업을 끝내지 않아도 즉시 제어권이 호출부로 반환됨

> \- 제어권의 관점에서 보아야 함  
> 👉🏻제어권: 코드를 실행할 수 있는 권리  
> \- 내가 어떤 함수를 호출했을 때 그 함수가 자기 일을 다 마칠 때까지 제어권을 돌려주지 않으면 블로킹  
> \- 요청만 받고 제어권을 즉시 돌려주면 논블로킹

**(3) 동기**

\- 함수 호출 시 결과가 반환될 때까지 기다리는 처리 방식

\- 작업의 시작과 끝이 호출 순서와 일치

**(4) 비동기**

\- 함수 호출과 결과 반환 사이에 다른 작업을 수행할 수 있는 처리 방식

\- 작업을 시켜놓고 기다리지 않고 다음 코드 실행

\- 작업이 끝나면 콜백/Promise/Event로 결과를 알려줌

> \- 순서와 결과 처리의 관점에서 봐야 함  
> \- 어떤 함수에게 일을 시켰을 때, 그 일이 끝나는 순서와 내 코드의 실행 순서가 일치하는지, 그리고 그 결과를 어떻게 처리하는지

> **비동기 vs 논블로킹**  
> \- 논블로킹은 제어권을 즉시 반환하는 것  
> \- 비동기는 결과를 나중에 처리하는 방식

#### **2\. 사용 방법**

**(1) 블로킹**

\- 동기적 API 호출을 통해 구현, 작업 완료 후 다음 명령어로 넘어감

\- 스레드는 작업완료 전까지 CPU 사용 불가(멈춰있음)

> **❓ 제어권**  
> \- 스레드(함수 호출) 관점에서 CPU 실행 흐름이 누구에게 있는지  
> \- CPU 실행의 소유

**(2) 논블로킹**

\- 비동기적 API 호출, 콜백 함수, 프로미스, async/await 등을 이요해 구현

\- 작업 요청 후 바로 다음 명령어 실행

\- 함수를 호출해도 즉시 반환되어, 스레드가 다른 로직을 계속 처리할 수 있음

\- 실제 작업은 백그라운드에서 진행됨

\- 스레드는 블록되지 않고 자유롭게 동작 가능  
  
**(3) 동기**

\- API 호출이나 함수 실행 시 결과를 바로 반환 받음

\- A 스레드가 B 스레드에게 작업 요청 후, 결과가 나올 때까지 로직 자체를 멈추고 기다림

\-> 작업 완료 순간에만 다음 단계 진행

**(4) 비동기**

\- 콜백 함수, Promise, async/await 등을 활용하여 결과를 나중에 받음

\- 동시에 여러 작업 가능 

\- A스레드가 B스레드에게 작업 요청해도 즉시 돌아와 다른 로직 진행 가능

\- B가 작업을 마치면 콜백 / 이벤트로 알리고, A는 그 시점에 후속처리함

#### **3\. 동기 / 블로킹**

\- 제어권과 결과 처리 순서가 동일한 방식

**(1) 제어권(블로킹) 관점**

\-  각 단계가 완료될 때까지 다른 단계는 멈춰있음

**(2) 결과 처리(동기) 관점**

\- 이전 단계 결과가 반드시 준비돼야 다음 단계 진행

#### **4\. 비동기 / 논블로킹**

\- 제어권 실행 즉시 반환

\- 결과에 관계 없이 자신의 작업 진행

\- 결과 처리를 요청 받으면 현재 작업을 마무리 후 해당 결과 처리 작업을 진행

\- 자바스크립트는 비동기/논블로킹 모델을 통해서 효율적으로 처리

**(1) 제어권**

\- 완전히 분산

\- 각자 작업을 스스로 관리해, 누가 끝났는지와 상관없이 다음 단계로 넘어갈 수 있음

**(2) 결과 처리**

\- 독립

\- 비동기적 통지: 둘 다 원할 때 서로에게 완료 정도를 전달할 수 있으나 상대가 기다리는 로직은 없음

#### **5\. JS는 싱글 스레드**

\- 자바스크립트 엔진은 싱글스레드라 한 번에 하나의 작업만 처리 가능

\- 브라우저가 비동기 작업을 대신 처리하고

\- 이벤트 루프가 적절한 타이밍에 콜백을 콜스택에 올려주기에

\- 마치 여러 작업이 동시에 실행되는 것처럼 동작

**(1) 콜스택**

\- 자바스크립트가 지금 실행 중인 함수들을 기록하는 스택 구조

\- 함수 호출하면 스택에 push

👉🏻 함수 종료하면 pop

👉🏻 스택이 비어있어야 다음 비동기 작업 들어올 수 있음

**(2) Web API**

\- 자바스크립트 엔진이 직접 못하는 작업을 대신 처리

\- 타이머, 돔 이벤트, fetch/AJAX 요청

**(3) 매크로 태스크 큐**

\- Web API에서 작업이 완료된 후 콜백이 들어오는 큐

\- 타이머 콜백 함수, DOM 이벤트 콜백

\- fetch 일부 콜백

\- 일반 대기줄 (노멀 큐)

**(4) 마이크로태스크 큐**

\- 자바스크립트에 비동기를 처리하기 위한 Promise의 then(), catch(), finally() 등록된 콜백 함수

\- 좀 더 빠르게 처리해야 하는 작업들

\- VIP 대기줄

**(5) 이벤트 루프**

\- 콜스택과 큐 사이를 계속 감시하는 조율자

\- 동작 규칙

👉🏻 콜스택 비었는지 확인

👉🏻 마이크로태스크 큐 비어있지 않으면 전부 처리

👉🏻 마이크로태스크가 끝나면 태스크큐에서 작업 1개 가져와 실행

👉🏻 반복

\- 마이크로 -> 매크로 순
