
## **🧠 회고**

오늘은 클로저, 프로토타입, 클래스, ES6+ 실무 문법, 동등 비교처럼 자바스크립트의 핵심을 이루는 개념들을 집중적으로 배웠다. 단순히 문법을 외우는 것이 아니라, 자바스크립트가 어떻게 동작하는지 이해하는 시간이었고, 특히 클로저나 프로토타입처럼 언어의 근본 구조를 알게 되니 코드가 더 명확하게 보였다. ES6+ 문법과 동등 비교도 실무에서 왜 중요한지 체감하면서, 앞으로 코드를 쓸 때 더 안정적으로 작성할 수 있겠다는 자신감이 생겼다. 오늘 배운 내용들을 꾸준히 복습해 실제 프로젝트에 자연스럽게 녹여낼 수 있도록 계속 다져가야겠다.

## **🪽 오늘의 다짐**

실력은 절대적인 기준이 아니라 언제나 상대적이고, 누구도 어느 순간 갑자기 완벽해지는 것이 아니다. 업계에서 최고로 평가받는 분들조차 지금도 꾸준히 공부하며 새로운 것을 배우고 있다는 사실을 떠올리면, 실력이란 결국 쌓아야 하는 ‘결과’가 아니라 계속 배우고 나아가려는 ‘태도’에 더 가깝다는 생각이 든다. 지금의 나는 부족해 보일 수 있지만, 꾸준히 복습하고, 이해 안 되는 부분을 질문하고, 직접 손으로 코드를 치면서 한 걸음씩 앞으로 나아가는 이 과정 자체가 이미 실력을 쌓고 있는 시간이다. 완벽해야만 무엇을 할 수 있는 것이 아니라, 배우는 태도를 잃지 않는 사람이 결국 더 멀리 간다는 것을 기억하고 싶다.

---

## **📝 Today I Learned**

### **1️⃣  클로저 사용 사례**

#### **1\. Decouncing과 Throttling**

**(1) 필요한 상황**

\- 이벤트의 과도한 호출

\- 검색창에 글자를 입력할 때마다 관련 검색어 밑에 출력하는 상황

\- 사용자가 브라우저 창 크기를 드래그해서 조절할 때마다 레이아웃을 다시 계산하는 기능

👉🏻 이런 과도한 이벤트 호출을 제어해서 성능 최적화하는 기법

#### **2\. 디바운싱**

(1) 정의

\- 계속 연속되는 이벤트 중에서, 마지막 이벤트가 끝난 뒤 일정 시간(delay) 지나면 딱 한 번만 함수를 실행하는 기술

(2) 예시

\- 사용자가 키보드로 입력할 때 계속 API 요청 보내면 안됨

\- 입력이 멈추고 500ms 지난 후 API 한 번만 보내기

👉🏻 디바운싱

(3) 디바운싱을 만들기 위해 필요한 핵심 개념

\- 새 이벤트가 들어오면 이전 타이머를 취소해야 함

(4) 타이머 ID를 어디에 저장해야 하나?

\- 전역 변수에 저장하면 안됨

👉🏻 페이지에 디바운스가 여러 개 쓰일 수 있음

👉🏻 전역 변수 하나면 여러 기능이 서로 타이머를 덮어써서 대참사

\- 각 디바운싱 함수마다 독립적인 타이머 보관소 필요

👉🏻 클로저

(5) 디바운싱 함수 구현

```
function debounce(callback, delay) {
	let timerId; // 클로저를 통해서 기억될 상태
	
	// 디바운스가 적용된 새로운 함수를 반환한다.
	return function(...args) {
		// 여기서 반환되는 실제 이벤트 리스너로 사용된다
		// 이함수는 외부의 timerId를 기억하고 있다.
	
		clearTimeout(timerId); // 이전에 설정된 타이머 있다면 취소하는 함수
		
		// delay 이후에 callback 함수를 실행하도록 새로운 타이머를 설정한다.
		timerId = setTimeout(() => {
			callback(...args);
		}, delay);
	};

}


// 사용 예시
const searchAPI = (keword) => console.log('`${keword}`로 API 검색 요청 ');
const debouncedSearch = debounce(serarchAPI, 500); // searchAPI를 500ms로 debounce

inputElement.addEventListner('input', (e) => debouncedSearch(e.target.value)
```

**(6) 클로저가 왜 필요?**

\- debounce()가 끝난 뒤에도 반환된 함수가 timerId를 계속 기억하기 때문

\- 이벤트가 발생할 때마다 timerId에 접근 가능, 이전 타이머 취소 가능, 새 타이머 등록 가능

\- debounce()를 여러 번 호출하면 각각 독립된 timerId 기억하므로 서로 영향을 주지 않음

#### **3\. 쓰로틀링**

(1) 정의

\- 일정 시간 함수가 최대 한 번만 실행되도록 제한하는 기술

(2) 예시

\- 스크롤 이벤트는 1초에 60번 이상 발생함

\- 이걸 매번 처리하면 브라우저가 버벅거림

\- 그래서 100ms에 딱 1번만 실행하게 제한

👉🏻 쓰로틀링

| **디바운싱** | “이벤트가 끝난 뒤” 한 번 | 검색, 자동완성 |
| --- | --- | --- |
| **쓰로틀링** | “일정 간격마다” 한 번 | 스크롤, 리사이즈, 애니메이션 |

#### **4\. React Hook (useState, useEffect)**

(1) React 함수형 컴포넌트의 특징

\- 함수형 컴포넌트는 상태가 변할 때마다 전체 함수가 다시 실행(리렌더링) 됨

\- JS 규칙대로라면 함수가 다시 실행되면 내부 변수는 초기화되어야 한다

\- 하지만 React는 상태 값을 계속 유지함 -> 상태 관리 시스템이 따로 존재하기 때문

(2) useState 동작 원리

```
const [count, setCount] = useState(0);
```

\- React는 컴포넌트마다 상태 저장 공간을 따로 유지함

\- 첫 번째 상태의 기본값을 0으로 기록해줌

\- setCount 반환

useState는 다음 두 값을 반환 : 현재 상태 값(count), 상태를 변경하는 함수 (setCount)

\- setCount는 어떤 컴포넌트의 어떤 상태를 바꿔야 하는지를 내부적으로 기억함

👉🏻 클로저 유사 구조

(3) setCount 실행 시 일어나는 일

```
setCount(count + 1);
```

\- setCount는 React에게 요청함

👉🏻 이 컴포넌트의 첫 번째 상태를 (count + 1)로 바꿔줘

\- 리액트는 상태를 업데이트한 뒤 컴포넌트를 다시 렌더 -> 함수 재실행

\- 재실행 시에도 useState(0)은 0을 쓰지 않고 -> React가 저장한 새로운 상태 값을 반환

👉🏻 따라서 count는 0 -> 1 -> 2 -> 3 형태로 증가함

(4) 클로저와 useState의 관계

\- 리액트 내부에는 컴포넌트별로 별도의 상태 저장소가 있음

\- useState가 반환하는 setCount는 해당 저장소와 연결된 키 역할을 함

\- setCount는 자기가 어떤 상태를 바꿔야하는지 기억하고 있기 때문에 계속 렌더되어도 상태가 유지됨

(5) 클로저가 만들어내는 메모리 누수 문제

\- 클로저는 상위 스코프를 계속 기억하기에 필요 없는 값도 메모리에 남아 GC가 수거 못할 수 있음

#### **5\. 정리**

\- 클로저는 함수와 그 함수가 선언된 환경 (렉시컬 환경, 실행 컨텍스트의 구성요소)의 조합

\- 핵심은 함수가 자신이 태어난 환경을 기억함

👉🏻이를 통해 함수가 외부 스코프의 변수에 접근할 수 있음

👉🏻 변수의 상태를 계속 유지하고 관리할 수 있다

\- 캡슐화, 디바운싱, 성능 최적화, 모듈 구현 다양하게 써볼 수 있음

\- 주의할 점은 메모리 누수

---

### **2️⃣  프로토타입**

#### **1\. 정의**

\- 객체가 새로 생성될 때마다 그 객체가 기본적으로 갖게 되는 상속받을 수 있는 속성과 메서드들의 집합

\- 객체들의 원본 또는 부모 역할을 하는 객체

\- 어떤 객체가 만들어질 때 그 객체는 자신의 프로토타입 객체로부터 속성이나 기능들을 물려받을 수 있음

\- 자바스크립트에서 상속을 구현하는 핵심 원리

\- Java에서 클래스는 설계도, 객체를 생성하기 위한 명세서, 블루 프린트

👉🏻청사진 자체는 메모리에 존재하는 실체 아니고 어떤 행동도 할 수 없음

👉🏻 new 키워드를 통해 인스턴스화 될 때 객체라는 실체가 만들어짐

\- JavaScript에서의 프로토타입

👉🏻 살아있는 원본 객체, 청사진이 아님, 수행할 수 있는 실제 객체라는 점이 큰 차이점

👉🏻 Java의 클래스가 자동차 설계도라면 자바스크립트의 프로토타입은 우리가 직접 만지고 부품 추가할 수 있는 프로토타입 자동차(시제품) 그 자체 

#### **2\. 사용 이유**

\- 객체 간의 공통 기능을 재사용해서 상속을 메모리 사용면에 있어 효율적으로 하기 위함

#### **3\. 사용 방법**

\- 객체명.prototype.새로운속성명 = 값   형태로 속성이나 메서드를 추가

```
house.prototype.laptop = 'LG';
```

(1) 생성자 함수와 인스턴스

```
function House() {
  this.door = "Red";  // 각 객체가 독립적으로 가지는 속성
}

const myHouse = new House(); // 인스턴스 생성
```

\- House = 설계도 (부모 객체)

\- myHouse = 설계도로 만든 실제 집 (인스턴스)

\- 인스턴스는 자신의 고유 속성을 가짐 (예: myHouse.door = "Red")

(2) 공통 기능 (메서드)는 프로토타입에 둔다

```
House.prototype.turnOnLight = function() {
  console.log("불");
};
```

\- 메소드를 인스턴스마다 만들면 메모리 낭비니까

\- 해결: House.prototype에 메소드 1개만 저장

(3) \[\[Prototype\]\] (숨겨진 링크)

\- 모든 JS 객체는 내부적으로 \[\[Prototype\]\] 이라는 숨겨진 링크를 가지고 있다.

-   역할: 이 객체가 누구에게서 메소드를 물려받았는지 연결하는 링크
-   브라우저에서는 \_\_proto\_\_ 로 확인 가능

(4) 프로토타입 체인

```
myHouse.turnOnLight();
```

1.  myHouse 자체에 turnOnLight가 있는가? → ❌ 없음
2.  \[\[Prototype\]\] 링크를 따라 House.prototype으로 이동
3.  House.prototype에 turnOnLight 있음 → 여기서 실행
4.  만약 없다면?
    -   House.prototype의 부모로 이동 (Object.prototype)
    -   또 없으면 → null까지 도달
    -   이런 식으로 위로 계속 올라가는 구조 = 프로토타입 체인

\- 모든 객체의 최종 조상: Object.prototype

#### **4\. 클래스 기반 상속 vs JS 프로토타입 상속**

\- Java, C++

-   클래스(class) 중심
-   상속 관계가 정적으로 결정됨

\- JS

-   객체가 다른 객체를 참조하는 방식
-   상속의 주체가 클래스가 아니라 객체
-   동적으로 프로토타입 체인을 따라 올라가며 메소드 탐색

#### **5\. Array.prototype 예시**

```
var list = [5, 8, 2, 4, 1];
```

list의 프로토타입은 Array.prototype

→ 그래서 list.map, list.filter, list.sort 사용 가능  
→ 이 메소드들은 Array.prototype에 저장됨 (공통 기능)  
→ 모든 배열이 이 메소드들을 공유함

#### **6\. 배열의 고유 속성 vs 공통 행동**

(1) 고유 속성

\- 각 인스턴스만 가지는 값

(2) 공통 행동

\- 모든 배열이 공유하는 기능

\- map, filter, reduce

\- Array,prototype에 1개만 존재

#### **7\. 정리**

\- 프로토타입은 자바스크립트에서 객체 상속의 근간

\- 모든 객체는 자신의 원형인 프로토타입 객체를 가리키는 내부 링크를 가짐

\- 프로토타입 체인을 통해 속성이나 메소드를 찾음

\- 객체 자신에게 없으면 계속해서 프로토타입을 타고 따라서 올라감

---

### **3️⃣ 클래스**

#### **1\. 정의**

\- 관련된 속성과 메서드를 묶어서 객체를 생성하기 위한 템플릿

\- 클래스는 프로토타입을 감싼 문법적 설탕

👉🏻 프로토타입 기반 상속을 더 보기 좋게 포장한 문법

👉🏻 Java와 이름만 같을 뿐 내부 작동 방식은 완전히 다르다

👉🏻 class 키워드로 코드를 작성해도 뒤에서는 prototype으로 동작한다

```
class Car {
  constructor(model) {
    this.model = model;  // 인스턴스 고유 속성
  }

  drive() { // 이 메소드는 어디에 저장될까?
    console.log(`${this.model} is driving`);
  }
}

const myCar = new Car('Model A');
myCar.drive();
```

\- Car.prototype에 저장된다 -> 인스턴스들이 공유함

1) Car 라는 함수를 만듦  
2) Car.prototype 이라는 객체를 자동으로 만듦  
3) 클래스 안의 메소드(drive)를 전부 Car.prototype에 넣음

#### **2\. 사용 이유**

\- 프로토타입을 직접 다루는 것은 코드가 더러워지고 익숙하지 않음

\- 코드를 직관적으로 쉽게 볼 수 있고, 재사용성과 유지보수성을 높이기 위함

#### **3\. 사용 방법**

(1) class 키워드를 사용해서 class를 선언하고 정의

```
class ClassName {
  constructor(params) {
    // 초기화 코드 (this로 속성 설정)
  }

  method1() {
    // 메서드
  }

  method2() {}
}
```

```
class Car {
  constructor(sideMirror, window) {
    this.sideMirror = sideMirror;
    this.window = window;
  }

  accelerator() {
    console.log('움직이기');
  }

  brake() {
    console.log('멈추기');
  }
}

class Bus extends Car {
  constructor(sideMirror, window, wheel) {
    super(sideMirror, window);
    this.wheel = wheel;
  }

  speedLimit() {
    console.log('속도 제한 장치 작동');
  }
}

const sonatine = new Car(2, 4);
const expressBus = new Bus(2, 10, 6);
```

(2) class 표현식을 사용해 class를 정의

\- 익명 클래스 표현식

```
const Car = class {
  constructor(sideMirror, window) {
    this.sideMirror = sideMirror;
    this.window = window;
  }
  accelerator() { ... }
};
```

\- 기명 클래스 표현식

```
const Car = class CarInner {
  constructor(sideMirror, window) { ... }
};
```

\- CarInner라는 이름은 클래스 내부에서만 유효 (자기 자신 참조용)

\- 바깥에서 쓸 때는 Car로 사용

\- 언제 유용?

👉🏻 조건에 따라 서로 다른 클래스를 만들어서 리턴해야 할 때

👉🏻 클래스를 다른 함수의 인자로 넘겨야 할 때

\- 실무에서는 일반 class 선언문이 훨씬 더 자주 쓰임

#### **4\. 프로토타입과 자바 클래스의 차이**

(1) Java

\- 클래스 기반, 정적인 상속

\- 컴파일된 클래스 구조를 런타임에 바꾸기 어려움

(2) JS

\- 프로토타입 기반, 동적인 상속

\- 런타임에 메서드 추가 가능

\- 변경사항은 그 프로토타입을 쓰는 모든 인스턴스에 바로 반영됨

👉🏻 상속의 주체가 Java에선 클래스, JS에선 객체(프로토타입)

#### **5\. 절대 하지 말아야 할 것**

\- 내장 객체 프로토타입 수정

\- 어디서 추가했는지 추적하기 어려움

\- 다른 라이브러리/코드와 충돌날 수 있음

\- 유지보수 지옥

\-> 내장 객체의 프로토타입은 손대지 않는 것이 원칙

\- Array.prototype, Object.prototype 등

#### **6\. 자바스크립트 클래스는 '단순 편의 문법'인가?**

반은 맞고 반은 틀림

(1) 반은 맞다는 이유

\- 내부 동작원리가 여전히 프로토타입

👉🏻 클래스 문법을 사용해도 내부적으로는 프로토타입으로 상속이 이루어진다

\- 자바스크립트에서 class 키워드로 만든 클래스는 사실 특별한 형태의 함수이다. 클래스 내부에 작성한 메서드들은 모두 이 함수의 prototype 객체 안에 저장되고, 클래스에서 new를 사용해 만들어진 인스턴스들은 자신만의 속성만 가지며 메서드는 갖지 않는다. 대신 인스턴스는 내부적으로 연결된 프로토타입 체인을 따라 올라가 Car.prototype같은 부모 객체에 정의된 메서드를 찾아 사용한다. 이런 구조때문에, 겉으로는 클래스 문법을 사용하더라도 실헤로는 자바스크립트의 고유한 프로토타입 기반 상속 방식이 그대로 동작하고 있다는 확실한 근거가 된다.

정리하면?

-   클래스 = 사실은 특별하게 생긴 함수
-   메서드 = 클래스가 아니라 prototype에 저장됨
-   객체는 기능을 직접 갖지 않고 prototype에서 빌려씀
-   그래서 내부적으로는 전부 프로토타입 방식으로 돌아감

(2) 반은 틀리다는 이유

\- new 키워드를 반드시 써야함 

👉🏻 new 키워드 없이 함수처럼 호출하면 타입 에러

👉🏻 기존 생성자 함수는 new 없이 호출하면 this가 전역 객체를 가리킴

👉🏻 클래스는 이런 위험을 원천적으로 차단

\- 호이스팅 동작 방식의 차이

👉🏻 클래스는 함수처럼 호이스팅은 되지만 실제로 사용할 수 있는 시점은 다름

👉🏻 엔진은 코드를 실행하기 전에 "여기에 클래스가 선언될 예정이다"라고 인지하고 내부적으로 미리 등록해둔다

👉🏻 그러나 선언문에 실제로 도달하기 전까지는 클래스가 TDZ 안에 있기 때문에 접근이 완전히 차단된다

👉🏻 그래서 클래스보다 위에서 클래스를 사용하려 하면 레퍼런스 에러가 발생한다

👉🏻 즉, 호이스팅은 되지만, 선언 전에 사용할 수 없도록 잠겨있는 상태이기 때문에 호스팅이 안되는 것처럼 느껴질 뿐이며, 실제로는 제대로 호이스팅 되고 있다.

\- 자바스크립트에서 클래스 내부는 특별한 규칙이 적용되는데, 바로 자동으로 'use strict'가 활성화된다는 점이다

👉🏻 일반 함수에서는 실수로 전역 변수 생성같은 느슨한 동작이 허용될 수 있지만, 클래스 안에서는 이런일이 절대로 일어나지 않는다.

👉🏻 즉, 클래스 본문에 있는 모든 코드 (생성자, 메서드)는 개발자의 의도치 않은 실수를 막기 위해 항상 엄격모드로 실행된다.

👉🏻 use strict를 적지 않아도 클래스 안에서의 코드는 이미 더 안전하고 오류에 민감한 환경에서 동작하고 있다.

---

### **4️⃣ 실무 사용 ES6+ 문법**

#### **1\. 얕은 복사**

(1) 정의

\- 겉부분만 새로 만들고, 안쪽 객체들은 주소만 복사하는 방식

\- 원본과 복사본 겉모양은 다르지만, 내부 객체는 같은 곳(같은 메모리 주소)를 가리킴

\- 안쪽 객체가 변경되면 둘 다 영향 받음

\- 부수효과 발생

(2) 예시

```
const companyCopy = Object.assign({}, company);
companyCopy.departments.development.manager = "최신기술";
```

\-> company.departments.development 도 같이 바뀜

\-> 둘이 안쪽 객체를 공유하고 있기 때문

(3) 리액트에서 왜 문제?

\- 상태는 절대 직접 수정하면 안됨 (불변성)

\- 하지만 얕은 복사를 쓰면 내부는 그대로 연결된 상태라 불변성이 깨짐

\- 화면 업데이트 꼬이고 버그 난무

#### **2\. 깊은 복사**

(1) 정의

\- 안에 있는 모든 객체와 배열까지 완전히 새로 만들어서 복사하는 것

\- 원본과 복사본이 완전히 독립된 객체

\- 안쪽 내용 변경해도 서로 영향 없음

(2) 방식 / 장점 / 단점

| JSON.stringify() + JSON.parse() | 간단 | Date, 함수 등 깨짐 |
| --- | --- | --- |
| structuredClone() | 가장 정확하고 좋음 | 너무 구형 브라우저에서는 미지원 |
| lodash.cloneDeep() | 안정적이고 강력 | 외부 라이브러리 필요 |

#### **3\. Map**

\- key-value로 값을 저장하고 관리한다는 부분에서 object와 비슷함

\- Object는 키로 문자열이나 심볼타입만 사용할 수 있음

→ 만약 다른 타입, 숫자를 키로 사용하려고 해도 내부적으로는 문자열로 변환을 함

(1) Map이 Object보다 좋은 경우

\- 키로 아무 타입이나 사용 가능

👉🏻 숫자, 문자열, 객체, 함수까지 가능

👉🏻 Object는 무조건 문자열로 변환함

\- 캐싱에 매우 유리

👉🏻 객체를 그대로 Key로 사용할 수 있어서 편리

#### **4\. Set**

\-배열에서 중복된 값 제거할 때 쓴다

\- 포함 여부 빠르게 검사하기 위해 쓴다

(1) set이 유용한 이유

\- 중복 제거

\- 빠른 포함 여부 체크 (O(1))

👉🏻 set.has(value) 는 크기가 커도 속도 동일

👉🏻 선택된 태그 목록 관리, 이미 처리된 ID인지 체크, 중복 없이 고유한 값만 저장해야할 때 유용

#### **5\. for...in**

\- 객체의 키 목록을 순회하기 위해서 만들어진 문법

\- 모든 열거 가능한 속성을 순회함

\- 객체 자신의 속성뿐 아니라 프로토타입 체인의 속성도 전부 순회해버림

👉🏻 의도치 않은 값까지 나올 수 있음 (버그)

---

### **5️⃣ 동등 비교**

#### **1\. 정의**

\- 값 또는 타입의 동일성을 평가하는 방식

#### **2\. 사용 이유**

\- 값이나 타입 일치 여부를 정확하게 확인하기 위해

\- React에서는 동등비교를 통해 렌더링을 진행한다

#### **3\. 자바스크립트의 데이터 타입**

\- 원시 타입

| **데이터 유형** | **설명** | **세부 사항** |
| --- | --- | --- |
| undefined | 초기화 시 자동으로 할당되는 값 | 선언되었지만 값이 할당되지 않은 변수 |
| null | 값이 없거나 비어 있다는 값을 표현 | 명시적으로 비어있음을 나타내는 값 |
| Boolean | 참과 거짓을 나타내는 타입 | Falsy: false, 0, -0, NaN, '', "", \`\`, null, undefined   Truthy: Falsy를 제외한 모든 값 |
| Number | 모든 10진수를 표현 | 범위: -(2^53-1)-(2^53-1) |
| BigInt | 아주 큰 정수를 표현하기 위한 타입 | n을 붙이거나 BigInt()함수 사용 |
| String | 변경 불가능한 문자열 데이터 | 문자열은 원시 타입   리터럴 재활용 가능 |
| Symbol | 중복되지 않는 고유값을 나타내기 위해 만들어짐 | Symbol()로 생성   동일한 인수라도 다른 Symbol값 생성   Symbol.for로 글로벌 등록 및 검색 |

 -객체 타입

👉🏻 원시 타입을 제외한 모든 것 (배열, 함수, 정규식, 클래스 등)

👉🏻 변수의 값이 직접 저장되는 것이 아니라 데이터가 저장된 메모리의 주소, 참조가 저장됨 (참조 타입)

👉🏻 데이터가 같은 값을 가진다고 하더라도 참조가 다를 경우 동등 비교에서는 falsy한 결과 보여줌

#### **4\. 동등 비교 방식**

\- ==, ===, Object.is

**(1) 느슨한 동등 비교 (==)**

\- 형 변환 동등 비교

\- 비교하는 두 값의 타입이 다를 경우, 하나의 공통 타입으로 강제 변환을 시도한 후에 값을 비교함

\- 사용 피함

**(2) 엄격한 동등 비교 (===)**

\- 두 값의 타입과 값이 정확히 같은 때만 true 반환

\- 타입변환이 일어나지 않음

**(3) Object.is**

\- ===보다 더 엄격한 비교 실행

#### **5\. 리액트의 동등 비교**

\- 리액트에서 성능 문제가 가장 많이 발생하는 이유는 불필요한 렌더링 때문이다

\- 리액트는 상태나 props가 바뀌면 렌더링해야 한다고 판단하는데, 바뀌었는지 판단하는 기준이 동등 비교이다

\- 참조 타입의 비교방식이 중요해진다

**(1) React.memo**

\- React.memo 감싸진 함수 컴포넌트는 props 변경되었을 때만 리렌더링을 수행한다

👉🏻 props가 변경되었는지를 판단하는 기준은 얕은 비교

\- 만약 props의 값들이 원시타입이면 값 자체를 비교하고 객체나 배열 같은 참조타입이면 메모리 주소를 비교한다

**(2) Hooks 의존성 배열 (userEffect, userMemo...)**

\- object.is로 비교한다

\- 의존성 배열을 비교할 대 object.is를 쓴다

\- 의존성 배열에 객체나 배열을 직접 넣으면 렌더링마다 새로운 참조가 생성되어서 의도치않게 계속 실행되는 문제가 생긴다 

👉🏻 그래서 의존성 배열에는 가급적 원시 값을 넣거나 userMemo, useCallback으로 참조를 고정한 값을 넣어야 한다.

**(3) useState에서 상태 업데이트를 생략**

\- useState의 상태 업데이트 함수를 호출할 때 만약 새로운 값이 이전 값과 object.is 비교를 통해서 같다고 판단되면 리액트는 리렌더링 생략한다.
