## **🧠 회고**

오늘은 딥다이브 + 카카오 멘토링 날이었다.

금요일만 되면 긴장을 잔뜩 하게 되는 것 같다. 그리고 경각심도 생기고 의욕도 타오르는 것 같다.

이론 기간 3주 남았다! 열심히 불태우자. 기초를 쌓자

## **🪽 오늘의 다짐**

1\. 기초를 쌓자

2\. 케빈 말 잘듣기... (조언해주신거 꼭 하기 매일 매일)

---

## **📝 Today I Learned**

**\- 딥다이브 내용 정리**

### **자바스크립트의 콜 스택(Call Stack)과 힙(Heap) 메모리의 차이에 대해 설명하고, 각각에 어떤 데이터가 저장되는지 설명해주세요.**

## 내가 만든 정의

**콜스택**

-   자바스크립트가 현재 어떤 함수를 실행 중인지 관리하는 실행 흐름 제어 영역입니다. 함수가 호출될 때 실행 컨텍스트가 LIFO 방식으로 스택에 쌓이고, 함수가 종료되면 제거됩니다. 즉, 함수 실행 순서를 관리하는 메모리 영역입니다.

**힙 메모리**

-   크기가 크거나 구조가 복잡한 데이터를 저장하는 동적 메모리 영역입니다. 실체 객체는 힙에 저장되고, 스택에는 그 주소만 저장됩니다. 즉, 참조 타입 데이터를 저장하기 위한 넓고 자유로운 메모리 공간입니다.

---

## 세부 설명 (질문에 맞게 변형합니다)

자바스크립트 엔진(대표적: V8)은 콜스택과 힙메모리로 구성되어있다.

둘은 역할과, 처리하는 데이터 타입이 구분된다.

### 1\. 콜스택

콜스택은 JS가 지금 어떤 일을 하고 있는지를 쌓아두는 메모장 같은 역할

자바스크립트는 일을 한 번에 하나씩밖에 못함 → 그래서 일을 하다가 지금 어떤 것을 처리 중인지 잊지 않기 위해 메모장(=스택)을 사용

**(1) 어떻게 작동?**

-   함수가 호출되면 → 스택에 추가됨 (push)
-   함수가 끝나면 → 스택에서 제거됨 (pop)
-   가장 마지막에 들어온 함수가 먼저 실행되는 LIFO 구조

**(2) 예시**

```
function a() {
  b();
}

function b() {
  c();
}

function c() {
  console.log("hi");
}

a();
```

-   진행 과정
    1.  전역 코드 실행 시작
        -   JS는 파일을 실행하면 가장 먼저 전역 실행 컨텍스트를 스택에 넣음\[ Global \]
    2.  a() 함수 호출됨
        -   전역 코드에서 a()가 호출되면, 콜스택 위에 a 실행 컨텍스트가 push 됨\[ Global \] \[ a \]
    3.  a() 내부에서 b() 호출
        -   a가 실행되다가 b()를 만나면, 스택에 b가 push 됨\[ Global \] \[ a \] \[ b \]
    4.  b() 내부에서 c() 호출
        -   b가 실행되다가 c() 호출하니까 c 컨텍스트가 스택에 push\[ Global \] \[ a \] \[ b \] \[ c \]
    5.  c() 실행
        -   console.log("hi");
            -   hi 출력됨
        -   c 함수 실행이 완료되면 스택에서 제거 (pop))
        -   \[ Global \] \[ a \] \[ b \]
    6.  b() 종료 → pop
        -   b 함수는 c() 호출 이후 할 일이 없으므로 끝남 → pop\[ Global \] \[ a \]
    7.  a() 종료 → pop
        -   a도 더 이상 실행할 코드가 없으므로 끝남 → pop\[ Global \]
    8.  전역 실행 종료 → pop
        -   스택이 비어 있음⇒ 최종 출력 결과
-   hi

```
[Global]
[Global, a]
[Global, a, b]
[Global, a, b, c]  → hi 출력
[Global, a, b]
[Global, a]
[Global]
[]
```

**(3) 콜 스택 안에는 어떤 데이터가 저장?**

그 함수가 실행되기 위해 필요한 모든 정보(=실행 컨텍스트)가 들어있다.

-   함수 관련 정보
    -   함수의 이름, 함수의 지역 변수, 매개변수, 어떤 스코프(환경) 안에 있는지, this 값
-   원시값

⇒ 즉, 함수가 실행되려면 필요한 것들이 묶음으로 스택에 쌓여 있다.

-   실행 컨텍스트?자바스크립트 엔진은 코드를 실행하기 전에 실행 컨텍스트를 만들고, 그 안에 변수, 함수, 스코프, this, 환경 정보 등을 미리 정해둠
    -   언제 만들어짐?
        -   전역 코드가 실행될 때 → 전역 실행 컨텍스트가 생성됨
        -   함수가 호출될 때마다 → 함수 실행 컨텍스트가 생성됨⇒ 그래서 함수가 호출되면 콜스택에 쌓임
    -   구조
        -   변수 환경, 렉시컬 환경, this 바인딩
    -   변수 환경
        -   var로 선언한 변수 정보를 저장하는 공간
        -   현재 실행 컨텍스트가 처음 만들어질 때 초기 스냅샷 같은 느낌
    -   렉시컬 환경
        -   현재 스코프의 변수들과 바깥 스코프에 대한 참조를 저장하는 구조
    -   this 바인딩
-   ⇒ 이 함수, 전역을 실행하는 데 필요한 모든 정보를 담아놓은 상자
-   JS가 코드를 실행하기 위해 필요한 모든 정보를 한 곳에 모아놓은 공간

**(4) 원시값은 왜 스택에 들어가는가?**

number, string, boolean, null, undefined, symbol, bigint

원시값은 크기도 작고, 숫자/문자 같은 단일값이라서 스택에 바로 넣기 좋음

-   빠르고 메모리 관리 쉬움

```
const a = 10;
const b = "hello";
```

⇒ 이런 값들은 스택이 직접 기억해도 부담 없음!

**(5) 반대로 객체는 왜 스택에 못들어가는가?**

```
const user = {
  name: "네온",
  age: 3,
};
```

객체는 크기도 크고 모양도 일정하지 않음

이런 대형 데이터는 힙(Heap)이라는 곳에 들어가고, 스택에는 힙 주소만 들어감

### 2\. 힙 메모리

크기 예측이 어렵고 복잡한 데이터(객체, 배열 등)을 저장해두는 곳

-   구조적으로 아무 규칙이 없는 큰 메모리 공간

**(1) 힙메모리가 필요한 이유**

-   객체는 크기도 제각각이고, 언제까지 사용할지 수명도 불확실함

```
const user = {
  name: "네온",
  age: 3,
  hobby: ["놀기", "먹기", "자기"]
};
```

이러한 객체는

크기도 일정하지 않고, 내부에 또 객체가 들어있고, 배열도 크기가 가변함

⇒ 그래서 스택처럼 정해진 크기/규칙이 있는 공간에 담을 수 없음

⇒ 힙이라는 곳에 저장해야함

-   콜스택처럼 순서도 없고, push/pop 규칙도 없음
-   공간이 넓고 자유로움
-   객체가 늘어나면 빈 공간 찾아서 저장
-   객체가 사라지면 공간이 비워지고, 다음에 다른 객체가 들어가기도 함

**(2) 힙에는 어떤 데이터가 저장?**

참조 타입이 저장된다

-   Object
-   Array
-   Function
-   Date
-   RegExp
-   Map / Set
-   클로저가 가진 은닉된 변수들
-   DOM 노드

⇒ 즉, 원시 값이 아닌 모든 것이 힙에 저장됨

**(3) 힙과 가비지 컬렉션(GC)**

자바스크립트의 GC는 힙 메모리를 계속 감시함

더 이상 아무 변수도 해당 객체를 가리키지 않으면

→ 필요없는 데이터로 판단

→ 힙에서 자동으로 삭제함

---

### 3\. 정리

자바스크립트에서 콜 스택은 코드 실행 흐름을 제어하고, 힙은 복잡한 데이터를 저장하는 역할을 합니다.

콜 스택은 함수가 호출될 때마다 실행 컨텍스트가 LIFO 방식으로 쌓이며, 여기에는 지역 변수, 매개 변수, 스코프 체인, this 같은 실행에 필요한 정보, 즉 실행 컨텍스트가 포함됩니다. 숫자나 문자열같은 원시 타입도 크기가 작기 때문에 스택에 저장됩니다.

반대로 힙에는 객체, 배열, 함수처럼 크기가 가변적이거나 구조가 복잡한 데이터가 저장됩니다. 이때 스택에는 데이터 자체가 아니라 힙에 저장된 위치를 가리키는 참조값만 들어갑니다. 또한 힙에 있는 데이터는 참조가 더 이상 남아 있지 않을 때 가비지 컬렉터가 자동으로 메모리를 회수합니다.

결론적으로 스택은 실행 제어, 힙은 데이터 저장에 특화된 영역입니다.
